{"ast":null,"code":"\"use strict\";\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar cross_spawn_1 = __importDefault(require(\"cross-spawn\"));\n\nfunction spawnAsync(command, args) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var fakeErr = new Error('fake error just to preserve stacktrace');\n  var previousStack = fakeErr.stack && fakeErr.stack.split('\\n').splice(1);\n  var previousStackString = previousStack && ['    ...'].concat(_toConsumableArray(previousStack)).join('\\n');\n  var child;\n  var promise = new Promise(function (resolve, reject) {\n    var ignoreStdio = options.ignoreStdio,\n        nodeOptions = __rest(options, [\"ignoreStdio\"]);\n\n    child = cross_spawn_1.default(command, args, nodeOptions);\n    var stdout = '';\n    var stderr = '';\n\n    if (!ignoreStdio) {\n      if (child.stdout) {\n        child.stdout.on('data', function (data) {\n          stdout += data;\n        });\n      }\n\n      if (child.stderr) {\n        child.stderr.on('data', function (data) {\n          stderr += data;\n        });\n      }\n    }\n\n    var completionListener = function completionListener(code, signal) {\n      child.removeListener('error', errorListener);\n      var result = {\n        pid: child.pid,\n        output: [stdout, stderr],\n        stdout: stdout,\n        stderr: stderr,\n        status: code,\n        signal: signal\n      };\n\n      if (code !== 0) {\n        var error = signal ? new Error(command + \" exited with signal: \" + signal) : new Error(command + \" exited with non-zero code: \" + code);\n\n        if (error.stack && previousStackString) {\n          error.stack += \"\\n\" + previousStackString;\n        }\n\n        _extends(error, result);\n\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    };\n\n    var errorListener = function errorListener(error) {\n      if (ignoreStdio) {\n        child.removeListener('exit', completionListener);\n      } else {\n        child.removeListener('close', completionListener);\n      }\n\n      _extends(error, {\n        pid: child.pid,\n        output: [stdout, stderr],\n        stdout: stdout,\n        stderr: stderr,\n        status: null,\n        signal: null\n      });\n\n      reject(error);\n    };\n\n    if (ignoreStdio) {\n      child.once('exit', completionListener);\n    } else {\n      child.once('close', completionListener);\n    }\n\n    child.once('error', errorListener);\n  });\n  promise.child = child;\n  return promise;\n}\n\nexports.default = spawnAsync;","map":{"version":3,"sources":["../src/spawnAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChildProcess, SpawnOptions as NodeSpawnOptions } from 'child_process';\nimport spawn from 'cross-spawn';\n\nexport interface SpawnOptions extends NodeSpawnOptions {\n  ignoreStdio?: boolean;\n}\n\nexport interface SpawnPromise<T> extends Promise<T> {\n  child: ChildProcess;\n}\n\nexport interface SpawnResult {\n  pid: number;\n  output: string[];\n  stdout: string;\n  stderr: string;\n  status: number | null;\n  signal: string | null;\n}\n\nexport default function spawnAsync(\n  command: string,\n  args?: ReadonlyArray<string>,\n  options: SpawnOptions = {}\n): SpawnPromise<SpawnResult> {\n  const fakeErr = new Error('fake error just to preserve stacktrace');\n  const previousStack = fakeErr.stack && fakeErr.stack.split('\\n').splice(1);\n  const previousStackString = previousStack && ['    ...', ...previousStack].join('\\n');\n\n  let child: ChildProcess;\n  let promise = new Promise((resolve, reject) => {\n    let { ignoreStdio, ...nodeOptions } = options;\n    // @ts-ignore: cross-spawn declares \"args\" to be a regular array instead of a read-only one\n    child = spawn(command, args, nodeOptions);\n    let stdout = '';\n    let stderr = '';\n\n    if (!ignoreStdio) {\n      if (child.stdout) {\n        child.stdout.on('data', data => {\n          stdout += data;\n        });\n      }\n\n      if (child.stderr) {\n        child.stderr.on('data', data => {\n          stderr += data;\n        });\n      }\n    }\n\n    let completionListener = (code: number | null, signal: string | null) => {\n      child.removeListener('error', errorListener);\n      let result: SpawnResult = {\n        pid: child.pid,\n        output: [stdout, stderr],\n        stdout,\n        stderr,\n        status: code,\n        signal,\n      };\n      if (code !== 0) {\n        let error = signal\n          ? new Error(`${command} exited with signal: ${signal}`)\n          : new Error(`${command} exited with non-zero code: ${code}`);\n        if (error.stack && previousStackString) {\n          error.stack += `\\n${previousStackString}`;\n        }\n        Object.assign(error, result);\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    };\n\n    let errorListener = (error: Error) => {\n      if (ignoreStdio) {\n        child.removeListener('exit', completionListener);\n      } else {\n        child.removeListener('close', completionListener);\n      }\n      Object.assign(error, {\n        pid: child.pid,\n        output: [stdout, stderr],\n        stdout,\n        stderr,\n        status: null,\n        signal: null,\n      });\n      reject(error);\n    };\n\n    if (ignoreStdio) {\n      child.once('exit', completionListener);\n    } else {\n      child.once('close', completionListener);\n    }\n    child.once('error', errorListener);\n  }) as SpawnPromise<SpawnResult>;\n  // @ts-ignore: TypeScript isn't aware the Promise constructor argument runs synchronously and\n  // thinks `child` is not yet defined\n  promise.child = child;\n  return promise;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}