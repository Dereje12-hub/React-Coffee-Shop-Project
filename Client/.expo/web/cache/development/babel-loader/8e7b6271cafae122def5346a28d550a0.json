{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar debug_1 = tslib_1.__importDefault(require(\"debug\"));\n\nvar crypto_1 = tslib_1.__importDefault(require(\"crypto\"));\n\nvar fs_1 = require(\"fs\");\n\nvar rimraf_1 = require(\"rimraf\");\n\nvar shared_1 = require(\"./shared\");\n\nvar utils_1 = require(\"../utils\");\n\nvar user_interface_1 = tslib_1.__importDefault(require(\"../user-interface\"));\n\nvar debug = debug_1.default('devcert:platforms:windows');\nvar encryptionKey;\n\nvar WindowsPlatform = function () {\n  function WindowsPlatform() {\n    _classCallCheck(this, WindowsPlatform);\n\n    this.HOST_FILE_PATH = 'C:\\\\Windows\\\\System32\\\\Drivers\\\\etc\\\\hosts';\n  }\n\n  _createClass(WindowsPlatform, [{\n    key: \"addToTrustStores\",\n    value: function addToTrustStores(certificatePath) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return tslib_1.__awaiter(this, void 0, void 0, _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                debug('adding devcert root to Windows OS trust store');\n\n                try {\n                  utils_1.run('certutil', ['-addstore', '-user', 'root', certificatePath]);\n                } catch (e) {\n                  e.output.map(function (buffer) {\n                    if (buffer) {\n                      console.log(buffer.toString());\n                    }\n                  });\n                }\n\n                debug('adding devcert root to Firefox trust store');\n                _context.prev = 3;\n                _context.next = 6;\n                return shared_1.openCertificateInFirefox('start firefox', certificatePath);\n\n              case 6:\n                _context.next = 11;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](3);\n                debug('Error opening Firefox, most likely Firefox is not installed');\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[3, 8]]);\n      }));\n    }\n  }, {\n    key: \"removeFromTrustStores\",\n    value: function removeFromTrustStores(certificatePath) {\n      debug('removing devcert root from Windows OS trust store');\n\n      try {\n        console.warn('Removing old certificates from trust stores. You may be prompted to grant permission for this. It\\'s safe to delete old devcert certificates.');\n        utils_1.run('certutil', ['-delstore', '-user', 'root', 'devcert']);\n      } catch (e) {\n        debug(\"failed to remove \" + certificatePath + \" from Windows OS trust store, continuing. \" + e.toString());\n      }\n    }\n  }, {\n    key: \"addDomainToHostFileIfMissing\",\n    value: function addDomainToHostFileIfMissing(domain) {\n      return tslib_1.__awaiter(this, void 0, void 0, _regeneratorRuntime.mark(function _callee2() {\n        var hostsFileContents;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                hostsFileContents = fs_1.readFileSync(this.HOST_FILE_PATH, 'utf8');\n\n                if (hostsFileContents.includes(domain)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                _context2.next = 4;\n                return utils_1.sudo(\"echo 127.0.0.1  \" + domain + \" >> \" + this.HOST_FILE_PATH);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"deleteProtectedFiles\",\n    value: function deleteProtectedFiles(filepath) {\n      shared_1.assertNotTouchingFiles(filepath, 'delete');\n      rimraf_1.sync(filepath);\n    }\n  }, {\n    key: \"readProtectedFile\",\n    value: function readProtectedFile(filepath) {\n      return tslib_1.__awaiter(this, void 0, void 0, _regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                shared_1.assertNotTouchingFiles(filepath, 'read');\n\n                if (encryptionKey) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                _context3.next = 4;\n                return user_interface_1.default.getWindowsEncryptionPassword();\n\n              case 4:\n                encryptionKey = _context3.sent;\n\n              case 5:\n                _context3.prev = 5;\n                return _context3.abrupt(\"return\", this.decrypt(fs_1.readFileSync(filepath, 'utf8'), encryptionKey));\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](5);\n\n                if (!(_context3.t0.message.indexOf('bad decrypt') >= -1)) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                encryptionKey = null;\n                _context3.next = 15;\n                return this.readProtectedFile(filepath);\n\n              case 15:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 16:\n                throw _context3.t0;\n\n              case 17:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[5, 9]]);\n      }));\n    }\n  }, {\n    key: \"writeProtectedFile\",\n    value: function writeProtectedFile(filepath, contents) {\n      return tslib_1.__awaiter(this, void 0, void 0, _regeneratorRuntime.mark(function _callee4() {\n        var encryptedContents;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                shared_1.assertNotTouchingFiles(filepath, 'write');\n\n                if (encryptionKey) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                _context4.next = 4;\n                return user_interface_1.default.getWindowsEncryptionPassword();\n\n              case 4:\n                encryptionKey = _context4.sent;\n\n              case 5:\n                encryptedContents = this.encrypt(contents, encryptionKey);\n                fs_1.writeFileSync(filepath, encryptedContents);\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(text, key) {\n      var cipher = crypto_1.default.createCipher('aes256', new Buffer(key));\n      return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\n    }\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(encrypted, key) {\n      var decipher = crypto_1.default.createDecipher('aes256', new Buffer(key));\n      return decipher.update(encrypted, 'hex', 'utf8') + decipher.final('utf8');\n    }\n  }]);\n\n  return WindowsPlatform;\n}();\n\nexports.default = WindowsPlatform;","map":{"version":3,"sources":["platforms/win32.ts"],"names":[],"mappings":"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","sourcesContent":["import createDebug from 'debug';\nimport crypto from 'crypto';\nimport { writeFileSync as write, readFileSync as read } from 'fs';\nimport { sync as rimraf } from 'rimraf';\nimport { Options } from '../index';\nimport { assertNotTouchingFiles, openCertificateInFirefox } from './shared';\nimport { Platform } from '.';\nimport { run, sudo } from '../utils';\nimport UI from '../user-interface';\n\nconst debug = createDebug('devcert:platforms:windows');\n\nlet encryptionKey: string;\n\nexport default class WindowsPlatform implements Platform {\n\n  private HOST_FILE_PATH = 'C:\\\\Windows\\\\System32\\\\Drivers\\\\etc\\\\hosts';\n\n  /**\n   * Windows is at least simple. Like macOS, most applications will delegate to\n   * the system trust store, which is updated with the confusingly named\n   * `certutil` exe (not the same as the NSS/Mozilla certutil). Firefox does it's\n   * own thing as usual, and getting a copy of NSS certutil onto the Windows\n   * machine to try updating the Firefox store is basically a nightmare, so we\n   * don't even try it - we just bail out to the GUI.\n   */\n  async addToTrustStores(certificatePath: string, options: Options = {}): Promise<void> {\n    // IE, Chrome, system utils\n    debug('adding devcert root to Windows OS trust store')\n    try {\n      run('certutil', ['-addstore', '-user', 'root', certificatePath]);\n    } catch (e) {\n      e.output.map((buffer: Buffer) => {\n        if (buffer) {\n          console.log(buffer.toString());\n        }\n      });\n    }\n    debug('adding devcert root to Firefox trust store')\n    // Firefox (don't even try NSS certutil, no easy install for Windows)\n    try {\n      await openCertificateInFirefox('start firefox', certificatePath);\n    } catch {\n      debug('Error opening Firefox, most likely Firefox is not installed');\n    }\n  }\n  \n  removeFromTrustStores(certificatePath: string) {\n    debug('removing devcert root from Windows OS trust store');\n    try {\n      console.warn('Removing old certificates from trust stores. You may be prompted to grant permission for this. It\\'s safe to delete old devcert certificates.');\n      run('certutil', ['-delstore', '-user', 'root', 'devcert']);\n    } catch (e) {\n      debug(`failed to remove ${ certificatePath } from Windows OS trust store, continuing. ${ e.toString() }`)\n    }\n  }\n\n  async addDomainToHostFileIfMissing(domain: string) {\n    let hostsFileContents = read(this.HOST_FILE_PATH, 'utf8');\n    if (!hostsFileContents.includes(domain)) {\n      await sudo(`echo 127.0.0.1  ${ domain } >> ${ this.HOST_FILE_PATH }`);\n    }\n  }\n  \n  deleteProtectedFiles(filepath: string) {\n    assertNotTouchingFiles(filepath, 'delete');\n    rimraf(filepath);\n  }\n\n  async readProtectedFile(filepath: string): Promise<string> {\n    assertNotTouchingFiles(filepath, 'read');\n    if (!encryptionKey) {\n      encryptionKey = await UI.getWindowsEncryptionPassword();\n    }\n    // Try to decrypt the file\n    try {\n      return this.decrypt(read(filepath, 'utf8'), encryptionKey);\n    } catch (e) {\n      // If it's a bad password, clear the cached copy and retry\n      if (e.message.indexOf('bad decrypt') >= -1) {\n        encryptionKey = null;\n        return await this.readProtectedFile(filepath);\n      }\n      throw e;\n    }\n  }\n\n  async writeProtectedFile(filepath: string, contents: string) {\n    assertNotTouchingFiles(filepath, 'write');\n    if (!encryptionKey) {\n      encryptionKey = await UI.getWindowsEncryptionPassword();\n    }\n    let encryptedContents = this.encrypt(contents, encryptionKey);\n    write(filepath, encryptedContents);\n  }\n\n  private encrypt(text: string, key: string) {\n    let cipher = crypto.createCipher('aes256', new Buffer(key));\n    return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\n  }\n\n  private decrypt(encrypted: string, key: string) {\n    let decipher = crypto.createDecipher('aes256', new Buffer(key));\n    return decipher.update(encrypted, 'hex', 'utf8') + decipher.final('utf8');\n  }\n\n}"],"sourceRoot":"/Users/evanbacon/Documents/GitHub/devcert/"},"metadata":{},"sourceType":"script"}