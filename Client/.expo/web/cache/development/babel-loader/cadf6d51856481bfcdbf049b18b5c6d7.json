{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readResourcesXMLAsync = readResourcesXMLAsync;\nexports.ensureDefaultResourceXML = ensureDefaultResourceXML;\nexports.buildResourceItem = buildResourceItem;\nexports.buildResourceGroup = buildResourceGroup;\nexports.findResourceGroup = findResourceGroup;\nexports.getResourceItemsAsObject = getResourceItemsAsObject;\nexports.getObjectAsResourceItems = getObjectAsResourceItems;\nexports.getObjectAsResourceGroup = getObjectAsResourceGroup;\n\nfunction _XML() {\n  var data = require(\"../utils/XML\");\n\n  _XML = function _XML() {\n    return data;\n  };\n\n  return data;\n}\n\nvar fallbackResourceString = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><resources></resources>\";\n\nfunction readResourcesXMLAsync(_ref) {\n  var path, _ref$fallback, fallback, xml;\n\n  return _regeneratorRuntime.async(function readResourcesXMLAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          path = _ref.path, _ref$fallback = _ref.fallback, fallback = _ref$fallback === void 0 ? fallbackResourceString : _ref$fallback;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap((0, _XML().readXMLAsync)({\n            path: path,\n            fallback: fallback\n          }));\n\n        case 3:\n          xml = _context.sent;\n\n          if (!xml.resources) {\n            xml.resources = {};\n          }\n\n          return _context.abrupt(\"return\", xml);\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction ensureDefaultResourceXML(xml) {\n  if (!xml) {\n    xml = {\n      resources: {}\n    };\n  }\n\n  if (!xml.resources) {\n    xml.resources = {};\n  }\n\n  return xml;\n}\n\nfunction buildResourceItem(_ref2) {\n  var name = _ref2.name,\n      value = _ref2.value,\n      targetApi = _ref2.targetApi,\n      translatable = _ref2.translatable;\n  var item = {\n    $: {\n      name: name\n    },\n    _: value\n  };\n\n  if (targetApi) {\n    item.$['tools:targetApi'] = targetApi;\n  }\n\n  if (translatable !== undefined) {\n    item.$['translatable'] = String(translatable);\n  }\n\n  return item;\n}\n\nfunction buildResourceGroup(parent) {\n  var _parent$items;\n\n  return {\n    $: {\n      name: parent.name,\n      parent: parent.parent\n    },\n    item: (_parent$items = parent.items) !== null && _parent$items !== void 0 ? _parent$items : []\n  };\n}\n\nfunction findResourceGroup(xml, group) {\n  var _xml$filter, _xml$filter$call;\n\n  var app = xml === null || xml === void 0 ? void 0 : (_xml$filter = xml.filter) === null || _xml$filter === void 0 ? void 0 : (_xml$filter$call = _xml$filter.call(xml, function (_ref3) {\n    var head = _ref3.$;\n    var matches = head.name === group.name;\n\n    if (group.parent != null && matches) {\n      matches = head.parent === group.parent;\n    }\n\n    return matches;\n  })) === null || _xml$filter$call === void 0 ? void 0 : _xml$filter$call[0];\n  return app !== null && app !== void 0 ? app : null;\n}\n\nfunction getResourceItemsAsObject(xml) {\n  return xml.reduce(function (prev, curr) {\n    return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, curr.$.name, curr._));\n  }, {});\n}\n\nfunction getObjectAsResourceItems(obj) {\n  return Object.entries(obj).map(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        name = _ref5[0],\n        value = _ref5[1];\n\n    return {\n      $: {\n        name: name\n      },\n      _: value\n    };\n  });\n}\n\nfunction getObjectAsResourceGroup(group) {\n  return {\n    $: {\n      name: group.name,\n      parent: group.parent\n    },\n    item: getObjectAsResourceItems(group.item)\n  };\n}","map":{"version":3,"sources":["../../src/android/Resources.ts"],"names":["fallbackResourceString","fallback","xml","path","resources","translatable","item","$","name","_","value","String","parent","app","head","matches","group","curr","getObjectAsResourceItems"],"mappings":"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","sourcesContent":["import { readXMLAsync, XMLObject } from '../utils/XML';\n\nexport type ResourceGroupXML = {\n  $: {\n    name: string;\n    parent: string;\n  };\n  item: ResourceItemXML[];\n};\n\nexport type ResourceXML = {\n  resources: {\n    $?: {\n      'xmlns:tools'?: string;\n    };\n    color?: ResourceItemXML[];\n    string?: ResourceItemXML[];\n    style?: ResourceGroupXML[];\n    // Add more if needed...\n  };\n};\n\nexport type ResourceItemXML = {\n  _: string;\n  $: {\n    name: string;\n    'tools:targetApi'?: string;\n    translatable?: string;\n  };\n};\n/**\n * Name of the resource folder.\n */\nexport type ResourceKind =\n  | 'values'\n  | 'values-night'\n  | 'values-v23'\n  | 'values-night-v23'\n  | 'drawable';\n\nconst fallbackResourceString = `<?xml version=\"1.0\" encoding=\"utf-8\"?><resources></resources>`;\n\n/**\n * Read an XML file while providing a default fallback for resource files.\n *\n * @param options path to the XML file, returns a fallback XML if the path doesn't exist.\n */\nexport async function readResourcesXMLAsync({\n  path,\n  fallback = fallbackResourceString,\n}: {\n  path: string;\n  fallback?: string | null;\n}): Promise<ResourceXML> {\n  const xml = await readXMLAsync({ path, fallback });\n  // Ensure the type is expected.\n  if (!xml.resources) {\n    xml.resources = {};\n  }\n  return xml as ResourceXML;\n}\n\n/**\n * Ensure the provided xml has a `resources` object (the expected shape).\n *\n * @param xml\n */\nexport function ensureDefaultResourceXML(xml: XMLObject): ResourceXML {\n  if (!xml) {\n    xml = { resources: {} };\n  }\n  if (!xml.resources) {\n    xml.resources = {};\n  }\n\n  return xml as ResourceXML;\n}\n\n/**\n * Build a `ResourceItemXML` given its `name` and `value`. This makes things a bit more readable.\n *\n * - JSON: `{ $: { name }, _: value }`\n * - XML: `<item name=\"NAME\">VALUE</item>`\n *\n * @param props name and value strings.\n */\nexport function buildResourceItem({\n  name,\n  value,\n  targetApi,\n  translatable,\n}: {\n  name: string;\n  value: string;\n  targetApi?: string;\n  translatable?: boolean;\n}): ResourceItemXML {\n  const item: ResourceItemXML = { $: { name }, _: value };\n  if (targetApi) {\n    item.$['tools:targetApi'] = targetApi;\n  }\n  if (translatable !== undefined) {\n    item.$['translatable'] = String(translatable);\n  }\n  return item;\n}\n\nexport function buildResourceGroup(parent: {\n  name: string;\n  parent: string;\n  items?: ResourceItemXML[];\n}): ResourceGroupXML {\n  return {\n    $: { name: parent.name, parent: parent.parent },\n    item: parent.items ?? [],\n  };\n}\n\nexport function findResourceGroup(\n  xml: ResourceGroupXML[] | undefined,\n  group: { name: string; parent?: string }\n): ResourceGroupXML | null {\n  const app = xml?.filter?.(({ $: head }) => {\n    let matches = head.name === group.name;\n    if (group.parent != null && matches) {\n      matches = head.parent === group.parent;\n    }\n    return matches;\n  })?.[0];\n  return app ?? null;\n}\n\n/**\n * Helper to convert a basic XML object into a simple k/v pair.\n *\n * @param xml\n * @returns\n */\nexport function getResourceItemsAsObject(xml: ResourceItemXML[]): Record<string, string> | null {\n  return xml.reduce(\n    (prev, curr) => ({\n      ...prev,\n      [curr.$.name]: curr._,\n    }),\n    {}\n  );\n}\n\n/**\n * Helper to convert a basic k/v object to a ResourceItemXML array.\n *\n * @param xml\n * @returns\n */\nexport function getObjectAsResourceItems(obj: Record<string, string>): ResourceItemXML[] {\n  return Object.entries(obj).map(([name, value]) => ({\n    $: { name },\n    _: value,\n  }));\n}\n\nexport function getObjectAsResourceGroup(group: {\n  name: string;\n  parent: string;\n  item: Record<string, string>;\n}): ResourceGroupXML {\n  return {\n    $: {\n      name: group.name,\n      parent: group.parent,\n    },\n    item: getObjectAsResourceItems(group.item),\n  };\n}\n"]},"metadata":{},"sourceType":"script"}