{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolvePluginForModule = resolvePluginForModule;\nexports.moduleNameIsDirectFileReference = moduleNameIsDirectFileReference;\nexports.normalizeStaticPlugin = normalizeStaticPlugin;\nexports.assertInternalProjectRoot = assertInternalProjectRoot;\nexports.resolveConfigPluginFunction = resolveConfigPluginFunction;\nexports.resolveConfigPluginFunctionWithInfo = resolveConfigPluginFunctionWithInfo;\nexports.resolveConfigPluginExport = resolveConfigPluginExport;\nexports.pluginFileName = void 0;\n\nfunction _assert() {\n  var data = _interopRequireDefault(require(\"assert\"));\n\n  _assert = function _assert() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _findUp() {\n  var data = _interopRequireDefault(require(\"find-up\"));\n\n  _findUp = function _findUp() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  var data = _interopRequireWildcard(require(\"path\"));\n\n  path = function path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _resolveFrom() {\n  var data = _interopRequireDefault(require(\"resolve-from\"));\n\n  _resolveFrom = function _resolveFrom() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _errors() {\n  var data = require(\"./errors\");\n\n  _errors = function _errors() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _modules() {\n  var data = require(\"./modules\");\n\n  _modules = function _modules() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar pluginFileName = 'app.plugin.js';\nexports.pluginFileName = pluginFileName;\n\nfunction findUpPackageJson(root) {\n  var packageJson = _findUp().default.sync('package.json', {\n    cwd: root\n  });\n\n  (0, _assert().default)(packageJson, \"No package.json found for module \\\"\" + root + \"\\\"\");\n  return packageJson;\n}\n\nfunction resolvePluginForModule(projectRoot, modulePath) {\n  var resolved = _resolveFrom().default.silent(projectRoot, modulePath);\n\n  if (!resolved) {\n    throw new (_errors().PluginError)(\"Failed to resolve plugin for module \\\"\" + modulePath + \"\\\" relative to \\\"\" + projectRoot + \"\\\"\", 'PLUGIN_NOT_FOUND');\n  }\n\n  if (moduleNameIsDirectFileReference(modulePath)) {\n    return {\n      isPluginFile: false,\n      filePath: resolved\n    };\n  }\n\n  return findUpPlugin(resolved);\n}\n\nfunction pathIsFilePath(name) {\n  return !!name.match(/^(\\.|~\\/|\\/)/g);\n}\n\nfunction moduleNameIsDirectFileReference(name) {\n  var _name$split;\n\n  if (pathIsFilePath(name)) {\n    return true;\n  }\n\n  var slashCount = (_name$split = name.split(path().sep)) === null || _name$split === void 0 ? void 0 : _name$split.length;\n\n  if (name.startsWith('@')) {\n    return slashCount > 2;\n  }\n\n  return slashCount > 1;\n}\n\nfunction resolveExpoPluginFile(root) {\n  var pluginModuleFile = _resolveFrom().default.silent(root, \"./\" + pluginFileName);\n\n  if (pluginModuleFile && (0, _modules().fileExists)(pluginModuleFile)) {\n    return pluginModuleFile;\n  }\n\n  return null;\n}\n\nfunction findUpPlugin(root) {\n  var packageJson = findUpPackageJson(root);\n  var moduleRoot = path().dirname(packageJson);\n  var pluginFile = resolveExpoPluginFile(moduleRoot);\n  return {\n    filePath: pluginFile !== null && pluginFile !== void 0 ? pluginFile : root,\n    isPluginFile: !!pluginFile\n  };\n}\n\nfunction normalizeStaticPlugin(plugin) {\n  if (Array.isArray(plugin)) {\n    (0, _assert().default)(plugin.length > 0 && plugin.length < 3, \"Wrong number of arguments provided for static config plugin, expected either 1 or 2, got \" + plugin.length);\n    return plugin;\n  }\n\n  return [plugin, undefined];\n}\n\nfunction assertInternalProjectRoot(projectRoot) {\n  (0, _assert().default)(projectRoot, \"Unexpected: Config `_internal.projectRoot` isn't defined by expo-cli, this is a bug.\");\n}\n\nfunction resolveConfigPluginFunction(projectRoot, pluginReference) {\n  var _resolveConfigPluginF = resolveConfigPluginFunctionWithInfo(projectRoot, pluginReference),\n      plugin = _resolveConfigPluginF.plugin;\n\n  return plugin;\n}\n\nfunction resolveConfigPluginFunctionWithInfo(projectRoot, pluginReference) {\n  var _resolvePluginForModu = resolvePluginForModule(projectRoot, pluginReference),\n      pluginFile = _resolvePluginForModu.filePath,\n      isPluginFile = _resolvePluginForModu.isPluginFile;\n\n  var result;\n\n  try {\n    result = requirePluginFile(pluginFile);\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      var learnMoreLink = \"Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin\";\n\n      if (!isPluginFile && !moduleNameIsDirectFileReference(pluginReference)) {\n        var pluginError = new (_errors().PluginError)(\"Package \\\"\" + pluginReference + \"\\\" does not contain a valid config plugin.\\n\" + learnMoreLink + \"\\n\\n\" + error.message, 'INVALID_PLUGIN_IMPORT');\n        pluginError.stack = error.stack;\n        throw pluginError;\n      }\n    }\n\n    throw error;\n  }\n\n  var plugin = resolveConfigPluginExport({\n    plugin: result,\n    pluginFile: pluginFile,\n    pluginReference: pluginReference,\n    isPluginFile: isPluginFile\n  });\n  return {\n    plugin: plugin,\n    pluginFile: pluginFile,\n    pluginReference: pluginReference,\n    isPluginFile: isPluginFile\n  };\n}\n\nfunction resolveConfigPluginExport(_ref) {\n  var plugin = _ref.plugin,\n      pluginFile = _ref.pluginFile,\n      pluginReference = _ref.pluginReference,\n      isPluginFile = _ref.isPluginFile;\n\n  if (plugin.default != null) {\n    plugin = plugin.default;\n  }\n\n  if (typeof plugin !== 'function') {\n    var learnMoreLink = \"Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin\";\n\n    if (!isPluginFile && !moduleNameIsDirectFileReference(pluginReference)) {\n      throw new (_errors().PluginError)(\"Package \\\"\" + pluginReference + \"\\\" does not contain a valid config plugin. Module must export a function from file: \" + pluginFile + \"\\n\" + learnMoreLink, 'INVALID_PLUGIN_TYPE');\n    }\n\n    throw new (_errors().PluginError)(\"Plugin \\\"\" + pluginReference + \"\\\" must export a function from file: \" + pluginFile + \". \" + learnMoreLink, 'INVALID_PLUGIN_TYPE');\n  }\n\n  return plugin;\n}\n\nfunction requirePluginFile(filePath) {\n  try {\n    return require(filePath);\n  } catch (error) {\n    throw error;\n  }\n}","map":{"version":3,"sources":["../../src/utils/plugin-resolver.ts"],"names":["pluginFileName","packageJson","cwd","root","resolved","resolveFrom","PluginError","modulePath","moduleNameIsDirectFileReference","isPluginFile","filePath","findUpPlugin","name","pathIsFilePath","slashCount","path","pluginModuleFile","findUpPackageJson","moduleRoot","pluginFile","resolveExpoPluginFile","Array","plugin","resolveConfigPluginFunctionWithInfo","resolvePluginForModule","result","requirePluginFile","error","learnMoreLink","pluginError","pluginReference","resolveConfigPluginExport","require"],"mappings":"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","sourcesContent":["import assert from 'assert';\nimport findUp from 'find-up';\nimport * as path from 'path';\nimport resolveFrom from 'resolve-from';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { PluginError } from './errors';\nimport { fileExists } from './modules';\n\n// Default plugin entry file name.\nexport const pluginFileName = 'app.plugin.js';\n\nfunction findUpPackageJson(root: string): string {\n  const packageJson = findUp.sync('package.json', { cwd: root });\n  assert(packageJson, `No package.json found for module \"${root}\"`);\n  return packageJson;\n}\n\nexport function resolvePluginForModule(projectRoot: string, modulePath: string) {\n  const resolved = resolveFrom.silent(projectRoot, modulePath);\n  if (!resolved) {\n    throw new PluginError(\n      `Failed to resolve plugin for module \"${modulePath}\" relative to \"${projectRoot}\"`,\n      'PLUGIN_NOT_FOUND'\n    );\n  }\n  // If the modulePath is something like `@bacon/package/index.js` or `expo-foo/build/app`\n  // then skip resolving the module `app.plugin.js`\n  if (moduleNameIsDirectFileReference(modulePath)) {\n    return { isPluginFile: false, filePath: resolved };\n  }\n  return findUpPlugin(resolved);\n}\n\n// TODO: Test windows\nfunction pathIsFilePath(name: string): boolean {\n  // Matches lines starting with: . / ~/\n  return !!name.match(/^(\\.|~\\/|\\/)/g);\n}\n\nexport function moduleNameIsDirectFileReference(name: string): boolean {\n  if (pathIsFilePath(name)) {\n    return true;\n  }\n\n  const slashCount = name.split(path.sep)?.length;\n  // Orgs (like @expo/config ) should have more than one slash to be a direct file.\n  if (name.startsWith('@')) {\n    return slashCount > 2;\n  }\n\n  // Regular packages should be considered direct reference if they have more than one slash.\n  return slashCount > 1;\n}\n\nfunction resolveExpoPluginFile(root: string): string | null {\n  // Find the expo plugin root file\n  const pluginModuleFile = resolveFrom.silent(\n    root,\n    // use ./ so it isn't resolved as a node module\n    `./${pluginFileName}`\n  );\n\n  // If the default expo plugin file exists use it.\n  if (pluginModuleFile && fileExists(pluginModuleFile)) {\n    return pluginModuleFile;\n  }\n  return null;\n}\n\nfunction findUpPlugin(root: string): { filePath: string; isPluginFile: boolean } {\n  // Get the closest package.json to the node module\n  const packageJson = findUpPackageJson(root);\n  // resolve the root folder for the node module\n  const moduleRoot = path.dirname(packageJson);\n  // use whatever the initial resolved file was ex: `node_modules/my-package/index.js` or `./something.js`\n  const pluginFile = resolveExpoPluginFile(moduleRoot);\n  return { filePath: pluginFile ?? root, isPluginFile: !!pluginFile };\n}\n\nexport function normalizeStaticPlugin(plugin: StaticPlugin | ConfigPlugin | string): StaticPlugin {\n  if (Array.isArray(plugin)) {\n    assert(\n      plugin.length > 0 && plugin.length < 3,\n      `Wrong number of arguments provided for static config plugin, expected either 1 or 2, got ${plugin.length}`\n    );\n    return plugin;\n  }\n  return [plugin, undefined];\n}\n\nexport function assertInternalProjectRoot(projectRoot?: string): asserts projectRoot {\n  assert(\n    projectRoot,\n    `Unexpected: Config \\`_internal.projectRoot\\` isn't defined by expo-cli, this is a bug.`\n  );\n}\n\n// Resolve the module function and assert type\nexport function resolveConfigPluginFunction(projectRoot: string, pluginReference: string) {\n  const { plugin } = resolveConfigPluginFunctionWithInfo(projectRoot, pluginReference);\n  return plugin;\n}\n\n// Resolve the module function and assert type\nexport function resolveConfigPluginFunctionWithInfo(projectRoot: string, pluginReference: string) {\n  const { filePath: pluginFile, isPluginFile } = resolvePluginForModule(\n    projectRoot,\n    pluginReference\n  );\n  let result: any;\n  try {\n    result = requirePluginFile(pluginFile);\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      const learnMoreLink = `Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin`;\n      // If the plugin reference is a node module, and that node module has a syntax error, then it probably doesn't have an official config plugin.\n      if (!isPluginFile && !moduleNameIsDirectFileReference(pluginReference)) {\n        const pluginError = new PluginError(\n          `Package \"${pluginReference}\" does not contain a valid config plugin.\\n${learnMoreLink}\\n\\n${error.message}`,\n          'INVALID_PLUGIN_IMPORT'\n        );\n        pluginError.stack = error.stack;\n        throw pluginError;\n      }\n    }\n    throw error;\n  }\n\n  const plugin = resolveConfigPluginExport({\n    plugin: result,\n    pluginFile,\n    pluginReference,\n    isPluginFile,\n  });\n  return { plugin, pluginFile, pluginReference, isPluginFile };\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param props.plugin plugin results\n * @param props.pluginFile plugin file path\n * @param props.pluginReference the string used to reference the plugin\n * @param props.isPluginFile is file path from the app.plugin.js module root\n */\nexport function resolveConfigPluginExport({\n  plugin,\n  pluginFile,\n  pluginReference,\n  isPluginFile,\n}: {\n  plugin: any;\n  pluginFile: string;\n  pluginReference: string;\n  isPluginFile: boolean;\n}): ConfigPlugin<unknown> {\n  if (plugin.default != null) {\n    plugin = plugin.default;\n  }\n  if (typeof plugin !== 'function') {\n    const learnMoreLink = `Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin`;\n    // If the plugin reference is a node module, and that node module does not export a function then it probably doesn't have a config plugin.\n    if (!isPluginFile && !moduleNameIsDirectFileReference(pluginReference)) {\n      throw new PluginError(\n        `Package \"${pluginReference}\" does not contain a valid config plugin. Module must export a function from file: ${pluginFile}\\n${learnMoreLink}`,\n        'INVALID_PLUGIN_TYPE'\n      );\n    }\n    throw new PluginError(\n      `Plugin \"${pluginReference}\" must export a function from file: ${pluginFile}. ${learnMoreLink}`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n\n  return plugin;\n}\n\nfunction requirePluginFile(filePath: string): any {\n  try {\n    return require(filePath);\n  } catch (error) {\n    // TODO: Improve error messages\n    throw error;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}