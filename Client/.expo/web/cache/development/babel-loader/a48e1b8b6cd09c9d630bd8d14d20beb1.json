{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Symbolicator = void 0;\n\nvar code_frame_1 = require(\"@babel/code-frame\");\n\nvar fs_1 = __importDefault(require(\"fs\"));\n\nvar source_map_1 = require(\"source-map\");\n\nvar url_1 = require(\"url\");\n\nvar Symbolicator = function () {\n  function Symbolicator(config) {\n    _classCallCheck(this, Symbolicator);\n\n    this.config = config;\n    this.sourceMapConsumerCache = {};\n  }\n\n  _createClass(Symbolicator, [{\n    key: \"process\",\n    value: function process(stack, _ref) {\n      var platform, frames, _iterator, _step, frame, file, processedFrames, _i, _frames, _frame, rawSourceMap, sourceMapConsumer, processedFrame, codeFrame, key;\n\n      return _regeneratorRuntime.async(function process$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              platform = _ref.platform;\n              frames = [];\n\n              for (_iterator = _createForOfIteratorHelperLoose(stack); !(_step = _iterator()).done;) {\n                frame = _step.value;\n                file = frame.file;\n\n                if ((file === null || file === void 0 ? void 0 : file.startsWith('http')) && !file.includes('debuggerWorker')) {\n                  frames.push(frame);\n                }\n              }\n\n              _context.prev = 3;\n              processedFrames = [];\n              _i = 0, _frames = frames;\n\n            case 6:\n              if (!(_i < _frames.length)) {\n                _context.next = 21;\n                break;\n              }\n\n              _frame = _frames[_i];\n\n              if (this.sourceMapConsumerCache[_frame.file]) {\n                _context.next = 16;\n                break;\n              }\n\n              _context.next = 11;\n              return _regeneratorRuntime.awrap(this.config.getSourceMapAsync({\n                url: _frame.file,\n                platform: platform\n              }));\n\n            case 11:\n              rawSourceMap = _context.sent;\n              _context.next = 14;\n              return _regeneratorRuntime.awrap(new source_map_1.SourceMapConsumer(rawSourceMap));\n\n            case 14:\n              sourceMapConsumer = _context.sent;\n              this.sourceMapConsumerCache[_frame.file] = sourceMapConsumer;\n\n            case 16:\n              processedFrame = this.config.customizeFrame(this.processFrame(_frame));\n              processedFrames.push(processedFrame);\n\n            case 18:\n              _i++;\n              _context.next = 6;\n              break;\n\n            case 21:\n              _context.next = 23;\n              return _regeneratorRuntime.awrap(this.getCodeFrame(processedFrames, platform));\n\n            case 23:\n              codeFrame = _context.sent;\n              return _context.abrupt(\"return\", {\n                stack: processedFrames,\n                codeFrame: codeFrame !== null && codeFrame !== void 0 ? codeFrame : null\n              });\n\n            case 25:\n              _context.prev = 25;\n\n              for (key in this.sourceMapConsumerCache) {\n                delete this.sourceMapConsumerCache[key];\n              }\n\n              return _context.finish(25);\n\n            case 28:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, [[3,, 25, 28]], Promise);\n    }\n  }, {\n    key: \"processFrame\",\n    value: function processFrame(frame) {\n      if (!frame.lineNumber || !frame.column) {\n        return _objectSpread(_objectSpread({}, frame), {}, {\n          collapse: false\n        });\n      }\n\n      var consumer = this.sourceMapConsumerCache[frame.file];\n\n      if (!consumer) {\n        return _objectSpread(_objectSpread({}, frame), {}, {\n          collapse: false\n        });\n      }\n\n      var lookup = consumer.originalPositionFor({\n        line: frame.lineNumber,\n        column: frame.column\n      });\n\n      if (!lookup.source) {\n        return _objectSpread(_objectSpread({}, frame), {}, {\n          collapse: false\n        });\n      }\n\n      return {\n        lineNumber: lookup.line || frame.lineNumber,\n        column: lookup.column || frame.column,\n        file: lookup.source,\n        methodName: lookup.name || frame.methodName,\n        collapse: false\n      };\n    }\n  }, {\n    key: \"getCodeFrame\",\n    value: function getCodeFrame(processedFrames, platform) {\n      var _iterator2, _step2, frame, filename, source;\n\n      return _regeneratorRuntime.async(function getCodeFrame$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iterator2 = _createForOfIteratorHelperLoose(processedFrames);\n\n            case 1:\n              if ((_step2 = _iterator2()).done) {\n                _context2.next = 27;\n                break;\n              }\n\n              frame = _step2.value;\n\n              if (!(frame.collapse || !frame.lineNumber || !frame.column)) {\n                _context2.next = 5;\n                break;\n              }\n\n              return _context2.abrupt(\"continue\", 25);\n\n            case 5:\n              _context2.prev = 5;\n              filename = void 0;\n              source = void 0;\n\n              if (!(frame.file.startsWith('http') && frame.file.includes('index.bundle'))) {\n                _context2.next = 15;\n                break;\n              }\n\n              filename = frame.file;\n              _context2.next = 12;\n              return _regeneratorRuntime.awrap(this.config.getFileAsync({\n                url: '/index.bundle',\n                platform: platform\n              }));\n\n            case 12:\n              source = _context2.sent;\n              _context2.next = 19;\n              break;\n\n            case 15:\n              filename = frame.file.replace('webpack://', '');\n              _context2.next = 18;\n              return _regeneratorRuntime.awrap(fs_1.default.promises.readFile(filename, 'utf8'));\n\n            case 18:\n              source = _context2.sent;\n\n            case 19:\n              return _context2.abrupt(\"return\", {\n                content: code_frame_1.codeFrameColumns(source, {\n                  start: {\n                    column: frame.column,\n                    line: frame.lineNumber\n                  }\n                }, {\n                  forceColor: true\n                }),\n                location: {\n                  row: frame.lineNumber,\n                  column: frame.column\n                },\n                fileName: filename\n              });\n\n            case 22:\n              _context2.prev = 22;\n              _context2.t0 = _context2[\"catch\"](5);\n              this.config.logger.error({\n                tag: 'dev-server'\n              }, 'Symbolication failed to create code preview: ' + _context2.t0.message);\n\n            case 25:\n              _context2.next = 1;\n              break;\n\n            case 27:\n              return _context2.abrupt(\"return\", undefined);\n\n            case 28:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, [[5, 22]], Promise);\n    }\n  }], [{\n    key: \"inferPlatformFromStack\",\n    value: function inferPlatformFromStack(stack) {\n      for (var _iterator3 = _createForOfIteratorHelperLoose(stack), _step3; !(_step3 = _iterator3()).done;) {\n        var frame = _step3.value;\n\n        if (!frame.file) {\n          return null;\n        }\n\n        var _url_1$URL = new url_1.URL(frame.file, 'file://'),\n            searchParams = _url_1$URL.searchParams,\n            pathname = _url_1$URL.pathname;\n\n        var platform = searchParams.get('platform');\n\n        if (platform) {\n          return platform;\n        } else {\n          var _pathname$split$rever = pathname.split('/').reverse(),\n              _pathname$split$rever2 = _slicedToArray(_pathname$split$rever, 1),\n              bundleFilename = _pathname$split$rever2[0];\n\n          var _bundleFilename$split = bundleFilename.split('.'),\n              _bundleFilename$split2 = _slicedToArray(_bundleFilename$split, 3),\n              platformOrExtension = _bundleFilename$split2[1],\n              extension = _bundleFilename$split2[2];\n\n          if (extension) {\n            return platformOrExtension;\n          }\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return Symbolicator;\n}();\n\nexports.Symbolicator = Symbolicator;","map":{"version":3,"sources":["../../src/webpack/Symbolicator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2021 Expo, Inc.\n * Copyright (c) 2021 Callstack, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Based on https://github.com/callstack/repack/blob/3c1e0597557d09ab64fab0a29a86d3c487a23ef0/packages/repack/src/server/Symbolicator.ts\n */\n\nimport { codeFrameColumns } from '@babel/code-frame';\nimport Log from '@expo/bunyan';\nimport fs from 'fs';\nimport { SourceMapConsumer } from 'source-map';\nimport { URL } from 'url';\n\n/**\n * Raw React Native stack frame.\n */\nexport interface ReactNativeStackFrame {\n  lineNumber: number | null;\n  column: number | null;\n  file: string | null;\n  methodName: string;\n}\n\n/**\n * React Native stack frame used as input when processing by {@link Symbolicator}.\n */\nexport interface InputStackFrame extends ReactNativeStackFrame {\n  file: string;\n}\n\n/**\n * Final symbolicated stack frame.\n */\nexport interface StackFrame extends InputStackFrame {\n  collapse: boolean;\n}\n\n/**\n * Represents [@babel/core-frame](https://babeljs.io/docs/en/babel-code-frame).\n */\nexport interface CodeFrame {\n  content: string;\n  location: {\n    row: number;\n    column: number;\n  };\n  fileName: string;\n}\n\n/**\n * Represents results of running {@link process} method on {@link Symbolicator} instance.\n */\nexport interface SymbolicatorResults {\n  codeFrame: CodeFrame | null;\n  stack: StackFrame[];\n}\n\n/**\n * Class for transforming stack traces from React Native application with using Source Map.\n * Raw stack frames produced by React Native, points to some location from the bundle\n * eg `index.bundle?platform=ios:567:1234`. By using Source Map for that bundle `Symbolicator`\n * produces frames that point to source code inside your project eg `Hello.tsx:10:9`.\n */\nexport class Symbolicator {\n  /**\n   * Infer platform from stack frames.\n   * Usually at least one frame has `file` field with the bundle URL eg:\n   * `http://localhost:8081/index.bundle?platform=ios&...`, which can be used to infer platform.\n   *\n   * @param stack Array of stack frames.\n   * @returns Inferred platform or `undefined` if cannot infer.\n   */\n  static inferPlatformFromStack(stack: ReactNativeStackFrame[]) {\n    for (const frame of stack) {\n      if (!frame.file) {\n        return null;\n      }\n\n      const { searchParams, pathname } = new URL(frame.file, 'file://');\n      const platform = searchParams.get('platform');\n      if (platform) {\n        return platform;\n      } else {\n        const [bundleFilename] = pathname.split('/').reverse();\n        const [, platformOrExtension, extension] = bundleFilename.split('.');\n        if (extension) {\n          return platformOrExtension;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Cache with initialized `SourceMapConsumer` to improve symbolication performance.\n   */\n  sourceMapConsumerCache: Record<string, SourceMapConsumer> = {};\n\n  constructor(\n    public config: {\n      projectRoot: string;\n      logger: Log;\n      customizeFrame: (frame: StackFrame) => StackFrame;\n      getFileAsync: (props: { url: string; platform: string }) => Promise<string>;\n      getSourceMapAsync: (props: { url: string; platform: string }) => Promise<string>;\n    }\n  ) {}\n\n  /**\n   * Process raw React Native stack frames and transform them using Source Maps.\n   * Method will try to symbolicate as much data as possible, but if the Source Maps\n   * are not available, invalid or the original positions/data is not found in Source Maps,\n   * the method will return raw values - the same as supplied with `stack` parameter.\n   * For example out of 10 frames, it's possible that only first 7 will be symbolicated and the\n   * remaining 3 will be unchanged.\n   *\n   * @param stack Raw stack frames.\n   * @returns Symbolicated stack frames.\n   */\n  async process(\n    stack: ReactNativeStackFrame[],\n    { platform }: { platform: string }\n  ): Promise<SymbolicatorResults> {\n    // TODO: add debug logging\n    const frames: InputStackFrame[] = [];\n    for (const frame of stack) {\n      const { file } = frame;\n\n      if (file?.startsWith('http') && !file.includes('debuggerWorker')) {\n        frames.push(frame as InputStackFrame);\n      }\n    }\n\n    try {\n      const processedFrames: StackFrame[] = [];\n      for (const frame of frames) {\n        if (!this.sourceMapConsumerCache[frame.file]) {\n          const rawSourceMap = await this.config.getSourceMapAsync({\n            url: frame.file,\n            platform,\n          });\n          const sourceMapConsumer = await new SourceMapConsumer(rawSourceMap as any);\n          this.sourceMapConsumerCache[frame.file] = sourceMapConsumer;\n        }\n        const processedFrame = this.config.customizeFrame(this.processFrame(frame));\n\n        processedFrames.push(processedFrame);\n      }\n\n      const codeFrame = await this.getCodeFrame(processedFrames, platform);\n      return {\n        stack: processedFrames,\n        codeFrame: codeFrame ?? null,\n      };\n    } finally {\n      for (const key in this.sourceMapConsumerCache) {\n        delete this.sourceMapConsumerCache[key];\n      }\n    }\n  }\n\n  private processFrame(frame: InputStackFrame): StackFrame {\n    if (!frame.lineNumber || !frame.column) {\n      return {\n        ...frame,\n        collapse: false,\n      };\n    }\n\n    const consumer = this.sourceMapConsumerCache[frame.file];\n    if (!consumer) {\n      return {\n        ...frame,\n        collapse: false,\n      };\n    }\n\n    const lookup = consumer.originalPositionFor({\n      line: frame.lineNumber,\n      column: frame.column,\n    });\n\n    // If lookup fails, we get the same shape object, but with\n    // all values set to null\n    if (!lookup.source) {\n      // It is better to gracefully return the original frame\n      // than to throw an exception\n      return {\n        ...frame,\n        collapse: false,\n      };\n    }\n\n    return {\n      lineNumber: lookup.line || frame.lineNumber,\n      column: lookup.column || frame.column,\n      file: lookup.source,\n      methodName: lookup.name || frame.methodName,\n      collapse: false,\n    };\n  }\n\n  private async getCodeFrame(\n    processedFrames: StackFrame[],\n    platform: string\n  ): Promise<CodeFrame | undefined> {\n    for (const frame of processedFrames) {\n      if (frame.collapse || !frame.lineNumber || !frame.column) {\n        continue;\n      }\n\n      try {\n        let filename;\n        let source;\n\n        if (frame.file.startsWith('http') && frame.file.includes('index.bundle')) {\n          // Frame points to the bundle so we need to read bundle from WDM's FS.\n          filename = frame.file;\n          source = await this.config.getFileAsync({ url: '/index.bundle', platform });\n        } else {\n          filename = frame.file.replace('webpack://', '');\n          source = await fs.promises.readFile(filename, 'utf8');\n        }\n\n        return {\n          content: codeFrameColumns(\n            source,\n            {\n              start: { column: frame.column, line: frame.lineNumber },\n            },\n            { forceColor: true }\n          ),\n          location: {\n            row: frame.lineNumber,\n            column: frame.column,\n          },\n          fileName: filename,\n        };\n      } catch (error) {\n        this.config.logger.error(\n          { tag: 'dev-server' },\n          'Symbolication failed to create code preview: ' + error.message\n        );\n      }\n    }\n    return undefined;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}