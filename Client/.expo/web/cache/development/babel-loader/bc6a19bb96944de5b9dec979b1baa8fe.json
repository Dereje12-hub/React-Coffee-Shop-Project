{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tapable_1 = require(\"tapable\");\n\nvar hooksMap = new WeakMap();\n\nfunction createWebpackPluginHooks() {\n  return {\n    beforeEmit: new tapable_1.AsyncSeriesWaterfallHook(['pluginArgs']),\n    afterEmit: new tapable_1.AsyncSeriesWaterfallHook(['pluginArgs'])\n  };\n}\n\nvar JsonWebpackPlugin = function () {\n  function JsonWebpackPlugin(options) {\n    var _this = this;\n\n    _classCallCheck(this, JsonWebpackPlugin);\n\n    this.options = options;\n\n    this.writeObject = function _callee(compilation, callback) {\n      var result, json;\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              result = {\n                json: _this.options.json,\n                path: _this.options.path,\n                plugin: _this\n              };\n              _context.prev = 1;\n              _context.next = 4;\n              return _regeneratorRuntime.awrap(JsonWebpackPlugin.getHooks(compilation).beforeEmit.promise(result));\n\n            case 4:\n              result = _context.sent;\n              _context.next = 10;\n              break;\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](1);\n              compilation.errors.push(_context.t0);\n\n            case 10:\n              json = JSON.stringify(result.json, undefined, _this.options.pretty ? 2 : undefined);\n              compilation.assets[result.path] = {\n                source: function source() {\n                  return json;\n                },\n                size: function size() {\n                  return json.length;\n                }\n              };\n              _context.next = 14;\n              return _regeneratorRuntime.awrap(JsonWebpackPlugin.getHooks(compilation).afterEmit.promise({\n                json: json,\n                outputName: result.path,\n                plugin: _this\n              }));\n\n            case 14:\n              callback();\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, [[1, 7]], Promise);\n    };\n\n    if (!this.options.path || !this.options.json) {\n      throw new Error('Failed to write json because either `path` or `json` were not defined.');\n    }\n  }\n\n  _createClass(JsonWebpackPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      compiler.hooks.emit.tapAsync(this.constructor.name, this.writeObject);\n    }\n  }], [{\n    key: \"getHooks\",\n    value: function getHooks(compilation) {\n      var hooks = hooksMap.get(compilation);\n\n      if (hooks === undefined) {\n        hooks = createWebpackPluginHooks();\n        hooksMap.set(compilation, hooks);\n      }\n\n      return hooks;\n    }\n  }]);\n\n  return JsonWebpackPlugin;\n}();\n\nexports.default = JsonWebpackPlugin;","map":{"version":3,"sources":["../../src/plugins/JsonWebpackPlugin.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAWA,IAAM,QAAQ,GAAG,IAAI,OAAJ,EAAjB;;AAEA,SAAS,wBAAT,GAAiC;AAC/B,SAAO;AACL,IAAA,UAAU,EAAE,IAAI,SAAA,CAAA,wBAAJ,CAA6B,CAAC,YAAD,CAA7B,CADP;AAEL,IAAA,SAAS,EAAE,IAAI,SAAA,CAAA,wBAAJ,CAA6B,CAAC,YAAD,CAA7B;AAFN,GAAP;AAID;;IAEoB,iB;AAWnB,6BAAmB,OAAnB,EAAmC;AAAA;;AAAA;;AAAhB,SAAA,OAAA,GAAA,OAAA;;AAUX,SAAA,WAAA,GAAc,iBACpB,WADoB,EAEpB,QAFoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAIhB,cAAA,MAJgB,GAIY;AAC9B,gBAAA,IAAI,EAAE,KAAI,CAAC,OAAL,CAAa,IADW;AAE9B,gBAAA,IAAI,EAAE,KAAI,CAAC,OAAL,CAAa,IAFW;AAG9B,gBAAA,MAAM,EAAE;AAHsB,eAJZ;AAAA;AAAA;AAAA,+CAUH,iBAAiB,CAAC,QAAlB,CAA2B,WAA3B,EAAwC,UAAxC,CAAmD,OAAnD,CAA2D,MAA3D,CAVG;;AAAA;AAUlB,cAAA,MAVkB;AAAA;AAAA;;AAAA;AAAA;AAAA;AAYlB,cAAA,WAAW,CAAC,MAAZ,CAAmB,IAAnB;;AAZkB;AAed,cAAA,IAfc,GAeP,IAAI,CAAC,SAAL,CAAe,MAAM,CAAC,IAAtB,EAA4B,SAA5B,EAAuC,KAAI,CAAC,OAAL,CAAa,MAAb,GAAsB,CAAtB,GAA0B,SAAjE,CAfO;AAmBpB,cAAA,WAAW,CAAC,MAAZ,CAAmB,MAAM,CAAC,IAA1B,IAAkC;AAChC,gBAAA,MAAM,EAAE;AAAA,yBAAM,IAAN;AAAA,iBADwB;AAEhC,gBAAA,IAAI,EAAE;AAAA,yBAAM,IAAI,CAAC,MAAX;AAAA;AAF0B,eAAlC;AAnBoB;AAAA,+CAwBd,iBAAiB,CAAC,QAAlB,CAA2B,WAA3B,EAAwC,SAAxC,CAAkD,OAAlD,CAA0D;AAC9D,gBAAA,IAAI,EAAJ,IAD8D;AAE9D,gBAAA,UAAU,EAAE,MAAM,CAAC,IAF2C;AAG9D,gBAAA,MAAM,EAAE;AAHsD,eAA1D,CAxBc;;AAAA;AA8BpB,cAAA,QAAQ;;AA9BY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAd;;AATN,QAAI,CAAC,KAAK,OAAL,CAAa,IAAd,IAAsB,CAAC,KAAK,OAAL,CAAa,IAAxC,EAA8C;AAC5C,YAAM,IAAI,KAAJ,CAAU,wEAAV,CAAN;AACD;AACF;;;;WAED,eAAM,QAAN,EAAwB;AACtB,MAAA,QAAQ,CAAC,KAAT,CAAe,IAAf,CAAoB,QAApB,CAA6B,KAAK,WAAL,CAAiB,IAA9C,EAAoD,KAAK,WAAzD;AACD;;;WAlBD,kBAAgB,WAAhB,EAAoD;AAClD,UAAI,KAAK,GAAG,QAAQ,CAAC,GAAT,CAAa,WAAb,CAAZ;;AAEA,UAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,QAAA,KAAK,GAAG,wBAAwB,EAAhC;AACA,QAAA,QAAQ,CAAC,GAAT,CAAa,WAAb,EAA0B,KAA1B;AACD;;AACD,aAAO,KAAP;AACD;;;;;;AATH,OAAA,CAAA,OAAA,GAAA,iBAAA","sourcesContent":["import { AsyncSeriesWaterfallHook } from 'tapable';\nimport { compilation, Compiler } from 'webpack';\n\nexport type Options = {\n  path: string;\n  json: any;\n  pretty?: boolean;\n};\n\nexport type BeforeEmitOptions = Options & { plugin: JsonWebpackPlugin };\n\nconst hooksMap = new WeakMap<compilation.Compilation, Record<string, AsyncSeriesWaterfallHook>>();\n\nfunction createWebpackPluginHooks(): Record<string, AsyncSeriesWaterfallHook> {\n  return {\n    beforeEmit: new AsyncSeriesWaterfallHook(['pluginArgs']),\n    afterEmit: new AsyncSeriesWaterfallHook(['pluginArgs']),\n  };\n}\n\nexport default class JsonWebpackPlugin {\n  static getHooks(compilation: compilation.Compilation): Record<string, AsyncSeriesWaterfallHook> {\n    let hooks = hooksMap.get(compilation);\n    // Setup the hooks only once\n    if (hooks === undefined) {\n      hooks = createWebpackPluginHooks();\n      hooksMap.set(compilation, hooks);\n    }\n    return hooks;\n  }\n\n  constructor(public options: Options) {\n    if (!this.options.path || !this.options.json) {\n      throw new Error('Failed to write json because either `path` or `json` were not defined.');\n    }\n  }\n\n  apply(compiler: Compiler) {\n    compiler.hooks.emit.tapAsync(this.constructor.name, this.writeObject);\n  }\n\n  private writeObject = async (\n    compilation: compilation.Compilation,\n    callback: () => void\n  ): Promise<void> => {\n    let result: BeforeEmitOptions = {\n      json: this.options.json,\n      path: this.options.path,\n      plugin: this,\n    };\n    try {\n      result = await JsonWebpackPlugin.getHooks(compilation).beforeEmit.promise(result);\n    } catch (error) {\n      compilation.errors.push(error);\n    }\n\n    const json = JSON.stringify(result.json, undefined, this.options.pretty ? 2 : undefined);\n\n    // Once all files are added to the webpack compilation\n    // let the webpack compiler continue\n    compilation.assets[result.path] = {\n      source: () => json,\n      size: () => json.length,\n    };\n\n    await JsonWebpackPlugin.getHooks(compilation).afterEmit.promise({\n      json,\n      outputName: result.path,\n      plugin: this,\n    });\n\n    callback();\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}