{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EmptyJsonFileError = void 0;\n\nvar JsonFileError = function (_Error) {\n  _inherits(JsonFileError, _Error);\n\n  var _super = _createSuper(JsonFileError);\n\n  function JsonFileError(message, cause, code, fileName) {\n    var _this;\n\n    _classCallCheck(this, JsonFileError);\n\n    var fullMessage = message;\n\n    if (fileName) {\n      fullMessage += \"\\n\" + (cause ? '├' : '└') + \"\\u2500 File: \" + fileName;\n    }\n\n    if (cause) {\n      fullMessage += \"\\n\\u2514\\u2500 Cause: \" + cause.name + \": \" + cause.message;\n    }\n\n    _this = _super.call(this, fullMessage);\n    _this.name = _this.constructor.name;\n    _this.cause = cause;\n    _this.code = code;\n    _this.fileName = fileName;\n    _this.isJsonFileError = true;\n    return _this;\n  }\n\n  return _createClass(JsonFileError);\n}(_wrapNativeSuper(Error));\n\nexports.default = JsonFileError;\n\nvar EmptyJsonFileError = function (_JsonFileError) {\n  _inherits(EmptyJsonFileError, _JsonFileError);\n\n  var _super2 = _createSuper(EmptyJsonFileError);\n\n  function EmptyJsonFileError(fileName) {\n    _classCallCheck(this, EmptyJsonFileError);\n\n    return _super2.call(this, \"Cannot parse an empty JSON string\", undefined, 'EJSONEMPTY', fileName);\n  }\n\n  return _createClass(EmptyJsonFileError);\n}(JsonFileError);\n\nexports.EmptyJsonFileError = EmptyJsonFileError;","map":{"version":3,"sources":["../src/JsonFileError.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;IAGqB,a;;;;;AAMnB,yBAAY,OAAZ,EAA6B,KAA7B,EAA4C,IAA5C,EAA2D,QAA3D,EAA4E;AAAA;;AAAA;;AAC1E,QAAI,WAAW,GAAG,OAAlB;;AACA,QAAI,QAAJ,EAAc;AACZ,MAAA,WAAW,YAAS,KAAK,GAAG,GAAH,GAAS,GAAvB,sBAAqC,QAAhD;AACD;;AACD,QAAI,KAAJ,EAAW;AACT,MAAA,WAAW,+BAAmB,KAAK,CAAC,IAAzB,UAAkC,KAAK,CAAC,OAAnD;AACD;;AACD,8BAAM,WAAN;AACA,UAAK,IAAL,GAAY,MAAK,WAAL,CAAiB,IAA7B;AACA,UAAK,KAAL,GAAa,KAAb;AACA,UAAK,IAAL,GAAY,IAAZ;AACA,UAAK,QAAL,GAAgB,QAAhB;AACA,UAAK,eAAL,GAAuB,IAAvB;AAb0E;AAc3E;;;mBApBwC,K;;AAA3C,OAAA,CAAA,OAAA,GAAA,aAAA;;IAuBa,kB;;;;;AACX,8BAAY,QAAZ,EAA6B;AAAA;;AAAA,mEACgB,SADhB,EAC2B,YAD3B,EACyC,QADzC;AAE5B;;;EAHqC,a;;AAAxC,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourcesContent":["/**\n * Note that instances of this class do NOT pass `instanceof JsonFileError`.\n */\nexport default class JsonFileError extends Error {\n  cause: Error | undefined;\n  code: string | undefined;\n  fileName: string | undefined;\n  isJsonFileError: true;\n\n  constructor(message: string, cause?: Error, code?: string, fileName?: string) {\n    let fullMessage = message;\n    if (fileName) {\n      fullMessage += `\\n${cause ? '├' : '└'}─ File: ${fileName}`;\n    }\n    if (cause) {\n      fullMessage += `\\n└─ Cause: ${cause.name}: ${cause.message}`;\n    }\n    super(fullMessage);\n    this.name = this.constructor.name;\n    this.cause = cause;\n    this.code = code;\n    this.fileName = fileName;\n    this.isJsonFileError = true;\n  }\n}\n\nexport class EmptyJsonFileError extends JsonFileError {\n  constructor(fileName?: string) {\n    super(`Cannot parse an empty JSON string`, undefined, 'EJSONEMPTY', fileName);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}