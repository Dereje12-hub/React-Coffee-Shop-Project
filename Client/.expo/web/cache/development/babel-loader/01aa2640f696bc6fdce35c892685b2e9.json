{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSymbolicateMiddleware = void 0;\n\nvar metro_config_1 = require(\"@expo/metro-config\");\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar Symbolicator_1 = require(\"./Symbolicator\");\n\nvar getFileAsync_1 = require(\"./getFileAsync\");\n\nfunction customizeFrame(frame) {\n  var _a;\n\n  var collapse = Boolean(frame.file && metro_config_1.INTERNAL_CALLSITES_REGEX.test(frame.file));\n\n  if (!collapse) {\n    if (frame.column === 3 && frame.methodName === 'global code' && ((_a = frame.file) === null || _a === void 0 ? void 0 : _a.match(/^https?:\\/\\//g))) {\n      collapse = true;\n    }\n  }\n\n  return _objectSpread(_objectSpread({}, frame || {}), {}, {\n    collapse: collapse\n  });\n}\n\nfunction createSymbolicateMiddleware(_ref) {\n  var projectRoot = _ref.projectRoot,\n      logger = _ref.logger,\n      compiler = _ref.compiler;\n  var getFilenameFromUrl = getFileAsync_1.createGetFileNameFromUrl(compiler);\n  var symbolicate = new Symbolicator_1.Symbolicator({\n    projectRoot: projectRoot,\n    logger: logger,\n    customizeFrame: customizeFrame,\n    getFileAsync: function getFileAsync(props) {\n      return function _callee() {\n        var fileName;\n        return _regeneratorRuntime.async(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                fileName = getFilenameFromUrl(props);\n                return _context.abrupt(\"return\", getFileAsync_1.getFileFromCompilerAsync(compiler, {\n                  fileName: fileName,\n                  platform: props.platform\n                }));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      }();\n    },\n    getSourceMapAsync: function getSourceMapAsync(props) {\n      return function _callee2() {\n        var _a, _b, fileName, fallbackSourceMapFilename, bundle, sourceMappingUrl, sourceMapBasename, sourceMapFilename, parseError, _i, _arr, file;\n\n        return _regeneratorRuntime.async(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                fileName = getFilenameFromUrl(props);\n                fallbackSourceMapFilename = fileName + \".map\";\n                _context2.next = 4;\n                return _regeneratorRuntime.awrap(getFileAsync_1.getFileFromCompilerAsync(compiler, {\n                  fileName: fileName,\n                  platform: props.platform\n                }));\n\n              case 4:\n                bundle = _context2.sent;\n                sourceMappingUrl = (_a = /sourceMappingURL=(.+)$/.exec(bundle)) === null || _a === void 0 ? void 0 : _a[1];\n                sourceMapBasename = (_b = sourceMappingUrl === null || sourceMappingUrl === void 0 ? void 0 : sourceMappingUrl.split('?')) === null || _b === void 0 ? void 0 : _b[0];\n                sourceMapFilename = fallbackSourceMapFilename;\n\n                if (sourceMapBasename) {\n                  sourceMapFilename = path_1.default.join(path_1.default.dirname(fileName), sourceMapBasename);\n                }\n\n                parseError = null;\n                _i = 0, _arr = [sourceMapFilename, fallbackSourceMapFilename];\n\n              case 11:\n                if (!(_i < _arr.length)) {\n                  _context2.next = 26;\n                  break;\n                }\n\n                file = _arr[_i];\n                _context2.prev = 13;\n                _context2.next = 16;\n                return _regeneratorRuntime.awrap(getFileAsync_1.getFileFromCompilerAsync(compiler, {\n                  fileName: file,\n                  platform: props.platform\n                }));\n\n              case 16:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 19:\n                _context2.prev = 19;\n                _context2.t0 = _context2[\"catch\"](13);\n                parseError = _context2.t0;\n                console.warn('Failed to read source map from sourceMappingURL:', file);\n\n              case 23:\n                _i++;\n                _context2.next = 11;\n                break;\n\n              case 26:\n                throw parseError;\n\n              case 27:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, null, null, [[13, 19]], Promise);\n      }();\n    }\n  });\n  return function _callee3(req, res) {\n    var _a, _b, _JSON$parse, stack, platform, parsed;\n\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n\n            if (req.rawBody) {\n              _context3.next = 3;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", res.writeHead(400).end('Missing request rawBody.'));\n\n          case 3:\n            _JSON$parse = JSON.parse(req.rawBody), stack = _JSON$parse.stack;\n            platform = (_b = (_a = getFileAsync_1.getPlatformFromRequest(req)) !== null && _a !== void 0 ? _a : Symbolicator_1.Symbolicator.inferPlatformFromStack(stack)) !== null && _b !== void 0 ? _b : 'web';\n\n            if (platform) {\n              _context3.next = 7;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", res.writeHead(400).end('Missing expo-platform header, platform query parameter, or platform parameter in source map comment url'));\n\n          case 7:\n            _context3.next = 9;\n            return _regeneratorRuntime.awrap(symbolicate.process(stack, {\n              platform: platform\n            }));\n\n          case 9:\n            parsed = _context3.sent;\n            return _context3.abrupt(\"return\", res.end(JSON.stringify(parsed)));\n\n          case 13:\n            _context3.prev = 13;\n            _context3.t0 = _context3[\"catch\"](0);\n            console.error(\"Failed to symbolicate: \" + _context3.t0 + \" \" + _context3.t0.stack);\n            res.statusCode = 500;\n            return _context3.abrupt(\"return\", res.end(JSON.stringify({\n              error: _context3.t0.message\n            })));\n\n          case 18:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, [[0, 13]], Promise);\n  };\n}\n\nexports.createSymbolicateMiddleware = createSymbolicateMiddleware;","map":{"version":3,"sources":["../../src/webpack/symbolicateMiddleware.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AACA,IAAA,cAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAEA,IAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;;AAEA,IAAA,cAAA,GAAA,OAAA,kBAAA;;AACA,IAAA,cAAA,GAAA,OAAA,kBAAA;;AAQA,SAAS,cAAT,CAAwB,KAAxB,EAAyC;;;AACvC,MAAI,QAAQ,GAAG,OAAO,CAAC,KAAK,CAAC,IAAN,IAAc,cAAA,CAAA,wBAAA,CAAyB,IAAzB,CAA8B,KAAK,CAAC,IAApC,CAAf,CAAtB;;AAEA,MAAI,CAAC,QAAL,EAAe;AAIb,QACE,KAAK,CAAC,MAAN,KAAiB,CAAjB,IACA,KAAK,CAAC,UAAN,KAAqB,aADrB,KAEA,CAAA,EAAA,GAAA,KAAK,CAAC,IAAN,MAAU,IAAV,IAAU,EAAA,KAAA,KAAA,CAAV,GAAU,KAAA,CAAV,GAAU,EAAA,CAAE,KAAF,CAAQ,eAAR,CAFV,CADF,EAIE;AACA,MAAA,QAAQ,GAAG,IAAX;AACD;AACF;;AAED,yCAAa,KAAK,IAAI,EAAtB;AAA2B,IAAA,QAAQ,EAAR;AAA3B;AACD;;AAED,SAAgB,2BAAhB,OAQC;AAAA,MAPC,WAOD,QAPC,WAOD;AAAA,MANC,MAMD,QANC,MAMD;AAAA,MALC,QAKD,QALC,QAKD;AACC,MAAM,kBAAkB,GAAG,cAAA,CAAA,wBAAA,CAAyB,QAAzB,CAA3B;AAEA,MAAM,WAAW,GAAG,IAAI,cAAA,CAAA,YAAJ,CAAiB;AACnC,IAAA,WAAW,EAAX,WADmC;AAEnC,IAAA,MAAM,EAAN,MAFmC;AAGnC,IAAA,cAAc,EAAd,cAHmC;AAI7B,IAAA,YAJ6B,wBAIhB,KAJgB,EAIX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAChB,gBAAA,QADgB,GACL,kBAAkB,CAAC,KAAD,CADb;AAAA,iDAEf,cAAA,CAAA,wBAAA,CAAyB,QAAzB,EAAmC;AAAE,kBAAA,QAAQ,EAAR,QAAF;AAAY,kBAAA,QAAQ,EAAE,KAAK,CAAC;AAA5B,iBAAnC,CAFe;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGvB,KAPkC;AAQ7B,IAAA,iBAR6B,6BAQX,KARW,EAQN;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACrB,gBAAA,QADqB,GACV,kBAAkB,CAAC,KAAD,CADR;AAErB,gBAAA,yBAFqB,GAEU,QAFV;AAAA;AAAA,iDAGN,cAAA,CAAA,wBAAA,CAAyB,QAAzB,EAAmC;AACtD,kBAAA,QAAQ,EAAR,QADsD;AAEtD,kBAAA,QAAQ,EAAE,KAAK,CAAC;AAFsC,iBAAnC,CAHM;;AAAA;AAGrB,gBAAA,MAHqB;AAOrB,gBAAA,gBAPqB,GAOF,CAAA,EAAA,GAAA,yBAAyB,IAAzB,CAA8B,MAA9B,CAAA,MAAqC,IAArC,IAAqC,EAAA,KAAA,KAAA,CAArC,GAAqC,KAAA,CAArC,GAAqC,EAAA,CAAG,CAAH,CAPnC;AAQrB,gBAAA,iBARqB,GAQD,CAAA,EAAA,GAAA,gBAAgB,KAAA,IAAhB,IAAA,gBAAgB,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAA,gBAAgB,CAAE,KAAlB,CAAwB,GAAxB,CAAA,MAA4B,IAA5B,IAA4B,EAAA,KAAA,KAAA,CAA5B,GAA4B,KAAA,CAA5B,GAA4B,EAAA,CAAG,CAAH,CAR3B;AAUvB,gBAAA,iBAVuB,GAUH,yBAVG;;AAW3B,oBAAI,iBAAJ,EAAuB;AACrB,kBAAA,iBAAiB,GAAG,MAAA,CAAA,OAAA,CAAK,IAAL,CAAU,MAAA,CAAA,OAAA,CAAK,OAAL,CAAa,QAAb,CAAV,EAAkC,iBAAlC,CAApB;AACD;;AAEG,gBAAA,UAfuB,GAeI,IAfJ;AAAA,+BAgBR,CAAC,iBAAD,EAAoB,yBAApB,CAhBQ;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBhB,gBAAA,IAhBgB;AAAA;AAAA;AAAA,iDAkBV,cAAA,CAAA,wBAAA,CAAyB,QAAzB,EAAmC;AAC9C,kBAAA,QAAQ,EAAE,IADoC;AAE9C,kBAAA,QAAQ,EAAE,KAAK,CAAC;AAF8B,iBAAnC,CAlBU;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAuBvB,gBAAA,UAAU,eAAV;AACA,gBAAA,OAAO,CAAC,IAAR,CAAa,kDAAb,EAAiE,IAAjE;;AAxBuB;AAAA;AAAA;AAAA;;AAAA;AAAA,sBA4BrB,UA5BqB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6B5B;AArCkC,GAAjB,CAApB;AAwCA,SAAO,kBACL,GADK,EAEL,GAFK;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,gBAKE,GAAG,CAAC,OALN;AAAA;AAAA;AAAA;;AAAA,8CAMM,GAAG,CAAC,SAAJ,CAAc,GAAd,EAAmB,GAAnB,CAAuB,0BAAvB,CANN;;AAAA;AAAA,0BASe,IAAI,CAAC,KAAL,CAAW,GAAG,CAAC,OAAf,CATf,EASK,KATL,eASK,KATL;AAaG,YAAA,QAbH,GAcD,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,cAAA,CAAA,sBAAA,CAAuB,GAAvB,CAAA,MAA2B,IAA3B,IAA2B,EAAA,KAAA,KAAA,CAA3B,GAA2B,EAA3B,GAA+B,cAAA,CAAA,YAAA,CAAa,sBAAb,CAAoC,KAApC,CAA/B,MAAyE,IAAzE,IAAyE,EAAA,KAAA,KAAA,CAAzE,GAAyE,EAAzE,GAA6E,KAd5E;;AAAA,gBAgBE,QAhBF;AAAA;AAAA;AAAA;;AAAA,8CAiBM,GAAG,CACP,SADI,CACM,GADN,EAEJ,GAFI,CAGH,yGAHG,CAjBN;;AAAA;AAAA;AAAA,6CAwBkB,WAAW,CAAC,OAAZ,CAAoB,KAApB,EAA2B;AAAE,cAAA,QAAQ,EAAR;AAAF,aAA3B,CAxBlB;;AAAA;AAwBG,YAAA,MAxBH;AAAA,8CAyBI,GAAG,CAAC,GAAJ,CAAQ,IAAI,CAAC,SAAL,CAAe,MAAf,CAAR,CAzBJ;;AAAA;AAAA;AAAA;AA2BH,YAAA,OAAO,CAAC,KAAR,kDAAiD,aAAM,KAAvD;AAEA,YAAA,GAAG,CAAC,UAAJ,GAAiB,GAAjB;AA7BG,8CA8BI,GAAG,CAAC,GAAJ,CAAQ,IAAI,CAAC,SAAL,CAAe;AAAE,cAAA,KAAK,EAAE,aAAM;AAAf,aAAf,CAAR,CA9BJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAP;AAiCD;;AApFD,OAAA,CAAA,2BAAA,GAAA,2BAAA","sourcesContent":["import Log from '@expo/bunyan';\nimport { INTERNAL_CALLSITES_REGEX } from '@expo/metro-config';\nimport type { IncomingMessage, ServerResponse } from 'http';\nimport path from 'path';\n\nimport { ReactNativeStackFrame, StackFrame, Symbolicator } from './Symbolicator';\nimport {\n  AnyCompiler,\n  createGetFileNameFromUrl,\n  getFileFromCompilerAsync,\n  getPlatformFromRequest,\n} from './getFileAsync';\n\n// Customize the stack frames like we do in Metro projects.\nfunction customizeFrame(frame: StackFrame) {\n  let collapse = Boolean(frame.file && INTERNAL_CALLSITES_REGEX.test(frame.file));\n\n  if (!collapse) {\n    // This represents the first frame of the stacktrace.\n    // Often this looks like: `__r(0);`.\n    // The URL will also be unactionable in the app and therefore not very useful to the developer.\n    if (\n      frame.column === 3 &&\n      frame.methodName === 'global code' &&\n      frame.file?.match(/^https?:\\/\\//g)\n    ) {\n      collapse = true;\n    }\n  }\n\n  return { ...(frame || {}), collapse };\n}\n\nexport function createSymbolicateMiddleware({\n  projectRoot,\n  logger,\n  compiler,\n}: {\n  projectRoot: string;\n  logger: Log;\n  compiler: AnyCompiler;\n}) {\n  const getFilenameFromUrl = createGetFileNameFromUrl(compiler);\n\n  const symbolicate = new Symbolicator({\n    projectRoot,\n    logger,\n    customizeFrame,\n    async getFileAsync(props) {\n      const fileName = getFilenameFromUrl(props);\n      return getFileFromCompilerAsync(compiler, { fileName, platform: props.platform });\n    },\n    async getSourceMapAsync(props) {\n      const fileName = getFilenameFromUrl(props);\n      const fallbackSourceMapFilename = `${fileName}.map`;\n      const bundle = await getFileFromCompilerAsync(compiler, {\n        fileName,\n        platform: props.platform,\n      });\n      const sourceMappingUrl = /sourceMappingURL=(.+)$/.exec(bundle)?.[1];\n      const sourceMapBasename = sourceMappingUrl?.split('?')?.[0];\n\n      let sourceMapFilename = fallbackSourceMapFilename;\n      if (sourceMapBasename) {\n        sourceMapFilename = path.join(path.dirname(fileName), sourceMapBasename);\n      }\n\n      let parseError: Error | null = null;\n      for (const file of [sourceMapFilename, fallbackSourceMapFilename]) {\n        try {\n          return await getFileFromCompilerAsync(compiler, {\n            fileName: file,\n            platform: props.platform,\n          });\n        } catch (error) {\n          parseError = error;\n          console.warn('Failed to read source map from sourceMappingURL:', file);\n          // logger.warn({ tag: 'dev-server' }, 'Failed to read source map from sourceMappingURL');\n        }\n      }\n      throw parseError;\n    },\n  });\n\n  return async function (\n    req: IncomingMessage & { body?: any; rawBody?: any },\n    res: ServerResponse\n  ) {\n    try {\n      if (!req.rawBody) {\n        return res.writeHead(400).end('Missing request rawBody.');\n      }\n\n      const { stack } = JSON.parse(req.rawBody as string) as {\n        stack: ReactNativeStackFrame[];\n      };\n\n      const platform =\n        getPlatformFromRequest(req) ?? Symbolicator.inferPlatformFromStack(stack) ?? 'web';\n\n      if (!platform) {\n        return res\n          .writeHead(400)\n          .end(\n            'Missing expo-platform header, platform query parameter, or platform parameter in source map comment url'\n          );\n      }\n\n      const parsed = await symbolicate.process(stack, { platform });\n      return res.end(JSON.stringify(parsed));\n    } catch (error) {\n      console.error(`Failed to symbolicate: ${error} ${error.stack}`);\n      // logger.error({ tag: 'dev-server' }, `Failed to symbolicate: ${error} ${error.stack}`);\n      res.statusCode = 500;\n      return res.end(JSON.stringify({ error: error.message }));\n    }\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}