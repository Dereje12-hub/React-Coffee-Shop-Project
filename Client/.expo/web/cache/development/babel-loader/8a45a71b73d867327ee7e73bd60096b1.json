{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateAsync = void 0;\n\nvar parse_png_1 = __importDefault(require(\"parse-png\"));\n\nvar constants = {\n  directorySize: 16,\n  bitmapSize: 40,\n  headerSize: 6,\n  colorMode: 0\n};\n\nfunction createHeader(header) {\n  var buffer = Buffer.alloc(constants.headerSize);\n  buffer.writeUInt16LE(0, 0);\n  buffer.writeUInt16LE(1, 2);\n  buffer.writeUInt16LE(header, 4);\n  return buffer;\n}\n\nfunction createDirectory(data, offset) {\n  var buffer = Buffer.alloc(constants.directorySize);\n  var size = data.data.length + constants.bitmapSize;\n  var width = data.width === 256 ? 0 : data.width;\n  var height = data.height === 256 ? 0 : data.height;\n  var bpp = data.bpp * 8;\n  buffer.writeUInt8(width, 0);\n  buffer.writeUInt8(height, 1);\n  buffer.writeUInt8(0, 2);\n  buffer.writeUInt8(0, 3);\n  buffer.writeUInt16LE(1, 4);\n  buffer.writeUInt16LE(bpp, 6);\n  buffer.writeUInt32LE(size, 8);\n  buffer.writeUInt32LE(offset, 12);\n  return buffer;\n}\n\nfunction createBitmap(data, compression) {\n  var buffer = Buffer.alloc(constants.bitmapSize);\n  buffer.writeUInt32LE(constants.bitmapSize, 0);\n  buffer.writeInt32LE(data.width, 4);\n  buffer.writeInt32LE(data.height * 2, 8);\n  buffer.writeUInt16LE(1, 12);\n  buffer.writeUInt16LE(data.bpp * 8, 14);\n  buffer.writeUInt32LE(compression, 16);\n  buffer.writeUInt32LE(data.data.length, 20);\n  buffer.writeInt32LE(0, 24);\n  buffer.writeInt32LE(0, 28);\n  buffer.writeUInt32LE(0, 32);\n  buffer.writeUInt32LE(0, 36);\n  return buffer;\n}\n\nfunction createDIB(data, width, height, bpp) {\n  var cols = width * bpp;\n  var rows = height * cols;\n  var end = rows - cols;\n  var buffer = Buffer.alloc(data.length);\n\n  for (var row = 0; row < rows; row += cols) {\n    for (var col = 0; col < cols; col += bpp) {\n      var pos = row + col;\n      var r = data.readUInt8(pos);\n      var g = data.readUInt8(pos + 1);\n      var b = data.readUInt8(pos + 2);\n      var a = data.readUInt8(pos + 3);\n      pos = end - row + col;\n      buffer.writeUInt8(b, pos);\n      buffer.writeUInt8(g, pos + 1);\n      buffer.writeUInt8(r, pos + 2);\n      buffer.writeUInt8(a, pos + 3);\n    }\n  }\n\n  return buffer;\n}\n\nfunction generateFromPNGs(pngs) {\n  var header = createHeader(pngs.length);\n  var arr = [header];\n  var len = header.length;\n  var offset = constants.headerSize + constants.directorySize * pngs.length;\n\n  for (var _iterator = _createForOfIteratorHelperLoose(pngs), _step; !(_step = _iterator()).done;) {\n    var png = _step.value;\n    var dir = createDirectory(png, offset);\n    arr.push(dir);\n    len += dir.length;\n    offset += png.data.length + constants.bitmapSize;\n  }\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(pngs), _step2; !(_step2 = _iterator2()).done;) {\n    var _png = _step2.value;\n\n    var _header = createBitmap(_png, constants.colorMode);\n\n    var dib = createDIB(_png.data, _png.width, _png.height, _png.bpp);\n    arr.push(_header, dib);\n    len += _header.length + dib.length;\n  }\n\n  return Buffer.concat(arr, len);\n}\n\nfunction generateAsync(buffers) {\n  var pngs;\n  return _regeneratorRuntime.async(function generateAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(Promise.all(buffers.map(function (x) {\n            return parse_png_1.default(x);\n          })));\n\n        case 2:\n          pngs = _context.sent;\n          return _context.abrupt(\"return\", generateFromPNGs(pngs));\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.generateAsync = generateAsync;","map":{"version":3,"sources":["../src/Ico.ts"],"names":[],"mappings":"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","sourcesContent":["// Inspired by https://github.com/kevva/to-ico but reuses existing packages to keep bundle size small.\nimport parsePng from 'parse-png';\n\ntype PNG = {\n  data: Buffer;\n  width: number;\n  height: number;\n  bpp: number;\n};\n\nconst constants = {\n  directorySize: 16,\n  bitmapSize: 40,\n  headerSize: 6,\n  colorMode: 0,\n};\n\nfunction createHeader(header: number): Buffer {\n  const buffer = Buffer.alloc(constants.headerSize);\n\n  buffer.writeUInt16LE(0, 0);\n  buffer.writeUInt16LE(1, 2);\n  buffer.writeUInt16LE(header, 4);\n\n  return buffer;\n}\n\nfunction createDirectory(data: PNG, offset: number): Buffer {\n  const buffer = Buffer.alloc(constants.directorySize);\n  const size = data.data.length + constants.bitmapSize;\n  const width = data.width === 256 ? 0 : data.width;\n  const height = data.height === 256 ? 0 : data.height;\n  const bpp = data.bpp * 8;\n\n  buffer.writeUInt8(width, 0);\n  buffer.writeUInt8(height, 1);\n  buffer.writeUInt8(0, 2);\n  buffer.writeUInt8(0, 3);\n  buffer.writeUInt16LE(1, 4);\n  buffer.writeUInt16LE(bpp, 6);\n  buffer.writeUInt32LE(size, 8);\n  buffer.writeUInt32LE(offset, 12);\n\n  return buffer;\n}\n\nfunction createBitmap(data: PNG, compression: number): Buffer {\n  const buffer = Buffer.alloc(constants.bitmapSize);\n\n  buffer.writeUInt32LE(constants.bitmapSize, 0);\n  buffer.writeInt32LE(data.width, 4);\n  buffer.writeInt32LE(data.height * 2, 8);\n  buffer.writeUInt16LE(1, 12);\n  buffer.writeUInt16LE(data.bpp * 8, 14);\n  buffer.writeUInt32LE(compression, 16);\n  buffer.writeUInt32LE(data.data.length, 20);\n  buffer.writeInt32LE(0, 24);\n  buffer.writeInt32LE(0, 28);\n  buffer.writeUInt32LE(0, 32);\n  buffer.writeUInt32LE(0, 36);\n\n  return buffer;\n}\n\nfunction createDIB(data: Buffer, width: number, height: number, bpp: number): Buffer {\n  const cols = width * bpp;\n  const rows = height * cols;\n  const end = rows - cols;\n  const buffer = Buffer.alloc(data.length);\n\n  for (let row = 0; row < rows; row += cols) {\n    for (let col = 0; col < cols; col += bpp) {\n      let pos = row + col;\n\n      const r = data.readUInt8(pos);\n      const g = data.readUInt8(pos + 1);\n      const b = data.readUInt8(pos + 2);\n      const a = data.readUInt8(pos + 3);\n\n      pos = end - row + col;\n\n      buffer.writeUInt8(b, pos);\n      buffer.writeUInt8(g, pos + 1);\n      buffer.writeUInt8(r, pos + 2);\n      buffer.writeUInt8(a, pos + 3);\n    }\n  }\n\n  return buffer;\n}\n\nfunction generateFromPNGs(pngs: PNG[]): Buffer {\n  const header = createHeader(pngs.length);\n  const arr = [header];\n\n  let len = header.length;\n  let offset = constants.headerSize + constants.directorySize * pngs.length;\n\n  for (const png of pngs) {\n    const dir = createDirectory(png, offset);\n    arr.push(dir);\n    len += dir.length;\n    offset += png.data.length + constants.bitmapSize;\n  }\n\n  for (const png of pngs) {\n    const header = createBitmap(png, constants.colorMode);\n    const dib = createDIB(png.data, png.width, png.height, png.bpp);\n    arr.push(header, dib);\n    len += header.length + dib.length;\n  }\n\n  return Buffer.concat(arr, len);\n}\n\nexport async function generateAsync(buffers: Buffer[]): Promise<Buffer> {\n  const pngs: PNG[] = await Promise.all(buffers.map(x => parsePng(x)));\n  return generateFromPNGs(pngs);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}