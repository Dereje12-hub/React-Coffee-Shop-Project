{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getChromeIconConfig = exports.getFaviconIconConfig = exports.getSafariIconConfig = exports.getSafariStartupImageConfig = exports.getConfigForPWA = exports.generateManifestJson = exports.generateManifestAsync = exports.generateFaviconAsync = exports.generateChromeIconAsync = exports.generateAppleIconAsync = exports.generateSplashAsync = exports.generateAsync = exports.joinUrlPath = void 0;\n\nvar config_1 = require(\"@expo/config\");\n\nvar Image = __importStar(require(\"@expo/image-utils\"));\n\nvar path = __importStar(require(\"path\"));\n\nvar url_1 = require(\"url\");\n\nvar Manifest_1 = require(\"./Manifest\");\n\nObject.defineProperty(exports, \"getConfigForPWA\", {\n  enumerable: true,\n  get: function get() {\n    return Manifest_1.getConfigForPWA;\n  }\n});\n\nvar Splash_1 = require(\"./Splash\");\n\nfunction joinUrlPath(publicPath) {\n  for (var _len = arguments.length, toJoin = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    toJoin[_key - 1] = arguments[_key];\n  }\n\n  var segments = path.join.apply(path, toJoin);\n\n  try {\n    return new url_1.URL(segments, publicPath).href;\n  } catch (_unused) {\n    return path.join(publicPath, segments);\n  }\n}\n\nexports.joinUrlPath = joinUrlPath;\n\nfunction generateAsync(type, options, icon) {\n  return _regeneratorRuntime.async(function generateAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.t0 = type;\n          _context.next = _context.t0 === 'splash' ? 3 : _context.t0 === 'safari-icon' ? 4 : _context.t0 === 'chrome-icon' ? 5 : _context.t0 === 'favicon' ? 6 : 7;\n          break;\n\n        case 3:\n          return _context.abrupt(\"return\", generateSplashAsync(options, icon));\n\n        case 4:\n          return _context.abrupt(\"return\", generateAppleIconAsync(options, icon, {}));\n\n        case 5:\n          return _context.abrupt(\"return\", generateChromeIconAsync(options, icon, {}));\n\n        case 6:\n          return _context.abrupt(\"return\", generateFaviconAsync(options, icon));\n\n        case 7:\n          throw new Error(\"Invalid command type: \" + type);\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.generateAsync = generateAsync;\n\nfunction generateSplashAsync(_ref, icon) {\n  var projectRoot, publicPath, cacheType, devices, icons, _iterator, _step, device, _iterator2, _step2, orientation, width, height, name, data;\n\n  return _regeneratorRuntime.async(function generateSplashAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          projectRoot = _ref.projectRoot, publicPath = _ref.publicPath;\n          cacheType = 'apple-touch-startup-image';\n          devices = Splash_1.getDevices();\n          icons = Array.isArray(icon) ? icon : [];\n\n          if (!Array.isArray(icon)) {\n            for (_iterator = _createForOfIteratorHelperLoose(devices); !(_step = _iterator()).done;) {\n              device = _step.value;\n\n              for (_iterator2 = _createForOfIteratorHelperLoose(device.orientations); !(_step2 = _iterator2()).done;) {\n                orientation = _step2.value;\n                width = 0;\n                height = 0;\n\n                if (orientation !== 'portrait') {\n                  width = device.height;\n                  height = device.width;\n                } else {\n                  height = device.height;\n                  width = device.width;\n                }\n\n                name = \"apple-touch-startup-image-\" + width + \"x\" + height + \".png\";\n                icons.push(_objectSpread(_objectSpread({}, icon), {}, {\n                  name: name,\n                  width: width,\n                  height: height,\n                  media: Splash_1.assembleOrientationMedia(device.width, device.height, device.scale, orientation)\n                }));\n              }\n            }\n          }\n\n          _context3.next = 7;\n          return _regeneratorRuntime.awrap(Promise.all(icons.map(function _callee(icon) {\n            var _await$Image$generate, source, name, href;\n\n            return _regeneratorRuntime.async(function _callee$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    if (!icon.resizeMode) {\n                      icon.resizeMode = 'contain';\n                    }\n\n                    _context2.next = 3;\n                    return _regeneratorRuntime.awrap(Image.generateImageAsync({\n                      projectRoot: projectRoot,\n                      cacheType: cacheType\n                    }, icon));\n\n                  case 3:\n                    _await$Image$generate = _context2.sent;\n                    source = _await$Image$generate.source;\n                    name = _await$Image$generate.name;\n                    href = \"pwa/apple-touch-startup-image/\" + name;\n                    return _context2.abrupt(\"return\", {\n                      asset: {\n                        source: source,\n                        path: href\n                      },\n                      tag: {\n                        tagName: 'link',\n                        attributes: {\n                          rel: 'apple-touch-startup-image',\n                          media: icon.media,\n                          href: joinUrlPath(publicPath, href)\n                        }\n                      }\n                    });\n\n                  case 8:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          })));\n\n        case 7:\n          data = _context3.sent;\n          _context3.next = 10;\n          return _regeneratorRuntime.awrap(Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType));\n\n        case 10:\n          return _context3.abrupt(\"return\", data);\n\n        case 11:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.generateSplashAsync = generateSplashAsync;\n\nfunction generateAppleIconAsync(_ref2, icon, _ref3) {\n  var projectRoot, publicPath, _ref3$sizes, sizes, cacheType, data;\n\n  return _regeneratorRuntime.async(function generateAppleIconAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          projectRoot = _ref2.projectRoot, publicPath = _ref2.publicPath;\n          _ref3$sizes = _ref3.sizes, sizes = _ref3$sizes === void 0 ? [180] : _ref3$sizes;\n          cacheType = 'apple-touch-icon';\n          _context5.next = 5;\n          return _regeneratorRuntime.awrap(Promise.all(sizes.map(function _callee2(size) {\n            var rel, _await$Image$generate2, source, name, href;\n\n            return _regeneratorRuntime.async(function _callee2$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    rel = 'apple-touch-icon';\n                    _context4.next = 3;\n                    return _regeneratorRuntime.awrap(Image.generateImageAsync({\n                      projectRoot: projectRoot,\n                      cacheType: cacheType\n                    }, _objectSpread(_objectSpread({}, icon), {}, {\n                      width: size,\n                      height: size,\n                      name: rel + \"-\" + size + \".png\"\n                    })));\n\n                  case 3:\n                    _await$Image$generate2 = _context4.sent;\n                    source = _await$Image$generate2.source;\n                    name = _await$Image$generate2.name;\n                    href = \"pwa/\" + rel + \"/\" + name;\n                    return _context4.abrupt(\"return\", {\n                      asset: {\n                        source: source,\n                        path: href\n                      },\n                      tag: {\n                        tagName: 'link',\n                        attributes: {\n                          rel: rel,\n                          sizes: size + \"x\" + size,\n                          href: joinUrlPath(publicPath, href)\n                        }\n                      }\n                    });\n\n                  case 8:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          })));\n\n        case 5:\n          data = _context5.sent;\n\n          if (sizes.length) {\n            _context5.next = 9;\n            break;\n          }\n\n          _context5.next = 9;\n          return _regeneratorRuntime.awrap(Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType));\n\n        case 9:\n          return _context5.abrupt(\"return\", data);\n\n        case 10:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.generateAppleIconAsync = generateAppleIconAsync;\n\nfunction generateChromeIconAsync(_ref4, icon, _ref5) {\n  var projectRoot, publicPath, _ref5$sizes, sizes, cacheType, data;\n\n  return _regeneratorRuntime.async(function generateChromeIconAsync$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          projectRoot = _ref4.projectRoot, publicPath = _ref4.publicPath;\n          _ref5$sizes = _ref5.sizes, sizes = _ref5$sizes === void 0 ? [144, 192, 512] : _ref5$sizes;\n          cacheType = 'chrome-icon';\n          _context7.next = 5;\n          return _regeneratorRuntime.awrap(Promise.all(sizes.map(function _callee3(size) {\n            var rel, _await$Image$generate3, source, name, href;\n\n            return _regeneratorRuntime.async(function _callee3$(_context6) {\n              while (1) {\n                switch (_context6.prev = _context6.next) {\n                  case 0:\n                    rel = 'chrome-icon';\n                    _context6.next = 3;\n                    return _regeneratorRuntime.awrap(Image.generateImageAsync({\n                      projectRoot: projectRoot,\n                      cacheType: cacheType\n                    }, _objectSpread(_objectSpread({}, icon), {}, {\n                      width: size,\n                      height: size,\n                      name: rel + \"-\" + size + \".png\"\n                    })));\n\n                  case 3:\n                    _await$Image$generate3 = _context6.sent;\n                    source = _await$Image$generate3.source;\n                    name = _await$Image$generate3.name;\n                    href = \"pwa/\" + rel + \"/\" + name;\n                    return _context6.abrupt(\"return\", {\n                      asset: {\n                        source: source,\n                        path: href\n                      },\n                      manifest: {\n                        src: joinUrlPath(publicPath, href),\n                        sizes: size + \"x\" + size,\n                        type: 'image/png'\n                      }\n                    });\n\n                  case 8:\n                  case \"end\":\n                    return _context6.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          })));\n\n        case 5:\n          data = _context7.sent;\n\n          if (sizes.length) {\n            _context7.next = 9;\n            break;\n          }\n\n          _context7.next = 9;\n          return _regeneratorRuntime.awrap(Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType));\n\n        case 9:\n          return _context7.abrupt(\"return\", data);\n\n        case 10:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.generateChromeIconAsync = generateChromeIconAsync;\n\nfunction generateFaviconAsync(_ref6, icon) {\n  var projectRoot, publicPath, cacheType, dimensions, data, faviconUrl, largestImageBuffer, faviconBuffer;\n  return _regeneratorRuntime.async(function generateFaviconAsync$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          projectRoot = _ref6.projectRoot, publicPath = _ref6.publicPath;\n          cacheType = 'favicon';\n          dimensions = [16, 32, 48];\n          _context9.next = 5;\n          return _regeneratorRuntime.awrap(Promise.all(dimensions.map(function _callee4(size) {\n            var rel, _await$Image$generate4, source, name, href;\n\n            return _regeneratorRuntime.async(function _callee4$(_context8) {\n              while (1) {\n                switch (_context8.prev = _context8.next) {\n                  case 0:\n                    rel = 'icon';\n                    _context8.next = 3;\n                    return _regeneratorRuntime.awrap(Image.generateImageAsync({\n                      projectRoot: projectRoot,\n                      cacheType: cacheType\n                    }, _objectSpread(_objectSpread({}, icon), {}, {\n                      backgroundColor: icon.backgroundColor || 'transparent',\n                      width: size,\n                      height: size,\n                      name: \"favicon-\" + size + \".png\"\n                    })));\n\n                  case 3:\n                    _await$Image$generate4 = _context8.sent;\n                    source = _await$Image$generate4.source;\n                    name = _await$Image$generate4.name;\n                    href = \"\" + name;\n                    return _context8.abrupt(\"return\", {\n                      asset: {\n                        source: source,\n                        path: href\n                      },\n                      tag: {\n                        tagName: 'link',\n                        attributes: {\n                          rel: rel,\n                          type: 'image/png',\n                          sizes: size + \"x\" + size,\n                          href: joinUrlPath(publicPath, href)\n                        }\n                      }\n                    });\n\n                  case 8:\n                  case \"end\":\n                    return _context8.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          })));\n\n        case 5:\n          data = _context9.sent;\n          faviconUrl = joinUrlPath(publicPath, 'favicon.ico');\n          largestImageBuffer = data[data.length - 1].asset.source;\n          _context9.next = 10;\n          return _regeneratorRuntime.awrap(Image.generateFaviconAsync(largestImageBuffer, dimensions));\n\n        case 10:\n          faviconBuffer = _context9.sent;\n          _context9.next = 13;\n          return _regeneratorRuntime.awrap(Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType));\n\n        case 13:\n          return _context9.abrupt(\"return\", [data[0], data[1], {\n            asset: {\n              source: faviconBuffer,\n              path: 'favicon.ico'\n            },\n            tag: {\n              tagName: 'link',\n              attributes: {\n                rel: 'shortcut icon',\n                href: faviconUrl\n              }\n            }\n          }]);\n\n        case 14:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.generateFaviconAsync = generateFaviconAsync;\n\nfunction generateManifestAsync(options, configPath, config) {\n  var manifest;\n  return _regeneratorRuntime.async(function generateManifestAsync$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          if (configPath) {\n            config_1.setCustomConfigPath(options.projectRoot, configPath);\n          }\n\n          manifest = generateManifestJson(options, config);\n          return _context10.abrupt(\"return\", [{\n            asset: {\n              source: JSON.stringify(manifest, null, 2),\n              path: 'manifest.json'\n            },\n            tag: {\n              tagName: 'link',\n              attributes: {\n                rel: 'manifest',\n                href: joinUrlPath(options.publicPath, 'manifest.json')\n              }\n            }\n          }]);\n\n        case 3:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.generateManifestAsync = generateManifestAsync;\n\nfunction generateManifestJson(_ref7, config) {\n  var projectRoot = _ref7.projectRoot;\n\n  if (!config) {\n    if (!projectRoot) throw new Error('You must either define projectRoot or config');\n    config = Manifest_1.getConfigForPWA(projectRoot);\n  }\n\n  return Manifest_1.createPWAManifestFromWebConfig(config.web);\n}\n\nexports.generateManifestJson = generateManifestJson;\n\nvar Manifest_2 = require(\"./Manifest\");\n\nObject.defineProperty(exports, \"getSafariStartupImageConfig\", {\n  enumerable: true,\n  get: function get() {\n    return Manifest_2.getSafariStartupImageConfig;\n  }\n});\nObject.defineProperty(exports, \"getSafariIconConfig\", {\n  enumerable: true,\n  get: function get() {\n    return Manifest_2.getSafariIconConfig;\n  }\n});\nObject.defineProperty(exports, \"getFaviconIconConfig\", {\n  enumerable: true,\n  get: function get() {\n    return Manifest_2.getFaviconIconConfig;\n  }\n});\nObject.defineProperty(exports, \"getChromeIconConfig\", {\n  enumerable: true,\n  get: function get() {\n    return Manifest_2.getChromeIconConfig;\n  }\n});","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { ExpoConfig, setCustomConfigPath } from '@expo/config';\nimport * as Image from '@expo/image-utils';\nimport * as path from 'path';\nimport { URL } from 'url';\n\nimport { createPWAManifestFromWebConfig, getConfigForPWA } from './Manifest';\nimport { HTMLOutput, IconOptions, Manifest, ProjectOptions, SplashIcon } from './Manifest.types';\nimport { assembleOrientationMedia, getDevices } from './Splash';\n\n/**\n * Joins a url protocol + host to path segments, falls back to path.join\n * if result is not a valid url.\n */\nexport function joinUrlPath(publicPath: string, ...toJoin: string[]): string {\n  const segments = path.join(...toJoin);\n  try {\n    // Throws if publicPath is not a valid protocol+host\n    return new URL(segments, publicPath).href;\n  } catch {\n    return path.join(publicPath, segments);\n  }\n}\n\nexport async function generateAsync(\n  type: string,\n  options: ProjectOptions,\n  icon: IconOptions\n): Promise<HTMLOutput[]> {\n  switch (type) {\n    case 'splash':\n      return generateSplashAsync(options, icon);\n    case 'safari-icon':\n      return generateAppleIconAsync(options, icon, {});\n    case 'chrome-icon':\n      return generateChromeIconAsync(options, icon, {});\n    case 'favicon':\n      return generateFaviconAsync(options, icon);\n  }\n  throw new Error(`Invalid command type: ${type}`);\n}\n\nexport async function generateSplashAsync(\n  { projectRoot, publicPath }: ProjectOptions,\n  icon: IconOptions\n): Promise<HTMLOutput[]> {\n  const cacheType = 'apple-touch-startup-image';\n\n  // You cannot lock iOS PWA orientation, we should produce every splash screen\n  // orientation. We don't however because in iOS 13 it's far more rare to see landscape splash screens.\n  const devices = getDevices();\n\n  const icons: SplashIcon[] = Array.isArray(icon) ? icon : [];\n  if (!Array.isArray(icon)) {\n    for (const device of devices) {\n      for (const orientation of device.orientations) {\n        let width = 0;\n        let height = 0;\n        if (orientation !== 'portrait') {\n          width = device.height;\n          height = device.width;\n        } else {\n          height = device.height;\n          width = device.width;\n        }\n\n        const name = `apple-touch-startup-image-${width}x${height}.png`;\n        icons.push({\n          ...icon,\n          name,\n          width,\n          height,\n          media: assembleOrientationMedia(device.width, device.height, device.scale, orientation),\n        });\n      }\n    }\n  }\n\n  const data = await Promise.all<HTMLOutput>(\n    icons.map(\n      async (icon: SplashIcon): Promise<HTMLOutput> => {\n        // Ensure the default `splash.resizeMode` is used here:\n        // https://docs.expo.dev/versions/latest/config/app/#splash\n        if (!icon.resizeMode) {\n          icon.resizeMode = 'contain';\n        }\n        const { source, name } = await Image.generateImageAsync({ projectRoot, cacheType }, icon);\n\n        const href = `pwa/apple-touch-startup-image/${name}`;\n\n        return {\n          asset: {\n            source,\n            path: href,\n          },\n          tag: {\n            tagName: 'link',\n            attributes: {\n              rel: 'apple-touch-startup-image',\n              media: icon.media,\n              // TODO(Bacon): Use sizes to query splash screens better\n              // sizes: `${icon.width}x${icon.height}`,\n              href: joinUrlPath(publicPath, href),\n            },\n          },\n        };\n      }\n    )\n  );\n\n  await Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType);\n\n  return data;\n}\n\nexport async function generateAppleIconAsync(\n  { projectRoot, publicPath }: ProjectOptions,\n  icon: IconOptions,\n  { sizes = [180] }: { sizes?: number[] }\n): Promise<HTMLOutput[]> {\n  const cacheType = 'apple-touch-icon';\n\n  const data = await Promise.all<HTMLOutput>(\n    sizes.map(\n      async (size: number): Promise<HTMLOutput> => {\n        const rel = 'apple-touch-icon';\n        const { source, name } = await Image.generateImageAsync(\n          { projectRoot, cacheType },\n          { ...icon, width: size, height: size, name: `${rel}-${size}.png` }\n        );\n\n        const href = `pwa/${rel}/${name}`;\n\n        return {\n          asset: {\n            source,\n            path: href,\n          },\n          tag: {\n            tagName: 'link',\n            attributes: {\n              rel,\n              sizes: `${size}x${size}`,\n              href: joinUrlPath(publicPath, href),\n            },\n          },\n        };\n      }\n    )\n  );\n\n  // Don't clear the caches if no generation was performed.\n  if (!sizes.length) {\n    await Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType);\n  }\n\n  return data;\n}\n\nexport async function generateChromeIconAsync(\n  { projectRoot, publicPath }: ProjectOptions,\n  icon: IconOptions,\n  { sizes = [144, 192, 512] }: { sizes?: number[] }\n): Promise<HTMLOutput[]> {\n  const cacheType = 'chrome-icon';\n\n  const data = await Promise.all<HTMLOutput>(\n    sizes.map(\n      async (size: number): Promise<HTMLOutput> => {\n        const rel = 'chrome-icon';\n        const { source, name } = await Image.generateImageAsync(\n          { projectRoot, cacheType },\n          { ...icon, width: size, height: size, name: `${rel}-${size}.png` }\n        );\n\n        const href = `pwa/${rel}/${name}`;\n\n        return {\n          asset: {\n            source,\n            path: href,\n          },\n          manifest: {\n            src: joinUrlPath(publicPath, href),\n            sizes: `${size}x${size}`,\n            type: 'image/png',\n          },\n        };\n      }\n    )\n  );\n\n  // Don't clear the caches if no generation was performed.\n  if (!sizes.length) {\n    await Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType);\n  }\n\n  return data;\n}\n\nexport async function generateFaviconAsync(\n  { projectRoot, publicPath }: ProjectOptions,\n  icon: IconOptions\n): Promise<HTMLOutput[]> {\n  const cacheType = 'favicon';\n  const dimensions = [16, 32, 48];\n  const data: HTMLOutput[] = await Promise.all<HTMLOutput>(\n    dimensions.map(\n      async (size: number): Promise<HTMLOutput> => {\n        const rel = 'icon';\n        const { source, name } = await Image.generateImageAsync(\n          { projectRoot, cacheType },\n          {\n            ...icon,\n            backgroundColor: icon.backgroundColor || 'transparent',\n            width: size,\n            height: size,\n            name: `favicon-${size}.png`,\n          }\n        );\n\n        const href = `${name}`;\n\n        return {\n          asset: {\n            source,\n            path: href,\n          },\n          tag: {\n            tagName: 'link',\n            attributes: {\n              rel,\n              type: 'image/png',\n              sizes: `${size}x${size}`,\n              href: joinUrlPath(publicPath, href),\n            },\n          },\n        };\n      }\n    )\n  );\n\n  const faviconUrl = joinUrlPath(publicPath, 'favicon.ico');\n\n  const largestImageBuffer = data[data.length - 1].asset.source;\n\n  const faviconBuffer = await Image.generateFaviconAsync(largestImageBuffer, dimensions);\n\n  await Image.Cache.clearUnusedCachesAsync(projectRoot, cacheType);\n\n  return [\n    data[0],\n    data[1],\n    {\n      asset: { source: faviconBuffer, path: 'favicon.ico' },\n      tag: {\n        tagName: 'link',\n        attributes: { rel: 'shortcut icon', href: faviconUrl },\n      },\n    },\n  ];\n}\n\nexport async function generateManifestAsync(\n  options: ProjectOptions,\n  configPath?: string,\n  config?: ExpoConfig\n): Promise<HTMLOutput[]> {\n  if (configPath) {\n    setCustomConfigPath(options.projectRoot, configPath);\n  }\n  const manifest = generateManifestJson(options, config);\n  return [\n    {\n      // TODO: Bacon: Make the types more flexible\n      asset: { source: JSON.stringify(manifest, null, 2) as any, path: 'manifest.json' },\n      tag: {\n        tagName: 'link',\n        attributes: { rel: 'manifest', href: joinUrlPath(options.publicPath, 'manifest.json') },\n      },\n    },\n  ];\n}\n\nexport function generateManifestJson(\n  { projectRoot }: Partial<ProjectOptions>,\n  config?: ExpoConfig\n): Manifest {\n  if (!config) {\n    if (!projectRoot) throw new Error('You must either define projectRoot or config');\n    config = getConfigForPWA(projectRoot);\n  }\n  return createPWAManifestFromWebConfig(config.web);\n}\n\nexport { getConfigForPWA };\nexport {\n  getSafariStartupImageConfig,\n  getSafariIconConfig,\n  getFaviconIconConfig,\n  getChromeIconConfig,\n} from './Manifest';\n\nexport { IconOptions, ProjectOptions, HTMLOutput, PWAConfig } from './Manifest.types';\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}