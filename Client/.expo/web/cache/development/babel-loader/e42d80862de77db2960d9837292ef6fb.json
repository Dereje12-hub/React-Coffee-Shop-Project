{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _excluded = [\"modRequest\"],\n    _excluded2 = [\"nextMod\"],\n    _excluded3 = [\"modRequest\", \"modResults\"];\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withBaseMod = withBaseMod;\nexports.withMod = withMod;\n\nfunction _chalk() {\n  var data = _interopRequireDefault(require(\"chalk\"));\n\n  _chalk = function _chalk() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _getenv() {\n  var data = require(\"getenv\");\n\n  _getenv = function _getenv() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _errors() {\n  var data = require(\"../utils/errors\");\n\n  _errors = function _errors() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar EXPO_DEBUG = (0, _getenv().boolish)('EXPO_DEBUG', false);\n\nfunction withBaseMod(config, _ref2) {\n  var platform = _ref2.platform,\n      mod = _ref2.mod,\n      action = _ref2.action,\n      skipEmptyMod = _ref2.skipEmptyMod,\n      isProvider = _ref2.isProvider,\n      isIntrospective = _ref2.isIntrospective,\n      saveToInternal = _ref2.saveToInternal;\n\n  var _config$_internal$isD, _config$_internal;\n\n  if (!config.mods) {\n    config.mods = {};\n  }\n\n  if (!config.mods[platform]) {\n    config.mods[platform] = {};\n  }\n\n  var interceptedMod = config.mods[platform][mod];\n\n  if (!interceptedMod) {\n    if (skipEmptyMod) {\n      return config;\n    }\n\n    var noopMod = function noopMod(config) {\n      return config;\n    };\n\n    interceptedMod = noopMod;\n  }\n\n  var debugTrace = '';\n  var isDebug = (_config$_internal$isD = (_config$_internal = config._internal) === null || _config$_internal === void 0 ? void 0 : _config$_internal.isDebug) !== null && _config$_internal$isD !== void 0 ? _config$_internal$isD : EXPO_DEBUG;\n\n  if (isDebug) {\n    var stack = new Error().stack;\n    debugTrace = getDebugPluginStackFromStackTrace(stack);\n\n    var modStack = _chalk().default.bold(platform + \".\" + mod);\n\n    debugTrace = modStack + \": \" + debugTrace;\n  }\n\n  if (interceptedMod.isProvider) {\n    if (isProvider) {\n      throw new (_errors().PluginError)(\"Cannot set provider mod for \\\"\" + platform + \".\" + mod + \"\\\" because another is already being used.\", 'CONFLICTING_PROVIDER');\n    } else {\n      throw new (_errors().PluginError)(\"Cannot add mod to \\\"\" + platform + \".\" + mod + \"\\\" because the provider has already been added. Provider must be the last mod added.\", 'INVALID_MOD_ORDER');\n    }\n  }\n\n  function interceptingMod(_ref3) {\n    var modRequest, config, results;\n    return _regeneratorRuntime.async(function interceptingMod$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            modRequest = _ref3.modRequest, config = _objectWithoutProperties(_ref3, _excluded);\n\n            if (isDebug) {\n              console.log(debugTrace);\n            }\n\n            _context.next = 4;\n            return _regeneratorRuntime.awrap(action(_objectSpread(_objectSpread({}, config), {}, {\n              modRequest: _objectSpread(_objectSpread({}, modRequest), {}, {\n                nextMod: interceptedMod\n              })\n            })));\n\n          case 4:\n            results = _context.sent;\n\n            if (saveToInternal) {\n              saveToInternalObject(results, platform, mod, results.modResults);\n            }\n\n            return _context.abrupt(\"return\", results);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n\n  interceptingMod.isProvider = isProvider;\n\n  if (isIntrospective) {\n    interceptingMod.isIntrospective = isIntrospective;\n  }\n\n  config.mods[platform][mod] = interceptingMod;\n  return config;\n}\n\nfunction saveToInternalObject(config, platformName, modName, results) {\n  if (!config._internal) config._internal = {};\n  if (!config._internal.modResults) config._internal.modResults = {};\n  if (!config._internal.modResults[platformName]) config._internal.modResults[platformName] = {};\n  config._internal.modResults[platformName][modName] = results;\n}\n\nfunction getDebugPluginStackFromStackTrace(stacktrace) {\n  if (!stacktrace) {\n    return '';\n  }\n\n  var treeStackLines = [];\n\n  for (var _iterator = _createForOfIteratorHelperLoose(stacktrace.split('\\n')), _step; !(_step = _iterator()).done;) {\n    var line = _step.value;\n\n    var _line$trim$split = line.trim().split(' '),\n        _line$trim$split2 = _slicedToArray(_line$trim$split, 2),\n        first = _line$trim$split2[0],\n        second = _line$trim$split2[1];\n\n    if (first === 'at') {\n      treeStackLines.push(second);\n    }\n  }\n\n  var plugins = treeStackLines.map(function (first) {\n    var _ref, _first$match$1$trim, _first$match, _first$match$, _first$match2, _first$match2$;\n\n    return (_ref = (_first$match$1$trim = first === null || first === void 0 ? void 0 : (_first$match = first.match(/^(\\bwith[A-Z].*?\\b)/)) === null || _first$match === void 0 ? void 0 : (_first$match$ = _first$match[1]) === null || _first$match$ === void 0 ? void 0 : _first$match$.trim()) !== null && _first$match$1$trim !== void 0 ? _first$match$1$trim : first === null || first === void 0 ? void 0 : (_first$match2 = first.match(/\\.(\\bwith[A-Z].*?\\b)/)) === null || _first$match2 === void 0 ? void 0 : (_first$match2$ = _first$match2[1]) === null || _first$match2$ === void 0 ? void 0 : _first$match2$.trim()) !== null && _ref !== void 0 ? _ref : null;\n  }).filter(Boolean).filter(function (plugin) {\n    return !['withMod', 'withBaseMod', 'withExtendedMod'].includes(plugin);\n  });\n  var commonPlugins = ['withPlugins', 'withRunOnce', 'withStaticPlugin'];\n  return plugins.reverse().map(function (pluginName, index) {\n    if (pluginName.includes('BaseMod')) {\n      pluginName = _chalk().default.bold(pluginName);\n    }\n\n    if (pluginName.toLowerCase().includes('dangerous')) {\n      pluginName = _chalk().default.red(pluginName);\n    }\n\n    if (index === 0) {\n      return _chalk().default.blue(pluginName);\n    } else if (commonPlugins.includes(pluginName)) {\n      return _chalk().default.dim(pluginName);\n    }\n\n    return pluginName;\n  }).join(' ➜ ');\n}\n\nfunction withMod(config, _ref4) {\n  var platform = _ref4.platform,\n      mod = _ref4.mod,\n      _action = _ref4.action;\n  return withBaseMod(config, {\n    platform: platform,\n    mod: mod,\n    isProvider: false,\n    action: function action(_ref5) {\n      return function _callee() {\n        var _ref5$modRequest, nextMod, modRequest, modResults, config, results;\n\n        return _regeneratorRuntime.async(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _ref5$modRequest = _ref5.modRequest, nextMod = _ref5$modRequest.nextMod, modRequest = _objectWithoutProperties(_ref5$modRequest, _excluded2), modResults = _ref5.modResults, config = _objectWithoutProperties(_ref5, _excluded3);\n                _context2.next = 3;\n                return _regeneratorRuntime.awrap(_action(_objectSpread({\n                  modRequest: modRequest,\n                  modResults: modResults\n                }, config)));\n\n              case 3:\n                results = _context2.sent;\n                return _context2.abrupt(\"return\", nextMod(results));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      }();\n    }\n  });\n}","map":{"version":3,"sources":["../../src/plugins/withMod.ts"],"names":["EXPO_DEBUG","saveToInternal","config","interceptedMod","noopMod","debugTrace","isDebug","stack","getDebugPluginStackFromStackTrace","modStack","chalk","platform","PluginError","console","results","action","modRequest","nextMod","saveToInternalObject","interceptingMod","treeStackLines","stacktrace","line","first","plugins","plugin","commonPlugins","pluginName","index","withBaseMod","mod","isProvider","modResults"],"mappings":"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","sourcesContent":["import { ExpoConfig } from '@expo/config-types';\nimport { JSONObject } from '@expo/json-file';\nimport chalk from 'chalk';\nimport { boolish } from 'getenv';\n\nimport { ExportedConfig, ExportedConfigWithProps, Mod, ModPlatform } from '../Plugin.types';\nimport { PluginError } from '../utils/errors';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\n\nexport type BaseModOptions = {\n  platform: ModPlatform;\n  mod: string;\n  isProvider?: boolean;\n  skipEmptyMod?: boolean;\n  saveToInternal?: boolean;\n  /**\n   * If the mod supports introspection, and avoids making any filesystem modifications during compilation.\n   * By enabling, this mod, and all of its descendants will be run in introspection mode.\n   * This should only be used for static files like JSON or XML, and not for application files that require regexes,\n   * or complex static files that require other files to be generated like Xcode `.pbxproj`.\n   */\n  isIntrospective?: boolean;\n};\n\n/**\n * Plugin to intercept execution of a given `mod` with the given `action`.\n * If an action was already set on the given `config` config for `mod`, then it\n * will be provided to the `action` as `nextMod` when it's evaluated, otherwise\n * `nextMod` will be an identity function.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to intercept\n * @param skipEmptyMod should skip running the action if there is no existing mod to intercept\n * @param saveToInternal should save the results to `_internal.modResults`, only enable this when the results are pure JSON.\n * @param isProvider should provide data up to the other mods.\n * @param action method to run on the mod when the config is compiled\n */\nexport function withBaseMod<T>(\n  config: ExportedConfig,\n  {\n    platform,\n    mod,\n    action,\n    skipEmptyMod,\n    isProvider,\n    isIntrospective,\n    saveToInternal,\n  }: BaseModOptions & { action: Mod<T> }\n): ExportedConfig {\n  if (!config.mods) {\n    config.mods = {};\n  }\n  if (!config.mods[platform]) {\n    config.mods[platform] = {};\n  }\n\n  let interceptedMod: Mod<T> = (config.mods[platform] as Record<string, any>)[mod];\n\n  // No existing mod to intercept\n  if (!interceptedMod) {\n    if (skipEmptyMod) {\n      // Skip running the action\n      return config;\n    }\n    // Use a noop mod and continue\n    const noopMod: Mod<T> = config => config;\n    interceptedMod = noopMod;\n  }\n\n  // Create a stack trace for debugging ahead of time\n  let debugTrace: string = '';\n  // Use the possibly user defined value. Otherwise fallback to the env variable.\n  // We support the env variable because user mods won't have _internal defined in time.\n  const isDebug = config._internal?.isDebug ?? EXPO_DEBUG;\n  if (isDebug) {\n    // Get a stack trace via the Error API\n    const stack = new Error().stack;\n    // Format the stack trace to create the debug log\n    debugTrace = getDebugPluginStackFromStackTrace(stack);\n    const modStack = chalk.bold(`${platform}.${mod}`);\n\n    debugTrace = `${modStack}: ${debugTrace}`;\n  }\n\n  // Prevent adding multiple providers to a mod.\n  // Base mods that provide files ignore any incoming modResults and therefore shouldn't have provider mods as parents.\n  if (interceptedMod.isProvider) {\n    if (isProvider) {\n      throw new PluginError(\n        `Cannot set provider mod for \"${platform}.${mod}\" because another is already being used.`,\n        'CONFLICTING_PROVIDER'\n      );\n    } else {\n      throw new PluginError(\n        `Cannot add mod to \"${platform}.${mod}\" because the provider has already been added. Provider must be the last mod added.`,\n        'INVALID_MOD_ORDER'\n      );\n    }\n  }\n\n  async function interceptingMod({ modRequest, ...config }: ExportedConfigWithProps<T>) {\n    if (isDebug) {\n      // In debug mod, log the plugin stack in the order which they were invoked\n      console.log(debugTrace);\n    }\n    const results = await action({\n      ...config,\n      modRequest: { ...modRequest, nextMod: interceptedMod },\n    });\n\n    if (saveToInternal) {\n      saveToInternalObject(results, platform, mod, (results.modResults as unknown) as JSONObject);\n    }\n    return results;\n  }\n\n  // Ensure this base mod is registered as the provider.\n  interceptingMod.isProvider = isProvider;\n\n  if (isIntrospective) {\n    // Register the mode as idempotent so introspection doesn't remove it.\n    interceptingMod.isIntrospective = isIntrospective;\n  }\n\n  (config.mods[platform] as any)[mod] = interceptingMod;\n\n  return config;\n}\n\nfunction saveToInternalObject(\n  config: Pick<ExpoConfig, '_internal'>,\n  platformName: ModPlatform,\n  modName: string,\n  results: JSONObject\n) {\n  if (!config._internal) config._internal = {};\n  if (!config._internal.modResults) config._internal.modResults = {};\n  if (!config._internal.modResults[platformName]) config._internal.modResults[platformName] = {};\n  config._internal.modResults[platformName][modName] = results;\n}\n\nfunction getDebugPluginStackFromStackTrace(stacktrace?: string): string {\n  if (!stacktrace) {\n    return '';\n  }\n\n  const treeStackLines: string[] = [];\n  for (const line of stacktrace.split('\\n')) {\n    const [first, second] = line.trim().split(' ');\n    if (first === 'at') {\n      treeStackLines.push(second);\n    }\n  }\n\n  const plugins = treeStackLines\n    .map(first => {\n      // Match the first part of the stack trace against the plugin naming convention\n      // \"with\" followed by a capital letter.\n      return (\n        first?.match(/^(\\bwith[A-Z].*?\\b)/)?.[1]?.trim() ??\n        first?.match(/\\.(\\bwith[A-Z].*?\\b)/)?.[1]?.trim() ??\n        null\n      );\n    })\n    .filter(Boolean)\n    .filter(plugin => {\n      // redundant as all debug logs are captured in withBaseMod\n      return !['withMod', 'withBaseMod', 'withExtendedMod'].includes(plugin!);\n    });\n\n  const commonPlugins = ['withPlugins', 'withRunOnce', 'withStaticPlugin'];\n\n  return (\n    (plugins as string[])\n      .reverse()\n      .map((pluginName, index) => {\n        // Base mods indicate a logical section.\n        if (pluginName.includes('BaseMod')) {\n          pluginName = chalk.bold(pluginName);\n        }\n        // highlight dangerous mods\n        if (pluginName.toLowerCase().includes('dangerous')) {\n          pluginName = chalk.red(pluginName);\n        }\n\n        if (index === 0) {\n          return chalk.blue(pluginName);\n        } else if (commonPlugins.includes(pluginName)) {\n          // Common mod names often clutter up the logs, dim them out\n          return chalk.dim(pluginName);\n        }\n        return pluginName;\n      })\n      // Join the results:\n      // withAndroidExpoPlugins ➜ withPlugins ➜ withIcons ➜ withDangerousMod ➜ withMod\n      .join(' ➜ ')\n  );\n}\n\n/**\n * Plugin to extend a mod function in the plugins config.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to extend\n * @param action method to run on the mod when the config is compiled\n */\nexport function withMod<T>(\n  config: ExportedConfig,\n  {\n    platform,\n    mod,\n    action,\n  }: {\n    platform: ModPlatform;\n    mod: string;\n    action: Mod<T>;\n  }\n): ExportedConfig {\n  return withBaseMod(config, {\n    platform,\n    mod,\n    isProvider: false,\n    async action({ modRequest: { nextMod, ...modRequest }, modResults, ...config }) {\n      const results = await action({ modRequest, modResults: modResults as T, ...config });\n      return nextMod!(results as any);\n    },\n  });\n}\n"]},"metadata":{},"sourceType":"script"}