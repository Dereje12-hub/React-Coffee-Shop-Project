{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearUnusedCachesAsync = exports.cacheImageAsync = exports.getImageFromCacheAsync = exports.ensureCacheDirectory = exports.createCacheKeyWithDirectoryAsync = exports.createCacheKey = void 0;\n\nvar crypto_1 = __importDefault(require(\"crypto\"));\n\nvar fs_extra_1 = require(\"fs-extra\");\n\nvar path_1 = require(\"path\");\n\nvar CACHE_LOCATION = '.expo/web/cache/production/images';\nvar cacheKeys = {};\n\nfunction calculateHash(filePath) {\n  var contents = filePath.startsWith('http') ? filePath : fs_extra_1.readFileSync(filePath);\n  return crypto_1.default.createHash('sha256').update(contents).digest('hex');\n}\n\nfunction createCacheKey(fileSource, properties) {\n  var hash = calculateHash(fileSource);\n  return [hash].concat(properties).filter(Boolean).join('-');\n}\n\nexports.createCacheKey = createCacheKey;\n\nfunction createCacheKeyWithDirectoryAsync(projectRoot, type, icon) {\n  var cacheKey;\n  return _regeneratorRuntime.async(function createCacheKeyWithDirectoryAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          cacheKey = type + \"-\" + createCacheKey(icon.src, [icon.resizeMode, icon.backgroundColor]);\n\n          if (cacheKey in cacheKeys) {\n            _context.next = 5;\n            break;\n          }\n\n          _context.next = 4;\n          return _regeneratorRuntime.awrap(ensureCacheDirectory(projectRoot, type, cacheKey));\n\n        case 4:\n          cacheKeys[cacheKey] = _context.sent;\n\n        case 5:\n          return _context.abrupt(\"return\", cacheKey);\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.createCacheKeyWithDirectoryAsync = createCacheKeyWithDirectoryAsync;\n\nfunction ensureCacheDirectory(projectRoot, type, cacheKey) {\n  var cacheFolder;\n  return _regeneratorRuntime.async(function ensureCacheDirectory$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          cacheFolder = path_1.join(projectRoot, CACHE_LOCATION, type, cacheKey);\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(fs_extra_1.ensureDir(cacheFolder));\n\n        case 3:\n          return _context2.abrupt(\"return\", cacheFolder);\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.ensureCacheDirectory = ensureCacheDirectory;\n\nfunction getImageFromCacheAsync(fileName, cacheKey) {\n  return _regeneratorRuntime.async(function getImageFromCacheAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.prev = 0;\n          _context3.next = 3;\n          return _regeneratorRuntime.awrap(fs_extra_1.readFile(path_1.resolve(cacheKeys[cacheKey], fileName)));\n\n        case 3:\n          return _context3.abrupt(\"return\", _context3.sent);\n\n        case 6:\n          _context3.prev = 6;\n          _context3.t0 = _context3[\"catch\"](0);\n          return _context3.abrupt(\"return\", null);\n\n        case 9:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[0, 6]], Promise);\n}\n\nexports.getImageFromCacheAsync = getImageFromCacheAsync;\n\nfunction cacheImageAsync(fileName, buffer, cacheKey) {\n  var message;\n  return _regeneratorRuntime.async(function cacheImageAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.prev = 0;\n          _context4.next = 3;\n          return _regeneratorRuntime.awrap(fs_extra_1.writeFile(path_1.resolve(cacheKeys[cacheKey], fileName), buffer));\n\n        case 3:\n          _context4.next = 9;\n          break;\n\n        case 5:\n          _context4.prev = 5;\n          _context4.t0 = _context4[\"catch\"](0);\n          message = _context4.t0.message;\n          console.warn(\"Error caching image: \\\"\" + fileName + \"\\\". \" + message);\n\n        case 9:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[0, 5]], Promise);\n}\n\nexports.cacheImageAsync = cacheImageAsync;\n\nfunction clearUnusedCachesAsync(projectRoot, type) {\n  var cacheFolder, currentCaches, deleteCachePromises, _iterator, _step, cache;\n\n  return _regeneratorRuntime.async(function clearUnusedCachesAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          cacheFolder = path_1.join(projectRoot, CACHE_LOCATION, type);\n          _context5.next = 3;\n          return _regeneratorRuntime.awrap(fs_extra_1.ensureDir(cacheFolder));\n\n        case 3:\n          currentCaches = fs_extra_1.readdirSync(cacheFolder);\n\n          if (Array.isArray(currentCaches)) {\n            _context5.next = 7;\n            break;\n          }\n\n          console.warn('Failed to read the icon cache');\n          return _context5.abrupt(\"return\");\n\n        case 7:\n          deleteCachePromises = [];\n          _iterator = _createForOfIteratorHelperLoose(currentCaches);\n\n        case 9:\n          if ((_step = _iterator()).done) {\n            _context5.next = 16;\n            break;\n          }\n\n          cache = _step.value;\n\n          if (!cache.startsWith('.')) {\n            _context5.next = 13;\n            break;\n          }\n\n          return _context5.abrupt(\"continue\", 14);\n\n        case 13:\n          if (!(cache in cacheKeys)) {\n            deleteCachePromises.push(fs_extra_1.remove(path_1.join(cacheFolder, cache)));\n          }\n\n        case 14:\n          _context5.next = 9;\n          break;\n\n        case 16:\n          _context5.next = 18;\n          return _regeneratorRuntime.awrap(Promise.all(deleteCachePromises));\n\n        case 18:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.clearUnusedCachesAsync = clearUnusedCachesAsync;","map":{"version":3,"sources":["../src/Cache.ts"],"names":[],"mappings":"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","sourcesContent":["import crypto from 'crypto';\nimport { ensureDir, readdirSync, readFile, readFileSync, remove, writeFile } from 'fs-extra';\nimport { join, resolve } from 'path';\n\nimport { ImageOptions } from './Image.types';\n\nconst CACHE_LOCATION = '.expo/web/cache/production/images';\n\nconst cacheKeys: { [key: string]: string } = {};\n\n// Calculate SHA256 Checksum value of a file based on its contents\nfunction calculateHash(filePath: string): string {\n  const contents = filePath.startsWith('http') ? filePath : readFileSync(filePath);\n  return crypto.createHash('sha256').update(contents).digest('hex');\n}\n\n// Create a hash key for caching the images between builds\nexport function createCacheKey(fileSource: string, properties: string[]): string {\n  const hash = calculateHash(fileSource);\n  return [hash].concat(properties).filter(Boolean).join('-');\n}\n\nexport async function createCacheKeyWithDirectoryAsync(\n  projectRoot: string,\n  type: string,\n  icon: ImageOptions\n): Promise<string> {\n  const cacheKey = `${type}-${createCacheKey(icon.src, [icon.resizeMode, icon.backgroundColor])}`;\n  if (!(cacheKey in cacheKeys)) {\n    cacheKeys[cacheKey] = await ensureCacheDirectory(projectRoot, type, cacheKey);\n  }\n\n  return cacheKey;\n}\n\nexport async function ensureCacheDirectory(\n  projectRoot: string,\n  type: string,\n  cacheKey: string\n): Promise<string> {\n  const cacheFolder = join(projectRoot, CACHE_LOCATION, type, cacheKey);\n  await ensureDir(cacheFolder);\n  return cacheFolder;\n}\n\nexport async function getImageFromCacheAsync(\n  fileName: string,\n  cacheKey: string\n): Promise<null | Buffer> {\n  try {\n    return await readFile(resolve(cacheKeys[cacheKey], fileName));\n  } catch {\n    return null;\n  }\n}\n\nexport async function cacheImageAsync(\n  fileName: string,\n  buffer: Buffer,\n  cacheKey: string\n): Promise<void> {\n  try {\n    await writeFile(resolve(cacheKeys[cacheKey], fileName), buffer);\n  } catch ({ message }) {\n    console.warn(`Error caching image: \"${fileName}\". ${message}`);\n  }\n}\n\nexport async function clearUnusedCachesAsync(projectRoot: string, type: string): Promise<void> {\n  // Clean up any old caches\n  const cacheFolder = join(projectRoot, CACHE_LOCATION, type);\n  await ensureDir(cacheFolder);\n  const currentCaches = readdirSync(cacheFolder);\n\n  if (!Array.isArray(currentCaches)) {\n    console.warn('Failed to read the icon cache');\n    return;\n  }\n  const deleteCachePromises: Promise<void>[] = [];\n  for (const cache of currentCaches) {\n    // skip hidden folders\n    if (cache.startsWith('.')) {\n      continue;\n    }\n\n    // delete\n    if (!(cache in cacheKeys)) {\n      deleteCachePromises.push(remove(join(cacheFolder, cache)));\n    }\n  }\n\n  await Promise.all(deleteCachePromises);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}