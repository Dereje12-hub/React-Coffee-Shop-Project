{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withStaticPlugin = void 0;\n\nfunction _assert() {\n  var data = _interopRequireDefault(require(\"assert\"));\n\n  _assert = function _assert() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _getenv() {\n  var data = require(\"getenv\");\n\n  _getenv = function _getenv() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _errors() {\n  var data = require(\"../utils/errors\");\n\n  _errors = function _errors() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pluginResolver() {\n  var data = require(\"../utils/plugin-resolver\");\n\n  _pluginResolver = function _pluginResolver() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar EXPO_DEBUG = (0, _getenv().boolish)('EXPO_DEBUG', false);\nvar EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS = (0, _getenv().boolish)('EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS', false);\nvar EXPO_USE_UNVERSIONED_PLUGINS = (0, _getenv().boolish)('EXPO_USE_UNVERSIONED_PLUGINS', false);\n\nfunction isModuleMissingError(name, error) {\n  if (['MODULE_NOT_FOUND', 'PLUGIN_NOT_FOUND'].includes(error.code)) {\n    return true;\n  }\n\n  return error.message.includes(\"Cannot find module '\" + name + \"'\");\n}\n\nfunction isUnexpectedTokenError(error) {\n  if (error instanceof SyntaxError || error instanceof _errors().PluginError && error.code === 'INVALID_PLUGIN_IMPORT') {\n    return !!error.message.match(/Unexpected token/) || !!error.message.match(/Cannot use import statement/);\n  }\n\n  return false;\n}\n\nvar withStaticPlugin = function withStaticPlugin(config, props) {\n  var _pluginProps;\n\n  var projectRoot = props.projectRoot;\n\n  if (!projectRoot) {\n    var _config$_internal;\n\n    projectRoot = (_config$_internal = config._internal) === null || _config$_internal === void 0 ? void 0 : _config$_internal.projectRoot;\n    (0, _pluginResolver().assertInternalProjectRoot)(projectRoot);\n  }\n\n  var _ref = (0, _pluginResolver().normalizeStaticPlugin)(props.plugin),\n      _ref2 = _slicedToArray(_ref, 2),\n      pluginResolve = _ref2[0],\n      pluginProps = _ref2[1];\n\n  (0, _assert().default)(!((_pluginProps = pluginProps) !== null && _pluginProps !== void 0 && _pluginProps._resolverError), \"Plugin property '_resolverError' is a reserved property of `withStaticPlugin`\");\n  var withPlugin;\n\n  if (typeof pluginResolve === 'function') {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      withPlugin = (0, _pluginResolver().resolveConfigPluginFunction)(projectRoot, pluginResolve);\n\n      if (EXPO_USE_UNVERSIONED_PLUGINS && !!withPlugin && !!props._isLegacyPlugin && !!props.fallback) {\n        console.log(\"Force \\\"\" + pluginResolve + \"\\\" to unversioned plugin\");\n        withPlugin = props.fallback;\n      }\n    } catch (error) {\n      if (EXPO_DEBUG) {\n        if (EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS) {\n          console.log(\"Error resolving plugin \\\"\" + pluginResolve + \"\\\"\");\n          console.log(error);\n          console.log();\n        } else {\n          var shouldMuteWarning = props._isLegacyPlugin && (isModuleMissingError(pluginResolve, error) || isUnexpectedTokenError(error));\n\n          if (!shouldMuteWarning) {\n            if (isModuleMissingError(pluginResolve, error)) {\n              console.log(\"Could not find plugin \\\"\" + pluginResolve + \"\\\"\");\n            } else {\n              console.log(\"Error resolving plugin \\\"\" + pluginResolve + \"\\\"\");\n              console.log(error);\n              console.log();\n            }\n          }\n        }\n      }\n\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        throw error;\n      }\n    }\n  } else {\n    throw new (_errors().PluginError)(\"Plugin is an unexpected type: \" + typeof pluginResolve, 'INVALID_PLUGIN_TYPE');\n  }\n\n  config = withPlugin(config, pluginProps);\n  return config;\n};\n\nexports.withStaticPlugin = withStaticPlugin;","map":{"version":3,"sources":["../../src/plugins/withStaticPlugin.ts"],"names":["EXPO_DEBUG","EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS","EXPO_USE_UNVERSIONED_PLUGINS","error","PluginError","withStaticPlugin","projectRoot","props","config","pluginProps","withPlugin","console","shouldMuteWarning","isModuleMissingError","isUnexpectedTokenError"],"mappings":"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","sourcesContent":["import assert from 'assert';\nimport { boolish } from 'getenv';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { PluginError } from '../utils/errors';\nimport {\n  assertInternalProjectRoot,\n  normalizeStaticPlugin,\n  resolveConfigPluginFunction,\n} from '../utils/plugin-resolver';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\n\n// Show all error info related to plugin resolution.\nconst EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS = boolish('EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS', false);\n// Force using the fallback unversioned plugin instead of a local versioned copy,\n// this should only be used for testing the CLI.\nconst EXPO_USE_UNVERSIONED_PLUGINS = boolish('EXPO_USE_UNVERSIONED_PLUGINS', false);\n\nfunction isModuleMissingError(name: string, error: Error): boolean {\n  // @ts-ignore\n  if (['MODULE_NOT_FOUND', 'PLUGIN_NOT_FOUND'].includes(error.code)) {\n    return true;\n  }\n  return error.message.includes(`Cannot find module '${name}'`);\n}\n\nfunction isUnexpectedTokenError(error: Error): boolean {\n  if (\n    error instanceof SyntaxError ||\n    (error instanceof PluginError && error.code === 'INVALID_PLUGIN_IMPORT')\n  ) {\n    return (\n      // These are the most common errors that'll be thrown when a package isn't transpiled correctly.\n      !!error.message.match(/Unexpected token/) ||\n      !!error.message.match(/Cannot use import statement/)\n    );\n  }\n  return false;\n}\n\n/**\n * Resolves static module plugin and potentially falls back on a provided plugin if the module cannot be resolved\n *\n * @param config\n * @param fallback Plugin with `_resolverError` explaining why the module couldn't be used\n * @param projectRoot optional project root, fallback to _internal.projectRoot. Used for testing.\n * @param _isLegacyPlugin Used to suppress errors thrown by plugins that are applied automatically\n */\nexport const withStaticPlugin: ConfigPlugin<{\n  plugin: StaticPlugin | ConfigPlugin | string;\n  fallback?: ConfigPlugin<{ _resolverError: Error } & any>;\n  projectRoot?: string;\n  _isLegacyPlugin?: boolean;\n}> = (config, props) => {\n  let projectRoot = props.projectRoot;\n  if (!projectRoot) {\n    projectRoot = config._internal?.projectRoot;\n    assertInternalProjectRoot(projectRoot);\n  }\n\n  let [pluginResolve, pluginProps] = normalizeStaticPlugin(props.plugin);\n  // Ensure no one uses this property by accident.\n  assert(\n    !pluginProps?._resolverError,\n    `Plugin property '_resolverError' is a reserved property of \\`withStaticPlugin\\``\n  );\n\n  let withPlugin: ConfigPlugin<unknown>;\n\n  if (\n    // Function was provided, no need to resolve: [withPlugin, {}]\n    typeof pluginResolve === 'function'\n  ) {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      // Resolve and evaluate plugins.\n      withPlugin = resolveConfigPluginFunction(projectRoot, pluginResolve);\n\n      // Only force if the project has the versioned plugin, otherwise use default behavior.\n      // This helps see which plugins are being skipped.\n      if (\n        EXPO_USE_UNVERSIONED_PLUGINS &&\n        !!withPlugin &&\n        !!props._isLegacyPlugin &&\n        !!props.fallback\n      ) {\n        console.log(`Force \"${pluginResolve}\" to unversioned plugin`);\n        withPlugin = props.fallback;\n      }\n    } catch (error: any) {\n      if (EXPO_DEBUG) {\n        if (EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS) {\n          // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n          console.log(`Error resolving plugin \"${pluginResolve}\"`);\n          console.log(error);\n          console.log();\n        } else {\n          const shouldMuteWarning =\n            props._isLegacyPlugin &&\n            (isModuleMissingError(pluginResolve, error) || isUnexpectedTokenError(error));\n          if (!shouldMuteWarning) {\n            if (isModuleMissingError(pluginResolve, error)) {\n              // Prevent causing log spew for basic resolution errors.\n              console.log(`Could not find plugin \"${pluginResolve}\"`);\n            } else {\n              // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n              console.log(`Error resolving plugin \"${pluginResolve}\"`);\n              console.log(error);\n              console.log();\n            }\n          }\n        }\n      }\n      // TODO: Maybe allow for `PluginError`s to be thrown so external plugins can assert invalid options.\n\n      // If the static module failed to resolve, attempt to use a fallback.\n      // This enables support for built-in plugins with versioned variations living in other packages.\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        // Pass this to the fallback plugin for potential warnings about needing to install a versioned package.\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        // If no fallback, throw the resolution error.\n        throw error;\n      }\n    }\n  } else {\n    throw new PluginError(\n      `Plugin is an unexpected type: ${typeof pluginResolve}`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n\n  // Execute the plugin.\n  config = withPlugin(config, pluginProps);\n  return config;\n};\n"]},"metadata":{},"sourceType":"script"}