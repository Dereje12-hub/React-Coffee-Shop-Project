{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.queryAllInspectorAppsAsync = exports.queryInspectorAppAsync = exports.closeJsInspector = exports.openJsInspector = void 0;\n\nvar osascript = __importStar(require(\"@expo/osascript\"));\n\nvar child_process_1 = require(\"child_process\");\n\nvar glob_1 = require(\"glob\");\n\nvar node_fetch_1 = __importDefault(require(\"node-fetch\"));\n\nvar open_1 = __importDefault(require(\"open\"));\n\nvar os_1 = __importDefault(require(\"os\"));\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar openingChildProcess = null;\n\nfunction openJsInspector(app) {\n  var devtoolsFrontendRev = 'e3cd97fc771b893b7fd1879196d1215b622c2bed';\n  var urlBase = \"https://chrome-devtools-frontend.appspot.com/serve_rev/@\" + devtoolsFrontendRev + \"/inspector.html\";\n  var ws = app.webSocketDebuggerUrl.replace('ws://[::]:', 'localhost:');\n  var url = urlBase + \"?panel=sources&v8only=true&ws=\" + encodeURIComponent(ws);\n  launchChromiumAsync(url);\n}\n\nexports.openJsInspector = openJsInspector;\n\nfunction closeJsInspector() {\n  if (openingChildProcess != null) {\n    openingChildProcess.kill();\n    openingChildProcess = null;\n  }\n}\n\nexports.closeJsInspector = closeJsInspector;\n\nfunction queryInspectorAppAsync(metroServerOrigin, appId) {\n  var _a, apps;\n\n  return _regeneratorRuntime.async(function queryInspectorAppAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(queryAllInspectorAppsAsync(metroServerOrigin));\n\n        case 2:\n          apps = _context.sent;\n          return _context.abrupt(\"return\", (_a = apps.find(function (app) {\n            return app.description === appId;\n          })) !== null && _a !== void 0 ? _a : null);\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.queryInspectorAppAsync = queryInspectorAppAsync;\n\nfunction queryAllInspectorAppsAsync(metroServerOrigin) {\n  var resp, apps;\n  return _regeneratorRuntime.async(function queryAllInspectorAppsAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return _regeneratorRuntime.awrap(node_fetch_1.default(metroServerOrigin + \"/json/list\"));\n\n        case 2:\n          resp = _context2.sent;\n          _context2.t0 = transformApps;\n          _context2.next = 6;\n          return _regeneratorRuntime.awrap(resp.json());\n\n        case 6:\n          _context2.t1 = _context2.sent;\n          apps = (0, _context2.t0)(_context2.t1);\n          return _context2.abrupt(\"return\", apps.filter(function (app) {\n            return app.title === 'React Native Experimental (Improved Chrome Reloads)';\n          }));\n\n        case 9:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.queryAllInspectorAppsAsync = queryAllInspectorAppsAsync;\n\nfunction transformApps(apps) {\n  var deviceIdToAppId = {};\n\n  for (var _iterator = _createForOfIteratorHelperLoose(apps), _step; !(_step = _iterator()).done;) {\n    var app = _step.value;\n\n    if (app.description !== \"don't use\") {\n      var deviceId = app.id.split('-')[0];\n      var appId = app.description;\n      deviceIdToAppId[deviceId] = appId;\n    }\n  }\n\n  return apps.map(function (app) {\n    var _a;\n\n    if (app.description === \"don't use\") {\n      var deviceId = app.id.split('-')[0];\n      app.description = (_a = deviceIdToAppId[deviceId]) !== null && _a !== void 0 ? _a : app.description;\n    }\n\n    return app;\n  });\n}\n\nfunction launchChromiumAsync(url) {\n  var tmpDir, tempProfileDir, launchArgs, supportedChromiums, _i, _supportedChromiums, chromium;\n\n  return _regeneratorRuntime.async(function launchChromiumAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          tmpDir = require('temp-dir');\n          tempProfileDir = path_1.default.join(tmpDir, 'expo-inspector');\n          launchArgs = [\"--app=\" + url, '--allow-running-insecure-content', \"--user-data-dir=\" + tempProfileDir, '--no-first-run', '--no-startup-window', '--no-default-browser-check'];\n          supportedChromiums = [open_1.default.apps.chrome, open_1.default.apps.edge];\n          _i = 0, _supportedChromiums = supportedChromiums;\n\n        case 5:\n          if (!(_i < _supportedChromiums.length)) {\n            _context3.next = 18;\n            break;\n          }\n\n          chromium = _supportedChromiums[_i];\n          _context3.prev = 7;\n          _context3.next = 10;\n          return _regeneratorRuntime.awrap(launchAppAsync(chromium, launchArgs));\n\n        case 10:\n          return _context3.abrupt(\"return\");\n\n        case 13:\n          _context3.prev = 13;\n          _context3.t0 = _context3[\"catch\"](7);\n\n        case 15:\n          _i++;\n          _context3.next = 5;\n          break;\n\n        case 18:\n          throw new Error('Unable to find a browser on the host to open the inspector. Supported browsers: Google Chrome, Microsoft Edge');\n\n        case 19:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, [[7, 13]], Promise);\n}\n\nfunction launchAppAsync(appName, launchArgs) {\n  var _a, appDirectory, appPath, result;\n\n  return _regeneratorRuntime.async(function launchAppAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (!(os_1.default.platform() === 'darwin' && !Array.isArray(appName))) {\n            _context4.next = 10;\n            break;\n          }\n\n          _context4.next = 3;\n          return _regeneratorRuntime.awrap(osascript.execAsync(\"POSIX path of (path to application \\\"\" + appName + \"\\\")\"));\n\n        case 3:\n          appDirectory = _context4.sent;\n          appPath = (_a = glob_1.sync('Contents/MacOS/*', {\n            cwd: appDirectory.trim(),\n            absolute: true\n          })) === null || _a === void 0 ? void 0 : _a[0];\n\n          if (appPath) {\n            _context4.next = 7;\n            break;\n          }\n\n          throw new Error(\"Cannot find application path from \" + appDirectory + \"Contents/MacOS\");\n\n        case 7:\n          closeJsInspector();\n          openingChildProcess = child_process_1.spawn(appPath, launchArgs, {\n            stdio: 'ignore'\n          });\n          return _context4.abrupt(\"return\");\n\n        case 10:\n          _context4.next = 12;\n          return _regeneratorRuntime.awrap(open_1.default.openApp(appName, {\n            arguments: launchArgs,\n            newInstance: true,\n            wait: true\n          }));\n\n        case 12:\n          result = _context4.sent;\n\n          if (!(result.exitCode !== 0)) {\n            _context4.next = 15;\n            break;\n          }\n\n          throw new Error(\"Cannot find application: \" + appName);\n\n        case 15:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["../src/JsInspector.ts"],"names":[],"mappings":"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","sourcesContent":["import * as osascript from '@expo/osascript';\nimport { ChildProcess, spawn } from 'child_process';\nimport { sync as globSync } from 'glob';\nimport fetch from 'node-fetch';\nimport open from 'open';\nimport os from 'os';\nimport path from 'path';\n\nexport interface MetroInspectorProxyApp {\n  description: string;\n  devtoolsFrontendUrl: string;\n  faviconUrl: string;\n  id: string;\n  title: string;\n  type: 'node';\n  vm: 'Hermes' | \"don't use\";\n  webSocketDebuggerUrl: string;\n}\n\nlet openingChildProcess: ChildProcess | null = null;\n\nexport function openJsInspector(app: MetroInspectorProxyApp) {\n  // To update devtoolsFrontendRev, find the full commit hash in the url:\n  // https://chromium.googlesource.com/chromium/src.git/+log/refs/tags/{CHROME_VERSION}/chrome/VERSION\n  //\n  // 1. Replace {CHROME_VERSION} with the target chrome version\n  // 2. Click the first log item in the webpage\n  // 3. The full commit hash is the desired revision\n  const devtoolsFrontendRev = 'e3cd97fc771b893b7fd1879196d1215b622c2bed'; // Chrome 90.0.4430.212\n\n  const urlBase = `https://chrome-devtools-frontend.appspot.com/serve_rev/@${devtoolsFrontendRev}/inspector.html`;\n  const ws = app.webSocketDebuggerUrl.replace('ws://[::]:', 'localhost:');\n  const url = `${urlBase}?panel=sources&v8only=true&ws=${encodeURIComponent(ws)}`;\n  launchChromiumAsync(url);\n}\n\nexport function closeJsInspector() {\n  if (openingChildProcess != null) {\n    openingChildProcess.kill();\n    openingChildProcess = null;\n  }\n}\n\nexport async function queryInspectorAppAsync(\n  metroServerOrigin: string,\n  appId: string\n): Promise<MetroInspectorProxyApp | null> {\n  const apps = await queryAllInspectorAppsAsync(metroServerOrigin);\n  return apps.find(app => app.description === appId) ?? null;\n}\n\nexport async function queryAllInspectorAppsAsync(\n  metroServerOrigin: string\n): Promise<MetroInspectorProxyApp[]> {\n  const resp = await fetch(`${metroServerOrigin}/json/list`);\n  const apps: MetroInspectorProxyApp[] = transformApps(await resp.json());\n  // Only use targets with better reloading support\n  return apps.filter(app => app.title === 'React Native Experimental (Improved Chrome Reloads)');\n}\n\n// The description of `React Native Experimental (Improved Chrome Reloads)` target is `don't use` from metro.\n// This function tries to transform the unmeaningful description to appId\nfunction transformApps(apps: MetroInspectorProxyApp[]): MetroInspectorProxyApp[] {\n  const deviceIdToAppId: Record<string, string> = {};\n\n  for (const app of apps) {\n    if (app.description !== \"don't use\") {\n      const deviceId = app.id.split('-')[0];\n      const appId = app.description;\n      deviceIdToAppId[deviceId] = appId;\n    }\n  }\n\n  return apps.map(app => {\n    if (app.description === \"don't use\") {\n      const deviceId = app.id.split('-')[0];\n      app.description = deviceIdToAppId[deviceId] ?? app.description;\n    }\n    return app;\n  });\n}\n\nasync function launchChromiumAsync(url: string): Promise<void> {\n  // For dev-client connecting metro in LAN, the request to fetch sourcemaps may be blocked by Chromium\n  // with insecure-content (https page send xhr for http resource).\n  // Adding `--allow-running-insecure-content` to overcome this limitation\n  // without users manually allow insecure-content in site settings.\n  // However, if there is existing chromium browser process, the argument will not take effect.\n  // We also pass a `--user-data-dir=` as temporary profile and force chromium to create new browser process.\n  const tmpDir = require('temp-dir');\n  const tempProfileDir = path.join(tmpDir, 'expo-inspector');\n  const launchArgs = [\n    `--app=${url}`,\n    '--allow-running-insecure-content',\n    `--user-data-dir=${tempProfileDir}`,\n    '--no-first-run',\n    '--no-startup-window',\n    '--no-default-browser-check',\n  ];\n\n  const supportedChromiums = [open.apps.chrome, open.apps.edge];\n  for (const chromium of supportedChromiums) {\n    try {\n      await launchAppAsync(chromium, launchArgs);\n      return;\n    } catch {}\n  }\n\n  throw new Error(\n    'Unable to find a browser on the host to open the inspector. Supported browsers: Google Chrome, Microsoft Edge'\n  );\n}\n\nasync function launchAppAsync(\n  appName: string | readonly string[],\n  launchArgs: string[]\n): Promise<void> {\n  if (os.platform() === 'darwin' && !Array.isArray(appName)) {\n    const appDirectory = await osascript.execAsync(\n      `POSIX path of (path to application \"${appName}\")`\n    );\n    const appPath = globSync('Contents/MacOS/*', { cwd: appDirectory.trim(), absolute: true })?.[0];\n    if (!appPath) {\n      throw new Error(`Cannot find application path from ${appDirectory}Contents/MacOS`);\n    }\n    closeJsInspector();\n    openingChildProcess = spawn(appPath, launchArgs, { stdio: 'ignore' });\n    return;\n  }\n\n  const result = await open.openApp(appName, {\n    arguments: launchArgs,\n    newInstance: true,\n    wait: true,\n  });\n  if (result.exitCode !== 0) {\n    throw new Error(`Cannot find application: ${appName}`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}