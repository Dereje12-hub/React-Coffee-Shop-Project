{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = void 0;\n\nvar xmldom_1 = require(\"@xmldom/xmldom\");\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar TEXT_NODE = 3;\nvar CDATA_NODE = 4;\nvar COMMENT_NODE = 8;\n\nfunction shouldIgnoreNode(node) {\n  return node.nodeType === TEXT_NODE || node.nodeType === COMMENT_NODE || node.nodeType === CDATA_NODE;\n}\n\nfunction isEmptyNode(node) {\n  return !node.childNodes || node.childNodes.length === 0;\n}\n\nfunction parse(xml) {\n  var doc = new xmldom_1.DOMParser({\n    errorHandler: function errorHandler() {}\n  }).parseFromString(xml);\n  assert_1.default(doc.documentElement.nodeName === 'plist', 'malformed document. First element should be <plist>');\n  var plist = parsePlistXML(doc.documentElement);\n  if (plist.length == 1) plist = plist[0];\n  return plist;\n}\n\nexports.parse = parse;\n\nfunction parsePlistXML(node) {\n  var i, new_obj, key, new_arr, res, counter;\n  if (!node) return null;\n\n  if (node.nodeName === 'plist') {\n    new_arr = [];\n\n    if (isEmptyNode(node)) {\n      return new_arr;\n    }\n\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (!shouldIgnoreNode(node.childNodes[i])) {\n        new_arr.push(parsePlistXML(node.childNodes[i]));\n      }\n    }\n\n    return new_arr;\n  } else if (node.nodeName === 'dict') {\n    new_obj = {};\n    key = null;\n    counter = 0;\n\n    if (isEmptyNode(node)) {\n      return new_obj;\n    }\n\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (shouldIgnoreNode(node.childNodes[i])) continue;\n\n      if (counter % 2 === 0) {\n        assert_1.default(node.childNodes[i].nodeName === 'key', 'Missing key while parsing <dict/>.');\n        key = parsePlistXML(node.childNodes[i]);\n      } else {\n        assert_1.default(node.childNodes[i].nodeName !== 'key', 'Unexpected key \"' + parsePlistXML(node.childNodes[i]) + '\" while parsing <dict/>.');\n        new_obj[key] = parsePlistXML(node.childNodes[i]);\n      }\n\n      counter += 1;\n    }\n\n    if (counter % 2 === 1) {\n      throw new Error('Missing value for \"' + key + '\" while parsing <dict/>');\n    }\n\n    return new_obj;\n  } else if (node.nodeName === 'array') {\n    new_arr = [];\n\n    if (isEmptyNode(node)) {\n      return new_arr;\n    }\n\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (!shouldIgnoreNode(node.childNodes[i])) {\n        res = parsePlistXML(node.childNodes[i]);\n        if (res != null) new_arr.push(res);\n      }\n    }\n\n    return new_arr;\n  } else if (node.nodeName === '#text') {} else if (node.nodeName === 'key') {\n    if (isEmptyNode(node)) {\n      return '';\n    }\n\n    return node.childNodes[0].nodeValue;\n  } else if (node.nodeName === 'string') {\n    res = '';\n\n    if (isEmptyNode(node)) {\n      return res;\n    }\n\n    for (i = 0; i < node.childNodes.length; i++) {\n      var type = node.childNodes[i].nodeType;\n\n      if (type === TEXT_NODE || type === CDATA_NODE) {\n        res += node.childNodes[i].nodeValue;\n      }\n    }\n\n    return res;\n  } else if (node.nodeName === 'integer') {\n    assert_1.default(!isEmptyNode(node), 'Cannot parse \"\" as integer.');\n    return parseInt(node.childNodes[0].nodeValue, 10);\n  } else if (node.nodeName === 'real') {\n    assert_1.default(!isEmptyNode(node), 'Cannot parse \"\" as real.');\n    res = '';\n\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (node.childNodes[i].nodeType === TEXT_NODE) {\n        res += node.childNodes[i].nodeValue;\n      }\n    }\n\n    return parseFloat(res);\n  } else if (node.nodeName === 'data') {\n    res = '';\n\n    if (isEmptyNode(node)) {\n      return Buffer.from(res, 'base64');\n    }\n\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (node.childNodes[i].nodeType === TEXT_NODE) {\n        res += node.childNodes[i].nodeValue.replace(/\\s+/g, '');\n      }\n    }\n\n    return Buffer.from(res, 'base64');\n  } else if (node.nodeName === 'date') {\n    assert_1.default(!isEmptyNode(node), 'Cannot parse \"\" as Date.');\n    return new Date(node.childNodes[0].nodeValue);\n  } else if (node.nodeName === 'true') {\n    return true;\n  } else if (node.nodeName === 'false') {\n    return false;\n  }\n}","map":{"version":3,"sources":["../src/parse.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable */\n/* (The MIT License)\n\nCopyright (c) 2010-2017 Nathan Rajlich <nathan@tootallnate.net>\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE. */\n\nimport { DOMParser } from '@xmldom/xmldom';\nimport assert from 'assert';\n\nconst TEXT_NODE = 3;\nconst CDATA_NODE = 4;\nconst COMMENT_NODE = 8;\n\n/**\n * We ignore raw text (usually whitespace), <!-- xml comments -->,\n * and raw CDATA nodes.\n *\n * @param {Element} node\n * @returns {Boolean}\n * @api private\n */\n\nfunction shouldIgnoreNode(node: { [key: string]: any }): boolean {\n  return (\n    node.nodeType === TEXT_NODE || node.nodeType === COMMENT_NODE || node.nodeType === CDATA_NODE\n  );\n}\n\n/**\n * Check if the node is empty. Some plist file has such node:\n * <key />\n * this node shoud be ignored.\n *\n * @see https://github.com/TooTallNate/plist.js/issues/66\n * @param {Element} node\n * @returns {Boolean}\n * @api private\n */\nfunction isEmptyNode(node: { [key: string]: any }): boolean {\n  return !node.childNodes || node.childNodes.length === 0;\n}\n\n/**\n * Parses a Plist XML string. Returns an Object.\n *\n * @param {String} xml - the XML String to decode\n * @returns {Mixed} the decoded value from the Plist XML\n * @api public\n */\n\nexport function parse(xml: string): any {\n  // prevent the parser from logging non-fatel errors\n  const doc = new DOMParser({ errorHandler() {} }).parseFromString(xml);\n  assert(\n    doc.documentElement.nodeName === 'plist',\n    'malformed document. First element should be <plist>'\n  );\n  let plist = parsePlistXML(doc.documentElement);\n\n  // the root <plist> node gets interpreted as an Array,\n  // so pull out the inner data first\n  if (plist.length == 1) plist = plist[0];\n\n  return plist;\n}\n\n/**\n * Convert an XML based plist document into a JSON representation.\n *\n * @param {Object} xml_node - current XML node in the plist\n * @returns {Mixed} built up JSON object\n * @api private\n */\n\nfunction parsePlistXML(node: { [key: string]: any }): any {\n  let i, new_obj: { [key: string]: any }, key, new_arr: any[], res, counter;\n\n  if (!node) return null;\n\n  if (node.nodeName === 'plist') {\n    new_arr = [];\n    if (isEmptyNode(node)) {\n      return new_arr;\n    }\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (!shouldIgnoreNode(node.childNodes[i])) {\n        new_arr.push(parsePlistXML(node.childNodes[i]));\n      }\n    }\n    return new_arr;\n  } else if (node.nodeName === 'dict') {\n    new_obj = {};\n    key = null;\n    counter = 0;\n    if (isEmptyNode(node)) {\n      return new_obj;\n    }\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (shouldIgnoreNode(node.childNodes[i])) continue;\n      if (counter % 2 === 0) {\n        assert(node.childNodes[i].nodeName === 'key', 'Missing key while parsing <dict/>.');\n        key = parsePlistXML(node.childNodes[i]);\n      } else {\n        assert(\n          node.childNodes[i].nodeName !== 'key',\n          'Unexpected key \"' + parsePlistXML(node.childNodes[i]) + '\" while parsing <dict/>.'\n        );\n        new_obj[key] = parsePlistXML(node.childNodes[i]);\n      }\n      counter += 1;\n    }\n    if (counter % 2 === 1) {\n      throw new Error('Missing value for \"' + key + '\" while parsing <dict/>');\n    }\n    return new_obj;\n  } else if (node.nodeName === 'array') {\n    new_arr = [];\n    if (isEmptyNode(node)) {\n      return new_arr;\n    }\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (!shouldIgnoreNode(node.childNodes[i])) {\n        res = parsePlistXML(node.childNodes[i]);\n        if (res != null) new_arr.push(res);\n      }\n    }\n    return new_arr;\n  } else if (node.nodeName === '#text') {\n    // TODO: what should we do with text types? (CDATA sections)\n  } else if (node.nodeName === 'key') {\n    if (isEmptyNode(node)) {\n      return '';\n    }\n    return node.childNodes[0].nodeValue;\n  } else if (node.nodeName === 'string') {\n    res = '';\n    if (isEmptyNode(node)) {\n      return res;\n    }\n    for (i = 0; i < node.childNodes.length; i++) {\n      const type = node.childNodes[i].nodeType;\n      if (type === TEXT_NODE || type === CDATA_NODE) {\n        res += node.childNodes[i].nodeValue;\n      }\n    }\n    return res;\n  } else if (node.nodeName === 'integer') {\n    assert(!isEmptyNode(node), 'Cannot parse \"\" as integer.');\n    return parseInt(node.childNodes[0].nodeValue, 10);\n  } else if (node.nodeName === 'real') {\n    assert(!isEmptyNode(node), 'Cannot parse \"\" as real.');\n    res = '';\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (node.childNodes[i].nodeType === TEXT_NODE) {\n        res += node.childNodes[i].nodeValue;\n      }\n    }\n    return parseFloat(res);\n  } else if (node.nodeName === 'data') {\n    res = '';\n    if (isEmptyNode(node)) {\n      return Buffer.from(res, 'base64');\n    }\n    for (i = 0; i < node.childNodes.length; i++) {\n      if (node.childNodes[i].nodeType === TEXT_NODE) {\n        res += node.childNodes[i].nodeValue.replace(/\\s+/g, '');\n      }\n    }\n    return Buffer.from(res, 'base64');\n  } else if (node.nodeName === 'date') {\n    assert(!isEmptyNode(node), 'Cannot parse \"\" as Date.');\n    return new Date(node.childNodes[0].nodeValue);\n  } else if (node.nodeName === 'true') {\n    return true;\n  } else if (node.nodeName === 'false') {\n    return false;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}