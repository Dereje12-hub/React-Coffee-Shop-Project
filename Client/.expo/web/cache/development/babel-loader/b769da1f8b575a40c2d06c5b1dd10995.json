{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.downloadImage = exports.downloadOrUseCachedImage = void 0;\n\nvar fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nvar jimp_compact_1 = __importDefault(require(\"jimp-compact\"));\n\nvar node_fetch_1 = __importDefault(require(\"node-fetch\"));\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar stream_1 = __importDefault(require(\"stream\"));\n\nvar tempy_1 = __importDefault(require(\"tempy\"));\n\nvar util_1 = __importDefault(require(\"util\"));\n\nvar cacheDownloadedKeys = {};\n\nfunction stripQueryParams(url) {\n  return url.split('?')[0].split('#')[0];\n}\n\nfunction downloadOrUseCachedImage(url) {\n  return _regeneratorRuntime.async(function downloadOrUseCachedImage$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!(url in cacheDownloadedKeys)) {\n            _context.next = 2;\n            break;\n          }\n\n          return _context.abrupt(\"return\", cacheDownloadedKeys[url]);\n\n        case 2:\n          if (!url.startsWith('http')) {\n            _context.next = 8;\n            break;\n          }\n\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(downloadImage(url));\n\n        case 5:\n          cacheDownloadedKeys[url] = _context.sent;\n          _context.next = 9;\n          break;\n\n        case 8:\n          cacheDownloadedKeys[url] = url;\n\n        case 9:\n          return _context.abrupt(\"return\", cacheDownloadedKeys[url]);\n\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.downloadOrUseCachedImage = downloadOrUseCachedImage;\n\nfunction downloadImage(url) {\n  var outputPath, response, streamPipeline, localPath, img, mime, newPath;\n  return _regeneratorRuntime.async(function downloadImage$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          outputPath = tempy_1.default.directory();\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(node_fetch_1.default(url));\n\n        case 3:\n          response = _context2.sent;\n\n          if (response.ok) {\n            _context2.next = 6;\n            break;\n          }\n\n          throw new Error(\"It was not possible to download image from '\" + url + \"'\");\n\n        case 6:\n          streamPipeline = util_1.default.promisify(stream_1.default.pipeline);\n          localPath = path_1.default.join(outputPath, path_1.default.basename(stripQueryParams(url)));\n          _context2.next = 10;\n          return _regeneratorRuntime.awrap(streamPipeline(response.body, fs_extra_1.default.createWriteStream(localPath)));\n\n        case 10:\n          _context2.next = 12;\n          return _regeneratorRuntime.awrap(jimp_compact_1.default.read(localPath));\n\n        case 12:\n          img = _context2.sent;\n          mime = img.getMIME().split('/').pop();\n\n          if (localPath.endsWith(mime)) {\n            _context2.next = 19;\n            break;\n          }\n\n          newPath = path_1.default.join(outputPath, \"image.\" + mime);\n          _context2.next = 18;\n          return _regeneratorRuntime.awrap(fs_extra_1.default.move(localPath, newPath));\n\n        case 18:\n          return _context2.abrupt(\"return\", newPath);\n\n        case 19:\n          return _context2.abrupt(\"return\", localPath);\n\n        case 20:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.downloadImage = downloadImage;","map":{"version":3,"sources":["../src/Download.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\n// @ts-ignore\nimport Jimp from 'jimp-compact';\nimport fetch from 'node-fetch';\nimport path from 'path';\nimport stream from 'stream';\nimport temporary from 'tempy';\nimport util from 'util';\n\n// cache downloaded images into memory\nconst cacheDownloadedKeys: Record<string, string> = {};\n\nfunction stripQueryParams(url: string): string {\n  return url.split('?')[0].split('#')[0];\n}\n\nexport async function downloadOrUseCachedImage(url: string): Promise<string> {\n  if (url in cacheDownloadedKeys) {\n    return cacheDownloadedKeys[url];\n  }\n  if (url.startsWith('http')) {\n    cacheDownloadedKeys[url] = await downloadImage(url);\n  } else {\n    cacheDownloadedKeys[url] = url;\n  }\n  return cacheDownloadedKeys[url];\n}\n\nexport async function downloadImage(url: string): Promise<string> {\n  const outputPath = temporary.directory();\n\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`It was not possible to download image from '${url}'`);\n  }\n\n  // Download to local file\n  const streamPipeline = util.promisify(stream.pipeline);\n  const localPath = path.join(outputPath, path.basename(stripQueryParams(url)));\n  await streamPipeline(response.body, fs.createWriteStream(localPath));\n\n  // If an image URL doesn't have a name, get the mime type and move the file.\n  const img = await Jimp.read(localPath);\n  const mime = img.getMIME().split('/').pop()!;\n  if (!localPath.endsWith(mime)) {\n    const newPath = path.join(outputPath, `image.${mime}`);\n    await fs.move(localPath, newPath);\n    return newPath;\n  }\n\n  return localPath;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}