{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bunyan_1 = __importDefault(require(\"@expo/bunyan\"));\n\nvar loosely_validate_event_1 = __importDefault(require(\"@segment/loosely-validate-event\"));\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar fetch_retry_1 = __importDefault(require(\"fetch-retry\"));\n\nvar md5_1 = __importDefault(require(\"md5\"));\n\nvar node_fetch_1 = __importDefault(require(\"node-fetch\"));\n\nvar remove_trailing_slash_1 = __importDefault(require(\"remove-trailing-slash\"));\n\nvar uuid_1 = require(\"uuid\");\n\nvar version = require(\"./package.json\").version;\n\nvar retryableFetch = (0, fetch_retry_1.default)(node_fetch_1.default);\nvar setImmediate = global.setImmediate || process.nextTick.bind(process);\n\nvar Analytics = function () {\n  function Analytics(writeKey, dataPlaneURL) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref$enable = _ref.enable,\n        enable = _ref$enable === void 0 ? true : _ref$enable,\n        _ref$timeout = _ref.timeout,\n        timeout = _ref$timeout === void 0 ? 0 : _ref$timeout,\n        _ref$flushAt = _ref.flushAt,\n        flushAt = _ref$flushAt === void 0 ? 20 : _ref$flushAt,\n        _ref$flushInterval = _ref.flushInterval,\n        flushInterval = _ref$flushInterval === void 0 ? 20000 : _ref$flushInterval,\n        _ref$maxFlushSizeInBy = _ref.maxFlushSizeInBytes,\n        maxFlushSizeInBytes = _ref$maxFlushSizeInBy === void 0 ? 1024 * 1000 * 3.9 : _ref$maxFlushSizeInBy,\n        _ref$maxQueueLength = _ref.maxQueueLength,\n        maxQueueLength = _ref$maxQueueLength === void 0 ? 1000 : _ref$maxQueueLength,\n        _ref$logLevel = _ref.logLevel,\n        logLevel = _ref$logLevel === void 0 ? bunyan_1.default.FATAL : _ref$logLevel;\n\n    _classCallCheck(this, Analytics);\n\n    this.inFlightFlush = null;\n    this.queue = [];\n    this.flushCallbacks = [];\n    this.flushResponses = [];\n    this.finalMessageId = null;\n    this.flushed = false;\n    this.timer = null;\n    this.enable = enable;\n    (0, assert_1.default)(writeKey, \"The project's write key must be specified\");\n    (0, assert_1.default)(dataPlaneURL, \"The data plane URL must be specified\");\n    this.writeKey = writeKey;\n    this.host = (0, remove_trailing_slash_1.default)(dataPlaneURL);\n    this.timeout = timeout;\n    this.flushAt = Math.max(flushAt, 1);\n    this.flushInterval = flushInterval;\n    this.maxFlushSizeInBytes = maxFlushSizeInBytes;\n    this.maxQueueLength = maxQueueLength;\n    this.logger = bunyan_1.default.createLogger({\n      name: '@expo/rudder-node-sdk',\n      level: logLevel\n    });\n  }\n\n  _createClass(Analytics, [{\n    key: \"identify\",\n    value: function identify(message, callback) {\n      this.validate(message, 'identify');\n      this.enqueue('identify', message, callback);\n      return this;\n    }\n  }, {\n    key: \"group\",\n    value: function group(message, callback) {\n      this.validate(message, 'group');\n      this.enqueue('group', message, callback);\n      return this;\n    }\n  }, {\n    key: \"track\",\n    value: function track(message, callback) {\n      this.validate(message, 'track');\n      this.enqueue('track', message, callback);\n      return this;\n    }\n  }, {\n    key: \"page\",\n    value: function page(message, callback) {\n      this.validate(message, 'page');\n      this.enqueue('page', message, callback);\n      return this;\n    }\n  }, {\n    key: \"screen\",\n    value: function screen(message, callback) {\n      this.validate(message, 'screen');\n      this.enqueue('screen', message, callback);\n      return this;\n    }\n  }, {\n    key: \"alias\",\n    value: function alias(message, callback) {\n      this.validate(message, 'alias');\n      this.enqueue('alias', message, callback);\n      return this;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(message, type) {\n      try {\n        (0, loosely_validate_event_1.default)(message, type);\n      } catch (e) {\n        if (e.message === 'Your message must be < 32kb.') {\n          this.logger.warn('Your message must be < 32KiB. This is currently surfaced as a warning. Please update your code.', message);\n          return;\n        }\n\n        throw e;\n      }\n    }\n  }, {\n    key: \"enqueue\",\n    value: function enqueue(type, message) {\n      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\n      var _a, _b;\n\n      if (!this.enable) {\n        setImmediate(callback);\n        return;\n      }\n\n      if (this.queue.length >= this.maxQueueLength) {\n        this.logger.error(\"Not adding events for processing as queue size \" + this.queue.length + \" exceeds max configuration \" + this.maxQueueLength);\n        setImmediate(callback);\n        return;\n      }\n\n      if (type === 'identify') {\n        (_a = message.traits) !== null && _a !== void 0 ? _a : message.traits = {};\n        (_b = message.context) !== null && _b !== void 0 ? _b : message.context = {};\n        message.context.traits = message.traits;\n      }\n\n      message = _objectSpread({}, message);\n      message.type = type;\n      message.context = _objectSpread({\n        library: {\n          name: '@expo/rudder-sdk-node',\n          version: version\n        }\n      }, message.context);\n      message._metadata = _objectSpread({\n        nodeVersion: process.versions.node\n      }, message._metadata);\n\n      if (!message.originalTimestamp) {\n        message.originalTimestamp = new Date();\n      }\n\n      if (!message.messageId) {\n        message.messageId = \"node-\" + (0, md5_1.default)(JSON.stringify(message)) + \"-\" + (0, uuid_1.v4)();\n      }\n\n      this.queue.push({\n        message: message,\n        callback: callback\n      });\n\n      if (!this.flushed) {\n        this.flushed = true;\n        this.flush();\n        return;\n      }\n\n      var isDivisibleByFlushAt = this.queue.length % this.flushAt === 0;\n\n      if (isDivisibleByFlushAt) {\n        this.logger.debug(\"flushAt reached, messageQueueLength is \" + this.queue.length + \", trying flush...\");\n        this.flush();\n      } else if (this.flushInterval && !this.timer) {\n        this.logger.debug('no existing flush timer, creating new one');\n        this.timer = setTimeout(this.flush.bind(this), this.flushInterval);\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var callback,\n          _args = arguments;\n      return _regeneratorRuntime.async(function flush$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              callback = _args.length > 0 && _args[0] !== undefined ? _args[0] : function () {};\n              this.finalMessageId = this.queue.length ? this.queue[this.queue.length - 1].message.messageId : null;\n              this.flushCallbacks.push(callback);\n\n              if (!this.inFlightFlush) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 6;\n              return _regeneratorRuntime.awrap(this.inFlightFlush);\n\n            case 6:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 7:\n              this.inFlightFlush = this.executeFlush();\n              _context.next = 10;\n              return _regeneratorRuntime.awrap(this.inFlightFlush);\n\n            case 10:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"executeFlush\",\n    value: function executeFlush() {\n      var _this = this;\n\n      var flushedItems,\n          _a,\n          nullResponse,\n          _nullResponse,\n          flushSize,\n          spliceIndex,\n          i,\n          item,\n          itemSize,\n          exceededMaxFlushSize,\n          itemsToFlush,\n          callbacks,\n          currentBatchOfMessages,\n          done,\n          data,\n          req,\n          error,\n          response,\n          finishedFlushing,\n          _args2 = arguments;\n\n      return _regeneratorRuntime.async(function executeFlush$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              flushedItems = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : [];\n              this.logger.debug('in flush');\n\n              if (this.enable) {\n                _context2.next = 9;\n                break;\n              }\n\n              this.inFlightFlush = null;\n              this.finalMessageId = null;\n              this.flushResponses.splice(0, this.flushResponses.length);\n              nullResponse = this.nullFlushResponse();\n              this.flushCallbacks.splice(0, this.flushCallbacks.length).map(function (callback) {\n                return setImmediate(callback, nullResponse);\n              });\n              return _context2.abrupt(\"return\", nullResponse);\n\n            case 9:\n              if (this.timer) {\n                this.logger.debug('cancelling existing timer...');\n                clearTimeout(this.timer);\n                this.timer = null;\n              }\n\n              if (this.queue.length) {\n                _context2.next = 18;\n                break;\n              }\n\n              this.logger.debug('queue is empty, nothing to flush');\n              this.inFlightFlush = null;\n              this.finalMessageId = null;\n              this.flushResponses.splice(0, this.flushResponses.length);\n              _nullResponse = this.nullFlushResponse();\n              this.flushCallbacks.splice(0, this.flushCallbacks.length).map(function (callback) {\n                return setImmediate(callback, _nullResponse);\n              });\n              return _context2.abrupt(\"return\", _nullResponse);\n\n            case 18:\n              flushSize = 0;\n              spliceIndex = 0;\n              i = 0;\n\n            case 21:\n              if (!(i < this.queue.length)) {\n                _context2.next = 34;\n                break;\n              }\n\n              item = this.queue[i];\n              itemSize = JSON.stringify(item).length;\n              exceededMaxFlushSize = flushSize + itemSize > this.maxFlushSizeInBytes;\n\n              if (!exceededMaxFlushSize) {\n                _context2.next = 27;\n                break;\n              }\n\n              return _context2.abrupt(\"break\", 34);\n\n            case 27:\n              flushSize += itemSize;\n              spliceIndex++;\n\n              if (!(((_a = item.message.messageId) !== null && _a !== void 0 ? _a : null) === this.finalMessageId)) {\n                _context2.next = 31;\n                break;\n              }\n\n              return _context2.abrupt(\"break\", 34);\n\n            case 31:\n              i++;\n              _context2.next = 21;\n              break;\n\n            case 34:\n              itemsToFlush = this.queue.splice(0, spliceIndex);\n              callbacks = itemsToFlush.map(function (item) {\n                return item.callback;\n              });\n              currentBatchOfMessages = itemsToFlush.map(function (item) {\n                if (typeof item.message == 'object') {\n                  item.message.sentAt = new Date();\n                }\n\n                return item.message;\n              });\n\n              done = function done(err) {\n                callbacks.forEach(function (callback_) {\n                  callback_(err);\n                });\n\n                var flushResponses = _this.flushResponses.slice(0, _this.flushResponses.length);\n\n                _this.flushCallbacks.splice(0, _this.flushCallbacks.length).map(function (callback) {\n                  return setImmediate(callback, flushResponses);\n                });\n\n                _this.inFlightFlush = null;\n                _this.finalMessageId = null;\n              };\n\n              data = {\n                batch: currentBatchOfMessages,\n                sentAt: new Date()\n              };\n              this.logger.debug('batch size is ' + itemsToFlush.length);\n              this.logger.trace('===data===', data);\n              req = {\n                method: 'POST',\n                headers: {\n                  accept: 'application/json, text/plain, */*',\n                  'content-type': 'application/json;charset=utf-8',\n                  'user-agent': \"expo-rudder-sdk-node/\" + version,\n                  authorization: 'Basic ' + Buffer.from(this.writeKey + \":\").toString('base64')\n                },\n                body: JSON.stringify(data),\n                timeout: this.timeout > 0 ? this.timeout : undefined,\n                retryDelay: this.getExponentialDelay.bind(this),\n                retryOn: this.isErrorRetryable.bind(this)\n              };\n              error = undefined;\n              _context2.prev = 43;\n              _context2.next = 46;\n              return _regeneratorRuntime.awrap(retryableFetch(\"\" + this.host, req));\n\n            case 46:\n              response = _context2.sent;\n\n              if (!response.ok) {\n                this.logger.error('request failed to send after 3 retries, dropping ' + itemsToFlush.length + ' events');\n                error = new Error(response.statusText);\n              }\n\n              _context2.next = 54;\n              break;\n\n            case 50:\n              _context2.prev = 50;\n              _context2.t0 = _context2[\"catch\"](43);\n              this.logger.error('request failed to send after 3 retries, dropping ' + itemsToFlush.length + ' events');\n              error = _context2.t0;\n\n            case 54:\n              this.flushResponses.push({\n                error: error,\n                data: data\n              });\n              finishedFlushing = currentBatchOfMessages[currentBatchOfMessages.length - 1].messageId === this.finalMessageId;\n\n              if (!finishedFlushing) {\n                _context2.next = 59;\n                break;\n              }\n\n              if (error) {\n                done(error);\n              } else {\n                done();\n              }\n\n              return _context2.abrupt(\"return\", this.flushResponses.splice(0, this.flushResponses.length));\n\n            case 59:\n              callbacks.forEach(function (callback_) {\n                callback_(error);\n              });\n              _context2.next = 62;\n              return _regeneratorRuntime.awrap(this.executeFlush(flushedItems.concat(itemsToFlush)));\n\n            case 62:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 63:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, [[43, 50]], Promise);\n    }\n  }, {\n    key: \"getExponentialDelay\",\n    value: function getExponentialDelay(priorRetryCount) {\n      var delay = Math.pow(2, priorRetryCount) * 200;\n      var jitter = delay * 0.2 * Math.random();\n      return delay + jitter;\n    }\n  }, {\n    key: \"isErrorRetryable\",\n    value: function isErrorRetryable(priorRetryCount, error, response) {\n      if (priorRetryCount > 2) {\n        return false;\n      }\n\n      return !!error || response.status === 429 || response.status >= 500 && response.status <= 599;\n    }\n  }, {\n    key: \"nullFlushResponse\",\n    value: function nullFlushResponse() {\n      return [{\n        data: {\n          batch: [],\n          sentAt: new Date()\n        }\n      }];\n    }\n  }]);\n\n  return Analytics;\n}();\n\nexports.default = Analytics;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bunyan_1 = __importDefault(require(\"@expo/bunyan\"));\nconst loosely_validate_event_1 = __importDefault(require(\"@segment/loosely-validate-event\"));\nconst assert_1 = __importDefault(require(\"assert\"));\nconst fetch_retry_1 = __importDefault(require(\"fetch-retry\"));\nconst md5_1 = __importDefault(require(\"md5\"));\nconst node_fetch_1 = __importDefault(require(\"node-fetch\"));\nconst remove_trailing_slash_1 = __importDefault(require(\"remove-trailing-slash\"));\nconst uuid_1 = require(\"uuid\");\nconst version = require('./package.json').version;\nconst retryableFetch = (0, fetch_retry_1.default)(node_fetch_1.default);\nconst setImmediate = global.setImmediate || process.nextTick.bind(process);\nclass Analytics {\n    /**\n     * Initialize a new `Analytics` instance with your RudderStack project's `writeKey` and an\n     * optional dictionary of options.\n     */\n    constructor(writeKey, dataPlaneURL, { enable = true, timeout = 0, flushAt = 20, flushInterval = 20000, maxFlushSizeInBytes = 1024 * 1000 * 3.9, // defaults to ~3.9mb\n    maxQueueLength = 1000, logLevel = bunyan_1.default.FATAL, } = {}) {\n        this.inFlightFlush = null;\n        this.queue = [];\n        this.flushCallbacks = [];\n        this.flushResponses = [];\n        this.finalMessageId = null;\n        this.flushed = false;\n        this.timer = null;\n        this.enable = enable;\n        (0, assert_1.default)(writeKey, `The project's write key must be specified`);\n        (0, assert_1.default)(dataPlaneURL, `The data plane URL must be specified`);\n        this.writeKey = writeKey;\n        this.host = (0, remove_trailing_slash_1.default)(dataPlaneURL);\n        this.timeout = timeout;\n        this.flushAt = Math.max(flushAt, 1);\n        this.flushInterval = flushInterval;\n        this.maxFlushSizeInBytes = maxFlushSizeInBytes;\n        this.maxQueueLength = maxQueueLength;\n        this.logger = bunyan_1.default.createLogger({\n            name: '@expo/rudder-node-sdk',\n            level: logLevel,\n        });\n    }\n    /**\n     * Sends an \"identify\" message that associates traits with a user.\n     */\n    identify(message, callback) {\n        this.validate(message, 'identify');\n        this.enqueue('identify', message, callback);\n        return this;\n    }\n    /**\n     * Sends a \"group\" message that identifies this user with a group.\n     */\n    group(message, callback) {\n        this.validate(message, 'group');\n        this.enqueue('group', message, callback);\n        return this;\n    }\n    /**\n     * Sends a \"track\" event that records an action.\n     */\n    track(message, callback) {\n        this.validate(message, 'track');\n        this.enqueue('track', message, callback);\n        return this;\n    }\n    /**\n     * Sends a \"page\" event that records a page view on a website.\n     */\n    page(message, callback) {\n        this.validate(message, 'page');\n        this.enqueue('page', message, callback);\n        return this;\n    }\n    /**\n     * Sends a \"screen\" event that records a screen view in an app.\n     */\n    screen(message, callback) {\n        this.validate(message, 'screen');\n        this.enqueue('screen', message, callback);\n        return this;\n    }\n    /**\n     * Sends an \"alias\" message that associates one ID with another.\n     */\n    alias(message, callback) {\n        this.validate(message, 'alias');\n        this.enqueue('alias', message, callback);\n        return this;\n    }\n    validate(message, type) {\n        try {\n            (0, loosely_validate_event_1.default)(message, type);\n        }\n        catch (e) {\n            if (e.message === 'Your message must be < 32kb.') {\n                this.logger.warn('Your message must be < 32KiB. This is currently surfaced as a warning. Please update your code.', message);\n                return;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Adds a message of the specified type to the queue and flushes the queue if appropriate.\n     */\n    enqueue(type, message, callback = () => { }) {\n        var _a, _b;\n        if (!this.enable) {\n            setImmediate(callback);\n            return;\n        }\n        if (this.queue.length >= this.maxQueueLength) {\n            this.logger.error(`Not adding events for processing as queue size ${this.queue.length} exceeds max configuration ${this.maxQueueLength}`);\n            setImmediate(callback);\n            return;\n        }\n        if (type === 'identify') {\n            (_a = message.traits) !== null && _a !== void 0 ? _a : (message.traits = {});\n            (_b = message.context) !== null && _b !== void 0 ? _b : (message.context = {});\n            message.context.traits = message.traits;\n        }\n        message = { ...message };\n        message.type = type;\n        message.context = {\n            library: {\n                name: '@expo/rudder-sdk-node',\n                version,\n            },\n            ...message.context,\n        };\n        message._metadata = {\n            nodeVersion: process.versions.node,\n            ...message._metadata,\n        };\n        if (!message.originalTimestamp) {\n            message.originalTimestamp = new Date();\n        }\n        if (!message.messageId) {\n            // We md5 the messaage to add more randomness. This is primarily meant\n            // for use in the browser where the uuid package falls back to Math.random()\n            // which is not a great source of randomness.\n            // Borrowed from analytics.js (https://github.com/segment-integrations/analytics.js-integration-segmentio/blob/a20d2a2d222aeb3ab2a8c7e72280f1df2618440e/lib/index.js#L255-L256).\n            message.messageId = `node-${(0, md5_1.default)(JSON.stringify(message))}-${(0, uuid_1.v4)()}`;\n        }\n        this.queue.push({ message, callback });\n        if (!this.flushed) {\n            this.flushed = true;\n            this.flush();\n            return;\n        }\n        const isDivisibleByFlushAt = this.queue.length % this.flushAt === 0;\n        if (isDivisibleByFlushAt) {\n            this.logger.debug(`flushAt reached, messageQueueLength is ${this.queue.length}, trying flush...`);\n            this.flush();\n        }\n        else if (this.flushInterval && !this.timer) {\n            // only start a timer if there are dangling items in the message queue\n            this.logger.debug('no existing flush timer, creating new one');\n            this.timer = setTimeout(this.flush.bind(this), this.flushInterval);\n        }\n    }\n    /**\n     * Flushes the message queue to the server immediately if a flush is not already in progress.\n     */\n    async flush(callback = () => { }) {\n        // will cause new messages to be rolled up into the in-flight flush\n        this.finalMessageId = this.queue.length\n            ? this.queue[this.queue.length - 1].message.messageId\n            : null;\n        this.flushCallbacks.push(callback);\n        if (this.inFlightFlush) {\n            return await this.inFlightFlush;\n        }\n        this.inFlightFlush = this.executeFlush();\n        return await this.inFlightFlush;\n    }\n    /**\n     * Flushes messages from the message queue to the server immediately. After the flush has finished,\n     * this checks for pending flushes and executes them. All data is rolled up into a single FlushResponse.\n     */\n    async executeFlush(flushedItems = []) {\n        var _a;\n        // check if earlier flush was pushed to queue\n        this.logger.debug('in flush');\n        if (!this.enable) {\n            this.inFlightFlush = null;\n            this.finalMessageId = null;\n            this.flushResponses.splice(0, this.flushResponses.length);\n            const nullResponse = this.nullFlushResponse();\n            this.flushCallbacks\n                .splice(0, this.flushCallbacks.length)\n                .map((callback) => setImmediate(callback, nullResponse));\n            return nullResponse;\n        }\n        if (this.timer) {\n            this.logger.debug('cancelling existing timer...');\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n        if (!this.queue.length) {\n            this.logger.debug('queue is empty, nothing to flush');\n            this.inFlightFlush = null;\n            this.finalMessageId = null;\n            this.flushResponses.splice(0, this.flushResponses.length);\n            const nullResponse = this.nullFlushResponse();\n            this.flushCallbacks\n                .splice(0, this.flushCallbacks.length)\n                .map((callback) => setImmediate(callback, nullResponse));\n            return nullResponse;\n        }\n        let flushSize = 0;\n        let spliceIndex = 0;\n        // guard against requests larger than 4mb\n        for (let i = 0; i < this.queue.length; i++) {\n            const item = this.queue[i];\n            const itemSize = JSON.stringify(item).length;\n            const exceededMaxFlushSize = flushSize + itemSize > this.maxFlushSizeInBytes;\n            if (exceededMaxFlushSize) {\n                break;\n            }\n            flushSize += itemSize;\n            spliceIndex++;\n            if (((_a = item.message.messageId) !== null && _a !== void 0 ? _a : null) === this.finalMessageId) {\n                break; // guard against flushing items added to the message queue during this flush\n            }\n        }\n        const itemsToFlush = this.queue.splice(0, spliceIndex);\n        const callbacks = itemsToFlush.map((item) => item.callback);\n        const currentBatchOfMessages = itemsToFlush.map((item) => {\n            // if someone mangles directly with queue\n            if (typeof item.message == 'object') {\n                item.message.sentAt = new Date();\n            }\n            return item.message;\n        });\n        const done = (err) => {\n            callbacks.forEach((callback_) => {\n                callback_(err);\n            });\n            const flushResponses = this.flushResponses.slice(0, this.flushResponses.length);\n            this.flushCallbacks\n                .splice(0, this.flushCallbacks.length)\n                .map((callback) => setImmediate(callback, flushResponses));\n            this.inFlightFlush = null;\n            this.finalMessageId = null;\n        };\n        const data = {\n            batch: currentBatchOfMessages,\n            sentAt: new Date(),\n        };\n        this.logger.debug('batch size is ' + itemsToFlush.length);\n        this.logger.trace('===data===', data);\n        const req = {\n            method: 'POST',\n            headers: {\n                accept: 'application/json, text/plain, */*',\n                'content-type': 'application/json;charset=utf-8',\n                'user-agent': `expo-rudder-sdk-node/${version}`,\n                authorization: 'Basic ' + Buffer.from(`${this.writeKey}:`).toString('base64'),\n            },\n            body: JSON.stringify(data),\n            timeout: this.timeout > 0 ? this.timeout : undefined,\n            retryDelay: this.getExponentialDelay.bind(this),\n            retryOn: this.isErrorRetryable.bind(this),\n        };\n        let error = undefined;\n        try {\n            const response = await retryableFetch(`${this.host}`, req);\n            if (!response.ok) {\n                // handle 4xx 5xx errors\n                this.logger.error('request failed to send after 3 retries, dropping ' + itemsToFlush.length + ' events');\n                error = new Error(response.statusText);\n            }\n        }\n        catch (err) {\n            // handle network errors\n            this.logger.error('request failed to send after 3 retries, dropping ' + itemsToFlush.length + ' events');\n            error = err;\n        }\n        this.flushResponses.push({ error, data });\n        const finishedFlushing = currentBatchOfMessages[currentBatchOfMessages.length - 1].messageId === this.finalMessageId;\n        if (finishedFlushing) {\n            if (error) {\n                done(error);\n            }\n            else {\n                done();\n            }\n            return this.flushResponses.splice(0, this.flushResponses.length);\n        }\n        callbacks.forEach((callback_) => {\n            callback_(error);\n        });\n        return await this.executeFlush(flushedItems.concat(itemsToFlush));\n    }\n    /**\n     * Calculates the amount of time to wait before retrying a request, given the number of prior\n     * retries (excluding the initial attempt).\n     *\n     * @param priorRetryCount the number of prior retries, starting from zero\n     */\n    getExponentialDelay(priorRetryCount) {\n        const delay = 2 ** priorRetryCount * 200;\n        const jitter = delay * 0.2 * Math.random(); // 0-20% of the delay\n        return delay + jitter;\n    }\n    /**\n     * Returns whether to retry a request that failed with the given error or returned the given\n     * response.\n     */\n    isErrorRetryable(priorRetryCount, error, response) {\n        // 3 retries max\n        if (priorRetryCount > 2) {\n            return false;\n        }\n        return (\n        // Retry on any network error\n        !!error ||\n            // Retry if rate limited\n            response.status === 429 ||\n            // Retry on 5xx status codes due to server errors\n            (response.status >= 500 && response.status <= 599));\n    }\n    nullFlushResponse() {\n        return [\n            {\n                data: {\n                    batch: [],\n                    sentAt: new Date(),\n                },\n            },\n        ];\n    }\n}\nexports.default = Analytics;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}