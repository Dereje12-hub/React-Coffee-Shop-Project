{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resize = exports.getJimpImageAsync = exports.circleAsync = exports.isFolderAsync = exports.jimpAsync = exports.convertFormat = exports.resizeBufferAsync = void 0;\n\nvar fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nvar jimp_compact_1 = __importDefault(require(\"jimp-compact\"));\n\nvar path = __importStar(require(\"path\"));\n\nfunction resizeBufferAsync(buffer, sizes) {\n  return _regeneratorRuntime.async(function resizeBufferAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          return _context2.abrupt(\"return\", Promise.all(sizes.map(function _callee(size) {\n            var jimpImage, mime;\n            return _regeneratorRuntime.async(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return _regeneratorRuntime.awrap(jimp_compact_1.default.read(buffer));\n\n                  case 2:\n                    jimpImage = _context.sent;\n                    mime = jimpImage.getMIME();\n                    return _context.abrupt(\"return\", jimpImage.resize(size, size).getBufferAsync(mime));\n\n                  case 5:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          })));\n\n        case 1:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.resizeBufferAsync = resizeBufferAsync;\n\nfunction convertFormat(format) {\n  if (typeof format === 'undefined') return format;\n  var input = format === null || format === void 0 ? void 0 : format.toLowerCase();\n\n  switch (input) {\n    case 'png':\n    case 'webp':\n    case 'jpeg':\n      return \"image/\" + input;\n\n    case 'jpg':\n      return \"image/jpeg\";\n  }\n\n  return undefined;\n}\n\nexports.convertFormat = convertFormat;\n\nfunction jimpAsync(options) {\n  var commands,\n      command,\n      input,\n      image,\n      mime,\n      imgBuffer,\n      _args3 = arguments;\n  return _regeneratorRuntime.async(function jimpAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          commands = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : [];\n\n          if (!commands.length) {\n            _context3.next = 18;\n            break;\n          }\n\n          command = commands.shift();\n\n          if (!command) {\n            _context3.next = 18;\n            break;\n          }\n\n          if (!(command.operation === 'resize')) {\n            _context3.next = 10;\n            break;\n          }\n\n          _context3.next = 7;\n          return _regeneratorRuntime.awrap(resize(options, command));\n\n        case 7:\n          input = _context3.sent;\n          _context3.next = 17;\n          break;\n\n        case 10:\n          if (!(command.operation === 'flatten')) {\n            _context3.next = 16;\n            break;\n          }\n\n          _context3.next = 13;\n          return _regeneratorRuntime.awrap(flatten(options, command));\n\n        case 13:\n          input = _context3.sent;\n          _context3.next = 17;\n          break;\n\n        case 16:\n          throw new Error(\"The operation: '\" + command.operation + \"' is not supported with Jimp\");\n\n        case 17:\n          return _context3.abrupt(\"return\", jimpAsync(_objectSpread(_objectSpread({}, options), {}, {\n            input: input\n          }), commands));\n\n        case 18:\n          _context3.next = 20;\n          return _regeneratorRuntime.awrap(getJimpImageAsync(options.input));\n\n        case 20:\n          image = _context3.sent;\n          mime = typeof options.format === 'string' ? options.format : image.getMIME();\n          _context3.next = 24;\n          return _regeneratorRuntime.awrap(image.getBufferAsync(mime));\n\n        case 24:\n          imgBuffer = _context3.sent;\n\n          if (!(typeof options.output === 'string')) {\n            _context3.next = 35;\n            break;\n          }\n\n          _context3.next = 28;\n          return _regeneratorRuntime.awrap(isFolderAsync(options.output));\n\n        case 28:\n          if (!_context3.sent) {\n            _context3.next = 33;\n            break;\n          }\n\n          _context3.next = 31;\n          return _regeneratorRuntime.awrap(fs_extra_1.default.writeFile(path.join(options.output, path.basename(options.originalInput)), imgBuffer));\n\n        case 31:\n          _context3.next = 35;\n          break;\n\n        case 33:\n          _context3.next = 35;\n          return _regeneratorRuntime.awrap(fs_extra_1.default.writeFile(options.output, imgBuffer));\n\n        case 35:\n          return _context3.abrupt(\"return\", imgBuffer);\n\n        case 36:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.jimpAsync = jimpAsync;\n\nfunction isFolderAsync(path) {\n  return _regeneratorRuntime.async(function isFolderAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.prev = 0;\n          _context4.next = 3;\n          return _regeneratorRuntime.awrap(fs_extra_1.default.stat(path));\n\n        case 3:\n          return _context4.abrupt(\"return\", _context4.sent.isDirectory());\n\n        case 6:\n          _context4.prev = 6;\n          _context4.t0 = _context4[\"catch\"](0);\n          return _context4.abrupt(\"return\", false);\n\n        case 9:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[0, 6]], Promise);\n}\n\nexports.isFolderAsync = isFolderAsync;\n\nfunction circleAsync(jimp) {\n  var radius = Math.min(jimp.bitmap.width, jimp.bitmap.height) / 2;\n  var center = {\n    x: jimp.bitmap.width / 2,\n    y: jimp.bitmap.height / 2\n  };\n  return new Promise(function (resolve) {\n    jimp.scanQuiet(0, 0, jimp.bitmap.width, jimp.bitmap.height, function (x, y, idx) {\n      var curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));\n\n      if (radius - curR <= 0.0) {\n        jimp.bitmap.data[idx + 3] = 0;\n      } else if (radius - curR < 1.0) {\n        jimp.bitmap.data[idx + 3] = 255 * (radius - curR);\n      }\n\n      resolve(jimp);\n    });\n  });\n}\n\nexports.circleAsync = circleAsync;\n\nfunction getJimpImageAsync(input) {\n  return _regeneratorRuntime.async(function getJimpImageAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          if (!(typeof input === 'string' || input instanceof Buffer)) {\n            _context5.next = 4;\n            break;\n          }\n\n          _context5.next = 3;\n          return _regeneratorRuntime.awrap(jimp_compact_1.default.read(input));\n\n        case 3:\n          return _context5.abrupt(\"return\", _context5.sent);\n\n        case 4:\n          return _context5.abrupt(\"return\", input);\n\n        case 5:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.getJimpImageAsync = getJimpImageAsync;\n\nfunction resize(_ref, _ref2) {\n  var input, _ref$quality, quality, background, position, fit, width, height, initialImage, jimpPosition, jimpQuality;\n\n  return _regeneratorRuntime.async(function resize$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          input = _ref.input, _ref$quality = _ref.quality, quality = _ref$quality === void 0 ? 100 : _ref$quality;\n          background = _ref2.background, position = _ref2.position, fit = _ref2.fit, width = _ref2.width, height = _ref2.height;\n          _context6.next = 4;\n          return _regeneratorRuntime.awrap(getJimpImageAsync(input));\n\n        case 4:\n          initialImage = _context6.sent;\n\n          if (width && !height) {\n            height = jimp_compact_1.default.AUTO;\n          } else if (!width && height) {\n            width = jimp_compact_1.default.AUTO;\n          } else if (!width && !height) {\n            width = initialImage.bitmap.width;\n            height = initialImage.bitmap.height;\n          }\n\n          jimpPosition = convertPosition(position);\n          jimpQuality = typeof quality !== 'number' ? 100 : quality;\n\n          if (!(fit === 'cover')) {\n            _context6.next = 12;\n            break;\n          }\n\n          initialImage = initialImage.cover(width, height, jimpPosition);\n          _context6.next = 17;\n          break;\n\n        case 12:\n          if (!(fit === 'contain')) {\n            _context6.next = 16;\n            break;\n          }\n\n          initialImage = initialImage.contain(width, height, jimpPosition);\n          _context6.next = 17;\n          break;\n\n        case 16:\n          throw new Error(\"Unsupported fit: \" + fit + \". Please choose either 'cover', or 'contain' when using Jimp\");\n\n        case 17:\n          if (background) {\n            initialImage = initialImage.composite(new jimp_compact_1.default(width, height, background), 0, 0, {\n              mode: jimp_compact_1.default.BLEND_DESTINATION_OVER,\n              opacitySource: 1,\n              opacityDest: 1\n            });\n          }\n\n          _context6.next = 20;\n          return _regeneratorRuntime.awrap(initialImage.quality(jimpQuality));\n\n        case 20:\n          return _context6.abrupt(\"return\", _context6.sent);\n\n        case 21:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.resize = resize;\n\nfunction flatten(_ref3, _ref4) {\n  var input, _ref3$quality, quality, background, initialImage, jimpQuality;\n\n  return _regeneratorRuntime.async(function flatten$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          input = _ref3.input, _ref3$quality = _ref3.quality, quality = _ref3$quality === void 0 ? 100 : _ref3$quality;\n          background = _ref4.background;\n          _context7.next = 4;\n          return _regeneratorRuntime.awrap(getJimpImageAsync(input));\n\n        case 4:\n          initialImage = _context7.sent;\n          jimpQuality = typeof quality !== 'number' ? 100 : quality;\n          return _context7.abrupt(\"return\", initialImage.quality(jimpQuality).background(jimp_compact_1.default.cssColorToHex(background)));\n\n        case 7:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction convertPosition(position) {\n  if (!position) return convertPosition('center');\n\n  switch (position) {\n    case 'center':\n    case 'centre':\n      return jimp_compact_1.default.VERTICAL_ALIGN_MIDDLE | jimp_compact_1.default.HORIZONTAL_ALIGN_CENTER;\n\n    case 'north':\n    case 'top':\n      return jimp_compact_1.default.VERTICAL_ALIGN_TOP | jimp_compact_1.default.HORIZONTAL_ALIGN_CENTER;\n\n    case 'east':\n    case 'right':\n      return jimp_compact_1.default.VERTICAL_ALIGN_MIDDLE | jimp_compact_1.default.HORIZONTAL_ALIGN_RIGHT;\n\n    case 'south':\n    case 'bottom':\n      return jimp_compact_1.default.VERTICAL_ALIGN_BOTTOM | jimp_compact_1.default.HORIZONTAL_ALIGN_CENTER;\n\n    case 'west':\n    case 'left':\n      return jimp_compact_1.default.VERTICAL_ALIGN_MIDDLE | jimp_compact_1.default.HORIZONTAL_ALIGN_LEFT;\n\n    case 'northeast':\n    case 'right top':\n      return jimp_compact_1.default.VERTICAL_ALIGN_TOP | jimp_compact_1.default.HORIZONTAL_ALIGN_RIGHT;\n\n    case 'southeast':\n    case 'right bottom':\n      return jimp_compact_1.default.VERTICAL_ALIGN_BOTTOM | jimp_compact_1.default.HORIZONTAL_ALIGN_RIGHT;\n\n    case 'southwest':\n    case 'left bottom':\n      return jimp_compact_1.default.VERTICAL_ALIGN_BOTTOM | jimp_compact_1.default.HORIZONTAL_ALIGN_LEFT;\n\n    case 'northwest':\n    case 'left top':\n      return jimp_compact_1.default.VERTICAL_ALIGN_TOP | jimp_compact_1.default.HORIZONTAL_ALIGN_LEFT;\n\n    case 'entropy':\n    case 'attention':\n      throw new Error(\"Position: '\" + position + \"' is not supported\");\n\n    default:\n      throw new Error(\"Unknown position: '\" + position + \"'\");\n  }\n}","map":{"version":3,"sources":["../src/jimp.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\n// @ts-ignore\nimport Jimp from 'jimp-compact';\nimport * as path from 'path';\n\nimport {\n  FlattenOptions,\n  Position,\n  ResizeOptions,\n  SharpCommandOptions,\n  SharpGlobalOptions,\n} from './sharp.types';\n\ntype JimpGlobalOptions = Omit<SharpGlobalOptions, 'input'> & {\n  input: string | Buffer | Jimp;\n  originalInput: string;\n};\n\nexport async function resizeBufferAsync(buffer: Buffer, sizes: number[]): Promise<Buffer[]> {\n  return Promise.all(\n    sizes.map(async size => {\n      // Parse the buffer each time to prevent mutable copies.\n      // Parse the buffer each time to prevent mutable copies.\n      const jimpImage = await Jimp.read(buffer);\n      const mime = jimpImage.getMIME();\n\n      return jimpImage.resize(size, size).getBufferAsync(mime);\n    })\n  );\n}\n\nexport function convertFormat(format?: string): string | undefined {\n  if (typeof format === 'undefined') return format;\n\n  const input = format?.toLowerCase();\n  switch (input) {\n    case 'png':\n    case 'webp':\n    case 'jpeg':\n      return `image/${input}`;\n    case 'jpg':\n      return `image/jpeg`;\n  }\n  return undefined;\n}\n\nexport async function jimpAsync(\n  options: JimpGlobalOptions,\n  commands: SharpCommandOptions[] = []\n): Promise<Buffer> {\n  if (commands.length) {\n    const command = commands.shift();\n    if (command) {\n      let input: Jimp;\n      if (command.operation === 'resize') {\n        input = await resize(options, command);\n      } else if (command.operation === 'flatten') {\n        input = await flatten(options, command);\n      } else {\n        throw new Error(`The operation: '${command.operation}' is not supported with Jimp`);\n      }\n      // @ts-ignore\n      return jimpAsync({ ...options, input }, commands);\n    }\n  }\n\n  const image = await getJimpImageAsync(options.input);\n  const mime = typeof options.format === 'string' ? options.format : image.getMIME();\n  const imgBuffer = await image.getBufferAsync(mime);\n\n  if (typeof options.output === 'string') {\n    if (await isFolderAsync(options.output)) {\n      await fs.writeFile(\n        path.join(options.output, path.basename(options.originalInput)),\n        imgBuffer\n      );\n    } else {\n      await fs.writeFile(options.output, imgBuffer);\n    }\n  }\n  return imgBuffer;\n}\n\nexport async function isFolderAsync(path: string): Promise<boolean> {\n  try {\n    return (await fs.stat(path)).isDirectory();\n  } catch (e) {\n    return false;\n  }\n}\n\nexport function circleAsync(jimp: Jimp): Promise<Jimp> {\n  const radius = Math.min(jimp.bitmap.width, jimp.bitmap.height) / 2;\n\n  const center = {\n    x: jimp.bitmap.width / 2,\n    y: jimp.bitmap.height / 2,\n  };\n\n  return new Promise(resolve => {\n    jimp.scanQuiet(\n      0,\n      0,\n      jimp.bitmap.width,\n      jimp.bitmap.height,\n      (x: number, y: number, idx: number) => {\n        const curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));\n\n        if (radius - curR <= 0.0) {\n          jimp.bitmap.data[idx + 3] = 0;\n        } else if (radius - curR < 1.0) {\n          jimp.bitmap.data[idx + 3] = 255 * (radius - curR);\n        }\n        resolve(jimp);\n      }\n    );\n  });\n}\n\nexport async function getJimpImageAsync(input: string | Buffer | Jimp): Promise<Jimp> {\n  // @ts-ignore: Jimp types are broken\n  if (typeof input === 'string' || input instanceof Buffer) return await Jimp.read(input);\n\n  return input;\n}\n\nexport async function resize(\n  { input, quality = 100 }: JimpGlobalOptions,\n  { background, position, fit, width, height }: Omit<ResizeOptions, 'operation'>\n): Promise<Jimp> {\n  let initialImage = await getJimpImageAsync(input);\n\n  if (width && !height) {\n    height = Jimp.AUTO;\n  } else if (!width && height) {\n    width = Jimp.AUTO;\n  } else if (!width && !height) {\n    width = initialImage.bitmap.width;\n    height = initialImage.bitmap.height;\n  }\n\n  const jimpPosition = convertPosition(position);\n  const jimpQuality = typeof quality !== 'number' ? 100 : quality;\n  if (fit === 'cover') {\n    initialImage = initialImage.cover(width, height, jimpPosition);\n  } else if (fit === 'contain') {\n    initialImage = initialImage.contain(width, height, jimpPosition);\n  } else {\n    throw new Error(\n      `Unsupported fit: ${fit}. Please choose either 'cover', or 'contain' when using Jimp`\n    );\n  }\n  if (background) {\n    initialImage = initialImage.composite(new Jimp(width, height, background), 0, 0, {\n      mode: Jimp.BLEND_DESTINATION_OVER,\n      opacitySource: 1,\n      opacityDest: 1,\n    });\n  }\n\n  return await initialImage.quality(jimpQuality);\n}\n\nasync function flatten(\n  { input, quality = 100 }: JimpGlobalOptions,\n  { background }: Omit<FlattenOptions, 'operation'>\n): Promise<Jimp> {\n  const initialImage = await getJimpImageAsync(input);\n  const jimpQuality = typeof quality !== 'number' ? 100 : quality;\n  return initialImage.quality(jimpQuality).background(Jimp.cssColorToHex(background));\n}\n\n/**\n * Convert sharp position to Jimp position.\n *\n * @param position\n */\nfunction convertPosition(position?: Position): number {\n  if (!position) return convertPosition('center');\n\n  switch (position) {\n    case 'center':\n    case 'centre':\n      return Jimp.VERTICAL_ALIGN_MIDDLE | Jimp.HORIZONTAL_ALIGN_CENTER;\n    case 'north':\n    case 'top':\n      return Jimp.VERTICAL_ALIGN_TOP | Jimp.HORIZONTAL_ALIGN_CENTER;\n    case 'east':\n    case 'right':\n      return Jimp.VERTICAL_ALIGN_MIDDLE | Jimp.HORIZONTAL_ALIGN_RIGHT;\n    case 'south':\n    case 'bottom':\n      return Jimp.VERTICAL_ALIGN_BOTTOM | Jimp.HORIZONTAL_ALIGN_CENTER;\n    case 'west':\n    case 'left':\n      return Jimp.VERTICAL_ALIGN_MIDDLE | Jimp.HORIZONTAL_ALIGN_LEFT;\n    case 'northeast':\n    case 'right top':\n      return Jimp.VERTICAL_ALIGN_TOP | Jimp.HORIZONTAL_ALIGN_RIGHT;\n    case 'southeast':\n    case 'right bottom':\n      return Jimp.VERTICAL_ALIGN_BOTTOM | Jimp.HORIZONTAL_ALIGN_RIGHT;\n    case 'southwest':\n    case 'left bottom':\n      return Jimp.VERTICAL_ALIGN_BOTTOM | Jimp.HORIZONTAL_ALIGN_LEFT;\n    case 'northwest':\n    case 'left top':\n      return Jimp.VERTICAL_ALIGN_TOP | Jimp.HORIZONTAL_ALIGN_LEFT;\n    case 'entropy':\n    case 'attention':\n      throw new Error(`Position: '${position}' is not supported`);\n    default:\n      throw new Error(`Unknown position: '${position}'`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}