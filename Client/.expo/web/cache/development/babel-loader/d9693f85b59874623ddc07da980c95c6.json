{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createExoticTransformer = void 0;\n\nvar createMatcher_1 = require(\"./createMatcher\");\n\nvar createMultiRuleTransformer_1 = require(\"./createMultiRuleTransformer\");\n\nvar getCacheKey_1 = require(\"./getCacheKey\");\n\nfunction createExoticTransformer(_ref) {\n  var nodeModulesPaths = _ref.nodeModulesPaths,\n      transpileModules = _ref.transpileModules;\n\n  if (!nodeModulesPaths) {\n    nodeModulesPaths = ['node_modules'];\n  }\n\n  var nodeModuleMatcher = createMatcher_1.createModuleMatcher({\n    folders: nodeModulesPaths,\n    moduleIds: []\n  });\n  var impossibleNodeModuleMatcher = createMatcher_1.createModuleMatcher({\n    moduleIds: ['victory', '@expo/vector-icons'].concat(_toConsumableArray(transpileModules || [])),\n    folders: nodeModulesPaths\n  });\n  var transform = createMultiRuleTransformer_1.createMultiRuleTransformer({\n    getRuleType: function getRuleType(_ref2) {\n      var filename = _ref2.filename;\n      return nodeModuleMatcher.test(filename) && !impossibleNodeModuleMatcher.test(filename) ? 'module' : 'app';\n    },\n    rules: [{\n      name: 'bob',\n      type: 'module',\n      test: createMatcher_1.createModuleMatcher({\n        moduleIds: ['.*/lib/commonjs/'],\n        folders: nodeModulesPaths\n      }),\n      transform: createMultiRuleTransformer_1.loaders.passthroughModule,\n      warn: true\n    }, {\n      name: 'react-native',\n      type: 'module',\n      test: createMatcher_1.createReactNativeMatcher({\n        folders: nodeModulesPaths\n      }),\n      transform: createMultiRuleTransformer_1.loaders.reactNativeModule,\n      warn: true\n    }, {\n      name: 'expo-module',\n      type: 'module',\n      test: createMatcher_1.createExpoMatcher({\n        folders: nodeModulesPaths\n      }),\n      transform: createMultiRuleTransformer_1.loaders.expoModule,\n      warn: true\n    }, {\n      name: 'sucrase',\n      type: 'module',\n      test: createMatcher_1.createKnownCommunityMatcher({\n        folders: nodeModulesPaths\n      }),\n      transform: createMultiRuleTransformer_1.loaders.untranspiledModule,\n      warn: true\n    }, {\n      name: 'skip-module',\n      type: 'module',\n      test: function test() {\n        return true;\n      },\n      transform: createMultiRuleTransformer_1.loaders.passthroughModule\n    }, {\n      name: 'babel',\n      test: function test() {\n        return true;\n      },\n      transform: createMultiRuleTransformer_1.loaders.app\n    }]\n  });\n  return {\n    transform: transform,\n    getCacheKey: getCacheKey_1.getCacheKey\n  };\n}\n\nexports.createExoticTransformer = createExoticTransformer;","map":{"version":3,"sources":["../../src/transformer/createExoticTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2021-present 650 Industries (Expo). All rights reserved.\nimport { BabelTransformer } from 'metro-babel-transformer';\n\nimport {\n  createExpoMatcher,\n  createKnownCommunityMatcher,\n  createModuleMatcher,\n  createReactNativeMatcher,\n} from './createMatcher';\nimport { createMultiRuleTransformer, loaders } from './createMultiRuleTransformer';\nimport { getCacheKey } from './getCacheKey';\n\n/**\n * Create an experimental multi-rule transformer for a React Native app.\n *\n * @example\n * ```\n * module.exports = createExoticTransformer({\n *    nodeModulesPaths: ['react-native'],\n *    transpileModules: ['@stripe/stripe-react-native'],\n * });\n * ```\n *\n * @param props.nodeModulesPaths paths to node_modules folders, relative to project root. Default: `['node_modules']`\n * @param props.transpileModules matchers for module names that should be transpiled using the project Babel configuration. Example: `['@stripe/stripe-react-native']`\n * @returns a Metro `transformer` function and default `getCacheKey` function.\n */\nexport function createExoticTransformer({\n  nodeModulesPaths,\n  transpileModules,\n}: {\n  nodeModulesPaths?: string[];\n  transpileModules?: string[];\n}): BabelTransformer {\n  if (!nodeModulesPaths) {\n    nodeModulesPaths = ['node_modules'];\n  }\n  // Match any node modules, or monorepo module.\n  const nodeModuleMatcher = createModuleMatcher({ folders: nodeModulesPaths, moduleIds: [] });\n\n  // Match node modules which are so oddly written that we must\n  // transpile them with every possible option (most expensive).\n  const impossibleNodeModuleMatcher = createModuleMatcher({\n    moduleIds: [\n      // victory is too wild\n      // SyntaxError in ../../node_modules/victory-native/lib/components/victory-primitives/bar.js: Missing semicolon. (9:1)\n      'victory',\n      // vector icons has some hidden issues that break NCL\n      '@expo/vector-icons',\n      ...(transpileModules || []),\n    ],\n    folders: nodeModulesPaths,\n  });\n\n  const transform = createMultiRuleTransformer({\n    // Specify which rules to use on a per-file basis, basically\n    // this is used to determine which modules are node modules, and which are application code.\n    getRuleType({ filename }) {\n      // Is a node module, and is not one of the impossible modules.\n      return nodeModuleMatcher.test(filename) && !impossibleNodeModuleMatcher.test(filename)\n        ? 'module'\n        : 'app';\n    },\n\n    // Order is very important, we use wild card matchers to transpile\n    // \"every unhandled node module\" and \"every unhandled application module\".\n    rules: [\n      // Match bob compiler modules, use the passthrough loader.\n      {\n        name: 'bob',\n        type: 'module',\n        test: createModuleMatcher({ moduleIds: ['.*/lib/commonjs/'], folders: nodeModulesPaths }),\n        transform: loaders.passthroughModule,\n        warn: true,\n      },\n      // Match React Native modules, convert them statically using sucrase.\n      {\n        name: 'react-native',\n        type: 'module',\n        test: createReactNativeMatcher({ folders: nodeModulesPaths }),\n        transform: loaders.reactNativeModule,\n        warn: true,\n      },\n      // Match Expo SDK modules, convert them statically using sucrase.\n      {\n        name: 'expo-module',\n        type: 'module',\n        test: createExpoMatcher({ folders: nodeModulesPaths }),\n        transform: loaders.expoModule,\n        warn: true,\n      },\n      // Match known problematic modules, convert them statically using an expensive, dynamic sucrase.\n      {\n        name: 'sucrase',\n        type: 'module',\n        test: createKnownCommunityMatcher({\n          folders: nodeModulesPaths,\n        }),\n        transform: loaders.untranspiledModule,\n        warn: true,\n      },\n      // Pass through any unhandled node modules as passthrough, this is where the most savings occur.\n      // Ideally, you want your project to pass all node modules through this loader.\n      // This should be the last \"module\" rule.\n      // Message library authors and ask them to ship their modules as pre-transpiled\n      // commonjs, to improve the development speed of your project.\n      {\n        name: 'skip-module',\n        type: 'module',\n        test: () => true,\n        transform: loaders.passthroughModule,\n      },\n      // All application code should be transpiled with the user's babel preset,\n      // this is the most expensive operation but provides the most customization to the user.\n      // The goal is to use this as sparingly as possible.\n      {\n        name: 'babel',\n        test: () => true,\n        transform: loaders.app,\n      },\n    ],\n  });\n\n  return {\n    transform,\n    getCacheKey,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}