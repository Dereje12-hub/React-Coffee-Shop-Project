{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeXMLAsync = writeXMLAsync;\nexports.readXMLAsync = readXMLAsync;\nexports.parseXMLAsync = parseXMLAsync;\nexports.format = format;\n\nfunction _fsExtra() {\n  var data = _interopRequireDefault(require(\"fs-extra\"));\n\n  _fsExtra = function _fsExtra() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _os() {\n  var data = require(\"os\");\n\n  _os = function _os() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _xml2js() {\n  var data = require(\"xml2js\");\n\n  _xml2js = function _xml2js() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction writeXMLAsync(options) {\n  var xml;\n  return _regeneratorRuntime.async(function writeXMLAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          xml = new (_xml2js().Builder)().buildObject(options.xml);\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(_fsExtra().default.ensureDir(_path().default.dirname(options.path)));\n\n        case 3:\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(_fsExtra().default.writeFile(options.path, xml));\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction readXMLAsync(options) {\n  var contents, parser, manifest;\n  return _regeneratorRuntime.async(function readXMLAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          contents = '';\n          _context2.prev = 1;\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(_fsExtra().default.readFile(options.path, {\n            encoding: 'utf8',\n            flag: 'r'\n          }));\n\n        case 4:\n          contents = _context2.sent;\n          _context2.next = 9;\n          break;\n\n        case 7:\n          _context2.prev = 7;\n          _context2.t0 = _context2[\"catch\"](1);\n\n        case 9:\n          parser = new (_xml2js().Parser)();\n          _context2.next = 12;\n          return _regeneratorRuntime.awrap(parser.parseStringPromise(contents || options.fallback || ''));\n\n        case 12:\n          manifest = _context2.sent;\n          return _context2.abrupt(\"return\", manifest);\n\n        case 14:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, [[1, 7]], Promise);\n}\n\nfunction parseXMLAsync(contents) {\n  var xml;\n  return _regeneratorRuntime.async(function parseXMLAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return _regeneratorRuntime.awrap(new (_xml2js().Parser)().parseStringPromise(contents));\n\n        case 2:\n          xml = _context3.sent;\n          return _context3.abrupt(\"return\", xml);\n\n        case 4:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nvar stringTimesN = function stringTimesN(n, char) {\n  return Array(n + 1).join(char);\n};\n\nfunction format(manifest) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$indentLevel = _ref.indentLevel,\n      indentLevel = _ref$indentLevel === void 0 ? 2 : _ref$indentLevel,\n      _ref$newline = _ref.newline,\n      newline = _ref$newline === void 0 ? _os().EOL : _ref$newline;\n\n  var xmlInput;\n\n  if (typeof manifest === 'string') {\n    xmlInput = manifest;\n  } else if (manifest.toString) {\n    var builder = new (_xml2js().Builder)({\n      headless: true\n    });\n    xmlInput = builder.buildObject(manifest);\n    return xmlInput;\n  } else {\n    throw new Error(\"Invalid XML value passed in: \" + manifest);\n  }\n\n  var indentString = stringTimesN(indentLevel, ' ');\n  var formatted = '';\n  var regex = /(>)(<)(\\/*)/g;\n  var xml = xmlInput.replace(regex, \"$1\" + newline + \"$2$3\");\n  var pad = 0;\n  xml.split(/\\r?\\n/).map(function (line) {\n    return line.trim();\n  }).forEach(function (line) {\n    var indent = 0;\n\n    if (line.match(/.+<\\/\\w[^>]*>$/)) {\n      indent = 0;\n    } else if (line.match(/^<\\/\\w/)) {\n      if (pad !== 0) {\n        pad -= 1;\n      }\n    } else if (line.match(/^<\\w([^>]*[^/])?>.*$/)) {\n      indent = 1;\n    } else {\n      indent = 0;\n    }\n\n    var padding = stringTimesN(pad, indentString);\n    formatted += padding + line + newline;\n    pad += indent;\n  });\n  return formatted.trim();\n}","map":{"version":3,"sources":["../../src/utils/XML.ts"],"names":["xml","Builder","options","fs","path","contents","encoding","flag","parser","Parser","manifest","stringTimesN","Array","n","indentLevel","newline","EOL","xmlInput","builder","headless","indentString","formatted","regex","pad","line","indent","padding"],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\nimport { EOL } from 'os';\nimport path from 'path';\nimport { Builder, Parser } from 'xml2js';\n\nexport type XMLValue = boolean | number | string | null | XMLArray | XMLObject;\n\nexport interface XMLArray extends Array<XMLValue> {}\n\nexport interface XMLObject {\n  [key: string]: XMLValue | undefined;\n}\n\nexport async function writeXMLAsync(options: { path: string; xml: any }): Promise<void> {\n  const xml = new Builder().buildObject(options.xml);\n  await fs.ensureDir(path.dirname(options.path));\n  await fs.writeFile(options.path, xml);\n}\n\nexport async function readXMLAsync(options: {\n  path: string;\n  fallback?: string | null;\n}): Promise<XMLObject> {\n  let contents: string = '';\n  try {\n    contents = await fs.readFile(options.path, { encoding: 'utf8', flag: 'r' });\n  } catch {\n    // catch and use fallback\n  }\n  const parser = new Parser();\n  const manifest = await parser.parseStringPromise(contents || options.fallback || '');\n  return manifest;\n}\n\nexport async function parseXMLAsync(contents: string): Promise<XMLObject> {\n  const xml = await new Parser().parseStringPromise(contents);\n  return xml;\n}\n\nconst stringTimesN = (n: number, char: string) => Array(n + 1).join(char);\n\nexport function format(manifest: any, { indentLevel = 2, newline = EOL } = {}): string {\n  let xmlInput: string;\n  if (typeof manifest === 'string') {\n    xmlInput = manifest;\n  } else if (manifest.toString) {\n    const builder = new Builder({ headless: true });\n    xmlInput = builder.buildObject(manifest);\n    return xmlInput;\n  } else {\n    throw new Error(`Invalid XML value passed in: ${manifest}`);\n  }\n  const indentString = stringTimesN(indentLevel, ' ');\n\n  let formatted = '';\n  const regex = /(>)(<)(\\/*)/g;\n  const xml = xmlInput.replace(regex, `$1${newline}$2$3`);\n  let pad = 0;\n  xml\n    .split(/\\r?\\n/)\n    .map((line: string) => line.trim())\n    .forEach((line: string) => {\n      let indent = 0;\n      if (line.match(/.+<\\/\\w[^>]*>$/)) {\n        indent = 0;\n      } else if (line.match(/^<\\/\\w/)) {\n        // Somehow istanbul doesn't see the else case as covered, although it is. Skip it.\n        /* istanbul ignore else  */\n        if (pad !== 0) {\n          pad -= 1;\n        }\n      } else if (line.match(/^<\\w([^>]*[^/])?>.*$/)) {\n        indent = 1;\n      } else {\n        indent = 0;\n      }\n\n      const padding = stringTimesN(pad, indentString);\n      formatted += padding + line + newline; // eslint-disable-line prefer-template\n      pad += indent;\n    });\n\n  return formatted.trim();\n}\n"]},"metadata":{},"sourceType":"script"}