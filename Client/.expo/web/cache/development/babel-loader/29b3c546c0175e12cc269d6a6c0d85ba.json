{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction normalizePaths(initial, transformString) {\n  if (initial == null) {\n    return initial;\n  } else if (initial instanceof RegExp) {\n    return initial;\n  } else if (typeof initial === 'string') {\n    return transformString(initial);\n  } else if (Array.isArray(initial)) {\n    return initial.map(function (value) {\n      return normalizePaths(value, transformString);\n    });\n  } else if (typeof initial === 'object') {\n    var result = {};\n\n    for (var _i = 0, _Object$keys = Object.keys(initial); _i < _Object$keys.length; _i++) {\n      var prop = _Object$keys[_i];\n      result[prop] = normalizePaths(initial[prop], transformString);\n    }\n\n    return result;\n  } else {\n    return initial;\n  }\n}\n\nexports.default = normalizePaths;","map":{"version":3,"sources":["../../src/utils/normalizePaths.ts"],"names":[],"mappings":";;;;;;AAOA,SAAwB,cAAxB,CACE,OADF,EAEE,eAFF,EAE4C;AAE1C,MAAI,OAAO,IAAI,IAAf,EAAqB;AACnB,WAAO,OAAP;AACD,GAFD,MAEO,IAAI,OAAO,YAAY,MAAvB,EAA+B;AACpC,WAAO,OAAP;AACD,GAFM,MAEA,IAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AACtC,WAAO,eAAe,CAAC,OAAD,CAAtB;AACD,GAFM,MAEA,IAAI,KAAK,CAAC,OAAN,CAAc,OAAd,CAAJ,EAA4B;AACjC,WAAO,OAAO,CAAC,GAAR,CAAY,UAAA,KAAK;AAAA,aAAI,cAAc,CAAC,KAAD,EAAQ,eAAR,CAAlB;AAAA,KAAjB,CAAP;AACD,GAFM,MAEA,IAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AACtC,QAAM,MAAM,GAA2B,EAAvC;;AACA,oCAAmB,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAnB,kCAAyC;AAApC,UAAM,IAAI,mBAAV;AACH,MAAA,MAAM,CAAC,IAAD,CAAN,GAAe,cAAc,CAAC,OAAO,CAAC,IAAD,CAAR,EAAgB,eAAhB,CAA7B;AACD;;AACD,WAAO,MAAP;AACD,GANM,MAMA;AACL,WAAO,OAAP;AACD;AACF;;AArBD,OAAA,CAAA,OAAA,GAAA,cAAA","sourcesContent":["/**\n * Converts absolute paths to relative paths for testing purposes.\n *\n * @param initial\n * @param transformString\n * @internal\n */\nexport default function normalizePaths(\n  initial: any,\n  transformString: (value: string) => string\n): any {\n  if (initial == null) {\n    return initial;\n  } else if (initial instanceof RegExp) {\n    return initial;\n  } else if (typeof initial === 'string') {\n    return transformString(initial);\n  } else if (Array.isArray(initial)) {\n    return initial.map(value => normalizePaths(value, transformString));\n  } else if (typeof initial === 'object') {\n    const result: { [key: string]: any } = {};\n    for (const prop of Object.keys(initial)) {\n      result[prop] = normalizePaths(initial[prop], transformString);\n    }\n    return result;\n  } else {\n    return initial;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}