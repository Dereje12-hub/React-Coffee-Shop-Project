{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _excluded = [\"nextMod\"],\n    _excluded2 = [\"modRequest\"],\n    _excluded3 = [\"modName\"],\n    _excluded4 = [\"platform\", \"providers\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createBaseMod = createBaseMod;\nexports.assertModResults = assertModResults;\nexports.createPlatformBaseMod = createPlatformBaseMod;\nexports.provider = provider;\nexports.withGeneratedBaseMods = withGeneratedBaseMods;\n\nfunction _debug() {\n  var data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function _debug() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _withMod() {\n  var data = require(\"./withMod\");\n\n  _withMod = function _withMod() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar debug = (0, _debug().default)('config-plugins:base-mods');\n\nfunction createBaseMod(_ref) {\n  var methodName = _ref.methodName,\n      platform = _ref.platform,\n      modName = _ref.modName,\n      getFilePath = _ref.getFilePath,\n      read = _ref.read,\n      write = _ref.write,\n      isIntrospective = _ref.isIntrospective;\n\n  var withUnknown = function withUnknown(config, _props) {\n    var _props$skipEmptyMod, _props$saveToInternal;\n\n    var props = _props || {};\n    return (0, _withMod().withBaseMod)(config, {\n      platform: platform,\n      mod: modName,\n      skipEmptyMod: (_props$skipEmptyMod = props.skipEmptyMod) !== null && _props$skipEmptyMod !== void 0 ? _props$skipEmptyMod : true,\n      saveToInternal: (_props$saveToInternal = props.saveToInternal) !== null && _props$saveToInternal !== void 0 ? _props$saveToInternal : false,\n      isProvider: true,\n      isIntrospective: isIntrospective,\n      action: function action(_ref2) {\n        return function _callee() {\n          var _ref2$modRequest, nextMod, modRequest, config, results, filePath, modResults;\n\n          return _regeneratorRuntime.async(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _ref2$modRequest = _ref2.modRequest, nextMod = _ref2$modRequest.nextMod, modRequest = _objectWithoutProperties(_ref2$modRequest, _excluded), config = _objectWithoutProperties(_ref2, _excluded2);\n                  _context.prev = 1;\n                  results = _objectSpread(_objectSpread({}, config), {}, {\n                    modRequest: modRequest\n                  });\n                  _context.next = 5;\n                  return _regeneratorRuntime.awrap(getFilePath(results, props));\n\n                case 5:\n                  filePath = _context.sent;\n                  debug(\"mods.\" + platform + \".\" + modName + \": file path: \" + (filePath || '[skipped]'));\n                  _context.next = 9;\n                  return _regeneratorRuntime.awrap(read(filePath, results, props));\n\n                case 9:\n                  modResults = _context.sent;\n                  _context.next = 12;\n                  return _regeneratorRuntime.awrap(nextMod(_objectSpread(_objectSpread({}, results), {}, {\n                    modResults: modResults,\n                    modRequest: modRequest\n                  })));\n\n                case 12:\n                  results = _context.sent;\n                  assertModResults(results, modRequest.platform, modRequest.modName);\n                  _context.next = 16;\n                  return _regeneratorRuntime.awrap(write(filePath, results, props));\n\n                case 16:\n                  return _context.abrupt(\"return\", results);\n\n                case 19:\n                  _context.prev = 19;\n                  _context.t0 = _context[\"catch\"](1);\n                  _context.t0.message = \"[\" + platform + \".\" + modName + \"]: \" + methodName + \": \" + _context.t0.message;\n                  throw _context.t0;\n\n                case 23:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, null, null, [[1, 19]], Promise);\n        }();\n      }\n    });\n  };\n\n  if (methodName) {\n    Object.defineProperty(withUnknown, 'name', {\n      value: methodName\n    });\n  }\n\n  return withUnknown;\n}\n\nfunction assertModResults(results, platformName, modName) {\n  var ensuredResults = results;\n\n  if (!ensuredResults || typeof ensuredResults !== 'object' || !(ensuredResults !== null && ensuredResults !== void 0 && ensuredResults.mods)) {\n    throw new Error(\"Mod `mods.\" + platformName + \".\" + modName + \"` evaluated to an object that is not a valid project config. Instead got: \" + JSON.stringify(ensuredResults));\n  }\n\n  return ensuredResults;\n}\n\nfunction upperFirst(name) {\n  return name.charAt(0).toUpperCase() + name.slice(1);\n}\n\nfunction createPlatformBaseMod(_ref3) {\n  var modName = _ref3.modName,\n      props = _objectWithoutProperties(_ref3, _excluded3);\n\n  var methodName = \"with\" + upperFirst(props.platform) + upperFirst(modName) + \"BaseMod\";\n  return createBaseMod(_objectSpread({\n    methodName: methodName,\n    modName: modName\n  }, props));\n}\n\nfunction provider(props) {\n  return props;\n}\n\nfunction withGeneratedBaseMods(config, _ref4) {\n  var platform = _ref4.platform,\n      providers = _ref4.providers,\n      props = _objectWithoutProperties(_ref4, _excluded4);\n\n  return Object.entries(providers).reduce(function (config, _ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n        modName = _ref6[0],\n        value = _ref6[1];\n\n    var baseMod = createPlatformBaseMod(_objectSpread({\n      platform: platform,\n      modName: modName\n    }, value));\n    return baseMod(config, props);\n  }, config);\n}","map":{"version":3,"sources":["../../src/plugins/createBaseMod.ts"],"names":["debug","isIntrospective","withUnknown","props","_props","platform","mod","skipEmptyMod","saveToInternal","isProvider","modRequest","config","results","filePath","getFilePath","modName","modResults","read","nextMod","assertModResults","write","error","methodName","Object","value","ensuredResults","platformName","JSON","name","upperFirst","createBaseMod","baseMod","createPlatformBaseMod"],"mappings":"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","sourcesContent":["import Debug from 'debug';\n\nimport {\n  ConfigPlugin,\n  ExportedConfig,\n  ExportedConfigWithProps,\n  ModPlatform,\n} from '../Plugin.types';\nimport { BaseModOptions, withBaseMod } from './withMod';\n\nconst debug = Debug('config-plugins:base-mods');\n\nexport type ForwardedBaseModOptions = Partial<\n  Pick<BaseModOptions, 'saveToInternal' | 'skipEmptyMod'>\n>;\n\nexport type BaseModProviderMethods<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n> = {\n  getFilePath: (config: ExportedConfigWithProps<ModType>, props: Props) => Promise<string> | string;\n  read: (\n    filePath: string,\n    config: ExportedConfigWithProps<ModType>,\n    props: Props\n  ) => Promise<ModType> | ModType;\n  write: (\n    filePath: string,\n    config: ExportedConfigWithProps<ModType>,\n    props: Props\n  ) => Promise<void> | void;\n  /**\n   * If the mod supports introspection, and avoids making any filesystem modifications during compilation.\n   * By enabling, this mod, and all of its descendants will be run in introspection mode.\n   * This should only be used for static files like JSON or XML, and not for application files that require regexes,\n   * or complex static files that require other files to be generated like Xcode `.pbxproj`.\n   */\n  isIntrospective?: boolean;\n};\n\nexport type CreateBaseModProps<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n> = {\n  methodName: string;\n  platform: ModPlatform;\n  modName: string;\n} & BaseModProviderMethods<ModType, Props>;\n\nexport function createBaseMod<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n>({\n  methodName,\n  platform,\n  modName,\n  getFilePath,\n  read,\n  write,\n  isIntrospective,\n}: CreateBaseModProps<ModType, Props>): ConfigPlugin<Props | void> {\n  const withUnknown: ConfigPlugin<Props | void> = (config, _props) => {\n    const props = _props || ({} as Props);\n    return withBaseMod<ModType>(config, {\n      platform,\n      mod: modName,\n      skipEmptyMod: props.skipEmptyMod ?? true,\n      saveToInternal: props.saveToInternal ?? false,\n      isProvider: true,\n      isIntrospective,\n      async action({ modRequest: { nextMod, ...modRequest }, ...config }) {\n        try {\n          let results: ExportedConfigWithProps<ModType> = {\n            ...config,\n            modRequest,\n          };\n\n          const filePath = await getFilePath(results, props);\n          debug(`mods.${platform}.${modName}: file path: ${filePath || '[skipped]'}`);\n          const modResults = await read(filePath, results, props);\n\n          results = await nextMod!({\n            ...results,\n            modResults,\n            modRequest,\n          });\n\n          assertModResults(results, modRequest.platform, modRequest.modName);\n\n          await write(filePath, results, props);\n          return results;\n        } catch (error: any) {\n          error.message = `[${platform}.${modName}]: ${methodName}: ${error.message}`;\n          throw error;\n        }\n      },\n    });\n  };\n\n  if (methodName) {\n    Object.defineProperty(withUnknown, 'name', {\n      value: methodName,\n    });\n  }\n\n  return withUnknown;\n}\n\nexport function assertModResults(results: any, platformName: string, modName: string) {\n  // If the results came from a mod, they'd be in the form of [config, data].\n  // Ensure the results are an array and omit the data since it should've been written by a data provider plugin.\n  const ensuredResults = results;\n\n  // Sanity check to help locate non compliant mods.\n  if (!ensuredResults || typeof ensuredResults !== 'object' || !ensuredResults?.mods) {\n    throw new Error(\n      `Mod \\`mods.${platformName}.${modName}\\` evaluated to an object that is not a valid project config. Instead got: ${JSON.stringify(\n        ensuredResults\n      )}`\n    );\n  }\n  return ensuredResults;\n}\n\nfunction upperFirst(name: string): string {\n  return name.charAt(0).toUpperCase() + name.slice(1);\n}\n\nexport function createPlatformBaseMod<\n  ModType,\n  Props extends ForwardedBaseModOptions = ForwardedBaseModOptions\n>({ modName, ...props }: Omit<CreateBaseModProps<ModType, Props>, 'methodName'>) {\n  // Generate the function name to ensure it's uniform and also to improve stack traces.\n  const methodName = `with${upperFirst(props.platform)}${upperFirst(modName)}BaseMod`;\n  return createBaseMod<ModType, Props>({\n    methodName,\n    modName,\n    ...props,\n  });\n}\n\n/** A TS wrapper for creating provides */\nexport function provider<ModType, Props extends ForwardedBaseModOptions = ForwardedBaseModOptions>(\n  props: BaseModProviderMethods<ModType, Props>\n) {\n  return props;\n}\n\n/** Plugin to create and append base mods from file providers */\nexport function withGeneratedBaseMods<ModName extends string>(\n  config: ExportedConfig,\n  {\n    platform,\n    providers,\n    ...props\n  }: ForwardedBaseModOptions & {\n    platform: ModPlatform;\n    providers: Partial<Record<ModName, BaseModProviderMethods<any, any>>>;\n  }\n): ExportedConfig {\n  return Object.entries(providers).reduce((config, [modName, value]) => {\n    const baseMod = createPlatformBaseMod({ platform, modName, ...(value as any) });\n    return baseMod(config, props);\n  }, config);\n}\n"]},"metadata":{},"sourceType":"script"}