{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteralLoose = require(\"@babel/runtime/helpers/taggedTemplateLiteralLoose\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _templateObject;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loaders = exports.createMultiRuleTransformer = void 0;\n\nvar chalk_1 = __importDefault(require(\"chalk\"));\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar resolve_from_1 = __importDefault(require(\"resolve-from\"));\n\nvar generateFunctionMap_1 = require(\"./generateFunctionMap\");\n\nvar getBabelConfig_1 = require(\"./getBabelConfig\");\n\nvar debug = debug_1.default('expo:metro:exotic-babel-transformer');\nvar babelCore;\n\nfunction getBabelCoreFromProject(projectRoot) {\n  if (babelCore) return babelCore;\n  babelCore = require(resolve_from_1.default(projectRoot, '@babel/core'));\n  return babelCore;\n}\n\nvar babelParser;\n\nfunction getBabelParserFromProject(projectRoot) {\n  if (babelParser) return babelParser;\n  babelParser = require(resolve_from_1.default(projectRoot, '@babel/parser'));\n  return babelParser;\n}\n\nfunction sucrase(args, _ref) {\n  var transforms = _ref.transforms;\n  var src = args.src,\n      filename = args.filename,\n      dev = args.options.dev;\n\n  var _require = require('sucrase'),\n      transform = _require.transform;\n\n  var results = transform(src, {\n    filePath: filename,\n    production: !dev,\n    transforms: transforms\n  });\n  return {\n    code: results.code,\n    functionMap: null\n  };\n}\n\nvar getExpensiveSucraseTransforms = function getExpensiveSucraseTransforms(filename) {\n  return ['jsx', 'imports', /\\.tsx?$/.test(filename) ? 'typescript' : 'flow'];\n};\n\nfunction parseAst(projectRoot, sourceCode) {\n  var babylon = getBabelParserFromProject(projectRoot);\n  return babylon.parse(sourceCode, {\n    sourceType: 'unambiguous'\n  });\n}\n\nfunction createMultiRuleTransformer(_ref2) {\n  var getRuleType = _ref2.getRuleType,\n      rules = _ref2.rules;\n  return function transform(args) {\n    var filename = args.filename,\n        options = args.options;\n    var OLD_BABEL_ENV = process.env.BABEL_ENV;\n    process.env.BABEL_ENV = (options === null || options === void 0 ? void 0 : options.dev) ? 'development' : process.env.BABEL_ENV || 'production';\n\n    try {\n      var ruleType = getRuleType(args);\n\n      for (var _iterator = _createForOfIteratorHelperLoose(rules), _step; !(_step = _iterator()).done;) {\n        var rule = _step.value;\n\n        if (rule.type && rule.type !== ruleType) {\n          continue;\n        }\n\n        var isMatched = typeof rule.test === 'function' ? rule.test(args) : rule.test.test(args.filename);\n\n        if (isMatched) {\n          var results = rule.transform(args);\n          results._ruleName = rule.name;\n\n          if (results.code && !results.ast) {\n            results.ast = parseAst(options === null || options === void 0 ? void 0 : options.projectRoot, results.code);\n          }\n\n          return results;\n        }\n      }\n\n      throw new Error('no loader rule to handle file: ' + filename);\n    } finally {\n      if (OLD_BABEL_ENV) {\n        process.env.BABEL_ENV = OLD_BABEL_ENV;\n      }\n    }\n  };\n}\n\nexports.createMultiRuleTransformer = createMultiRuleTransformer;\nexports.loaders = {\n  app: function app(args) {\n    debug('app:', args.filename);\n    var filename = args.filename,\n        options = args.options,\n        src = args.src,\n        plugins = args.plugins;\n\n    var babelConfig = _objectSpread(_objectSpread({\n      sourceType: 'unambiguous'\n    }, getBabelConfig_1.getBabelConfig(filename, options, plugins)), {}, {\n      caller: {\n        name: 'metro',\n        platform: options.platform\n      },\n      ast: true\n    });\n\n    Object.defineProperty(babelConfig.caller, 'onWarning', {\n      enumerable: false,\n      writable: false,\n      value: babelConfig.caller.onWarning = function (msg) {\n        console.warn(chalk_1.default.bold.yellow(_templateObject || (_templateObject = _taggedTemplateLiteralLoose([\"warn \"]))) + args.filename);\n        console.warn(msg);\n      }\n    });\n\n    var _getBabelCoreFromProj = getBabelCoreFromProject(options.projectRoot),\n        parseSync = _getBabelCoreFromProj.parseSync,\n        transformFromAstSync = _getBabelCoreFromProj.transformFromAstSync;\n\n    var sourceAst = parseSync(src, babelConfig);\n    if (!sourceAst) return {\n      ast: null\n    };\n    var result = transformFromAstSync(sourceAst, src, babelConfig);\n    var functionMap = generateFunctionMap_1.generateFunctionMap(options.projectRoot, sourceAst, {\n      filename: filename\n    });\n\n    if (!result) {\n      return {\n        ast: null,\n        functionMap: functionMap\n      };\n    }\n\n    return {\n      ast: result.ast,\n      functionMap: functionMap\n    };\n  },\n  reactNativeModule: function reactNativeModule(args) {\n    debug('rn:', args.filename);\n    return sucrase(args, {\n      transforms: ['jsx', 'flow', 'imports']\n    });\n  },\n  expoModule: function expoModule(args) {\n    debug('expo:', args.filename);\n    return sucrase(args, {\n      transforms: ['imports', /(expo-processing|expo\\/vector-icons)/.test(args.filename) && 'jsx', /(expo-asset-utils)/.test(args.filename) && 'flow'].filter(Boolean)\n    });\n  },\n  untranspiledModule: function untranspiledModule(args) {\n    debug('known issues:', args.filename);\n    return sucrase(args, {\n      transforms: getExpensiveSucraseTransforms(args.filename)\n    });\n  },\n  passthroughModule: function passthroughModule(args) {\n    var filename = args.filename,\n        options = args.options,\n        src = args.src;\n    debug('passthrough:', filename);\n    var ast = parseAst(options.projectRoot, src);\n    var functionMap = generateFunctionMap_1.generateFunctionMap(options.projectRoot, ast, {\n      filename: filename\n    });\n    return {\n      code: src,\n      functionMap: functionMap,\n      ast: ast\n    };\n  }\n};","map":{"version":3,"sources":["../../src/transformer/createMultiRuleTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2021-present 650 Industries (Expo). All rights reserved.\n\nimport chalk from 'chalk';\nimport Debug from 'debug';\nimport type { BabelTransformer, BabelTransformerArgs } from 'metro-babel-transformer';\nimport resolveFrom from 'resolve-from';\n\nimport { generateFunctionMap } from './generateFunctionMap';\nimport { getBabelConfig } from './getBabelConfig';\n\nconst debug = Debug('expo:metro:exotic-babel-transformer');\n\nlet babelCore: typeof import('@babel/core') | undefined;\n\nfunction getBabelCoreFromProject(projectRoot: string) {\n  if (babelCore) return babelCore;\n  babelCore = require(resolveFrom(projectRoot, '@babel/core'));\n  return babelCore!;\n}\n\nlet babelParser: typeof import('@babel/parser') | undefined;\n\nfunction getBabelParserFromProject(projectRoot: string) {\n  if (babelParser) return babelParser;\n  babelParser = require(resolveFrom(projectRoot, '@babel/parser'));\n  return babelParser!;\n}\n\nfunction sucrase(\n  args: BabelTransformerArgs,\n  {\n    transforms,\n  }: {\n    transforms: string[];\n  }\n): Partial<ReturnType<BabelTransformer['transform']>> {\n  const {\n    src,\n    filename,\n    options: { dev },\n  } = args;\n  const { transform } = require('sucrase');\n\n  const results = transform(src, {\n    filePath: filename,\n    production: !dev,\n    transforms,\n  });\n\n  return {\n    code: results.code,\n    functionMap: null,\n  };\n}\n\nconst getExpensiveSucraseTransforms = (filename: string) => [\n  'jsx',\n  'imports',\n  /\\.tsx?$/.test(filename) ? 'typescript' : 'flow',\n];\n\nfunction parseAst(projectRoot: string, sourceCode: string) {\n  const babylon = getBabelParserFromProject(projectRoot);\n\n  return babylon.parse(sourceCode, {\n    sourceType: 'unambiguous',\n  });\n}\n\nexport type Rule = {\n  warn?: boolean;\n  type?: 'module' | 'app';\n  name?: string;\n  test: ((args: BabelTransformerArgs) => boolean) | RegExp;\n  transform: BabelTransformer['transform'];\n};\n\n/** Create a transformer that emulates Webpack's loader system. */\nexport function createMultiRuleTransformer({\n  getRuleType,\n  rules,\n}: {\n  getRuleType: (args: BabelTransformerArgs) => string;\n  rules: Rule[];\n}): BabelTransformer['transform'] {\n  // const warnings: string[] = [];\n  return function transform(args: BabelTransformerArgs) {\n    const { filename, options } = args;\n    const OLD_BABEL_ENV = process.env.BABEL_ENV;\n    process.env.BABEL_ENV = options?.dev ? 'development' : process.env.BABEL_ENV || 'production';\n\n    try {\n      const ruleType = getRuleType(args);\n\n      for (const rule of rules) {\n        // optimization for checking node modules\n        if (rule.type && rule.type !== ruleType) {\n          continue;\n        }\n\n        const isMatched =\n          typeof rule.test === 'function' ? rule.test(args) : rule.test.test(args.filename);\n        if (isMatched) {\n          const results = rule.transform(args);\n          // @ts-ignore: Add extra property for testing\n          results._ruleName = rule.name;\n          // Perform a basic parse if none exists, this enables us to control the output, but only if it changed.\n          if (results.code && !results.ast) {\n            // Parse AST with babel otherwise Metro transformer will throw away the returned results.\n            results.ast = parseAst(options?.projectRoot, results.code);\n          }\n\n          // TODO: Suboptimal warnings\n          // if (rule.warn) {\n          //   const matchName =\n          //     filename.match(/node_modules\\/((:?@[\\w\\d-]+\\/[\\w\\d-]+)|(:?[\\w\\d-]+))\\/?/)?.[1] ??\n          //     filename;\n          //   if (matchName && !warnings.includes(matchName)) {\n          //     warnings.push(matchName);\n          //     console.warn(chalk.yellow.bold`warn `, matchName);\n          //     console.warn(\n          //       chalk.yellow`untranspiled module is potentially causing bundler slowdown, using modules that support commonjs will make your dev server much faster.`\n          //     );\n          //   }\n          // }\n\n          return results;\n        }\n      }\n      throw new Error('no loader rule to handle file: ' + filename);\n    } finally {\n      if (OLD_BABEL_ENV) {\n        process.env.BABEL_ENV = OLD_BABEL_ENV;\n      }\n    }\n  };\n}\n\nexport const loaders: Record<string, (args: BabelTransformerArgs) => any> = {\n  // Perform the standard, and most expensive transpilation sequence.\n  app(args) {\n    debug('app:', args.filename);\n\n    const { filename, options, src, plugins } = args;\n    const babelConfig = {\n      // ES modules require sourceType='module' but OSS may not always want that\n      sourceType: 'unambiguous',\n      ...getBabelConfig(filename, options, plugins),\n      // Variables that are exposed to the user's babel preset.\n      caller: {\n        name: 'metro',\n\n        platform: options.platform,\n      },\n      ast: true,\n    };\n\n    // Surface a warning function so babel linters can be used.\n    Object.defineProperty(babelConfig.caller, 'onWarning', {\n      enumerable: false,\n      writable: false,\n      value: (babelConfig.caller.onWarning = function (msg: any) {\n        // Format the file path first so users know where the warning came from.\n        console.warn(chalk.bold.yellow`warn ` + args.filename);\n        console.warn(msg);\n      }),\n    });\n\n    const { parseSync, transformFromAstSync } = getBabelCoreFromProject(options.projectRoot);\n    const sourceAst = parseSync(src, babelConfig);\n\n    // Should never happen.\n    if (!sourceAst) return { ast: null };\n\n    const result = transformFromAstSync(sourceAst, src, babelConfig);\n\n    // TODO: Disable by default\n    const functionMap = generateFunctionMap(options.projectRoot, sourceAst, { filename });\n    // The result from `transformFromAstSync` can be null (if the file is ignored)\n    if (!result) {\n      return { ast: null, functionMap };\n    }\n\n    return { ast: result.ast, functionMap };\n  },\n\n  // Transpile react-native with sucrase.\n  reactNativeModule(args) {\n    debug('rn:', args.filename);\n    return sucrase(args, {\n      transforms: ['jsx', 'flow', 'imports'],\n    });\n  },\n\n  // Transpile expo modules with sucrase.\n  expoModule(args) {\n    debug('expo:', args.filename);\n    // TODO: Fix all expo packages\n    return sucrase(args, {\n      transforms: [\n        'imports',\n        // TODO: fix expo-processing, expo/vector-icons\n        /(expo-processing|expo\\/vector-icons)/.test(args.filename) && 'jsx',\n        // TODO: fix expo-asset-utils\n        /(expo-asset-utils)/.test(args.filename) && 'flow',\n      ].filter(Boolean) as string[],\n    });\n  },\n\n  // Transpile known community modules with the most expensive sucrase\n  untranspiledModule(args) {\n    debug('known issues:', args.filename);\n    return sucrase(args, {\n      transforms: getExpensiveSucraseTransforms(args.filename),\n    });\n  },\n\n  // Pass all modules through without transpiling them.\n  passthroughModule(args) {\n    const { filename, options, src } = args;\n    debug('passthrough:', filename);\n\n    // Perform a basic ast parse, this doesn't matter since the worker will parse and ignore anyways.\n    const ast = parseAst(options.projectRoot, src);\n\n    // TODO: Disable by default\n    const functionMap = generateFunctionMap(options.projectRoot, ast, { filename });\n\n    return {\n      code: src,\n      functionMap,\n      ast,\n    };\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}