{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _taggedTemplateLiteralLoose = require(\"@babel/runtime/helpers/taggedTemplateLiteralLoose\");\n\nvar _templateObject, _templateObject2;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) {\n    if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDevServerMiddleware = exports.LogReporter = exports.attachInspectorProxy = exports.bundleAsync = exports.runMetroDevServerAsync = void 0;\n\nvar config_1 = require(\"@expo/config\");\n\nvar chalk_1 = __importDefault(require(\"chalk\"));\n\nvar HermesBundler_1 = require(\"./HermesBundler\");\n\nvar LogReporter_1 = __importDefault(require(\"./LogReporter\"));\n\nexports.LogReporter = LogReporter_1.default;\n\nvar createDevServerAsync_1 = require(\"./metro/createDevServerAsync\");\n\nvar importMetroFromProject_1 = require(\"./metro/importMetroFromProject\");\n\nvar devServerMiddleware_1 = require(\"./middleware/devServerMiddleware\");\n\nObject.defineProperty(exports, \"createDevServerMiddleware\", {\n  enumerable: true,\n  get: function get() {\n    return devServerMiddleware_1.createDevServerMiddleware;\n  }\n});\n\nfunction getExpoMetroConfig(projectRoot, _ref) {\n  var logger = _ref.logger,\n      unversioned = _ref.unversioned;\n\n  if (!unversioned) {\n    try {\n      return importMetroFromProject_1.importExpoMetroConfigFromProject(projectRoot);\n    } catch (_unused) {}\n  }\n\n  var unversionedVersion = require('@expo/metro-config/package.json').version;\n\n  logger.info({\n    tag: 'expo'\n  }, chalk_1.default.gray(\"\\u203A Unversioned \" + chalk_1.default.bold(_templateObject || (_templateObject = _taggedTemplateLiteralLoose([\"@expo/metro-config@\", \"\"])), unversionedVersion) + \" is being used. Bundling apps may not work as expected, and is subject to breaking changes. Install \" + chalk_1.default.bold(_templateObject2 || (_templateObject2 = _taggedTemplateLiteralLoose([\"expo\"]))) + \" or set the app.json sdkVersion to use a stable version of @expo/metro-config.\"));\n  return require('@expo/metro-config');\n}\n\nfunction runMetroDevServerAsync(projectRoot, options) {\n  var reporter, ExpoMetroConfig, metroConfig, _devServerMiddleware_, middleware, attachToServer, customEnhanceMiddleware, _await$createDevServe, server, _attachToServer, messageSocket, eventsSocket;\n\n  return _regeneratorRuntime.async(function runMetroDevServerAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          reporter = new LogReporter_1.default(options.logger);\n          ExpoMetroConfig = getExpoMetroConfig(projectRoot, options);\n          _context.next = 4;\n          return _regeneratorRuntime.awrap(ExpoMetroConfig.loadAsync(projectRoot, _objectSpread({\n            reporter: reporter\n          }, options)));\n\n        case 4:\n          metroConfig = _context.sent;\n          _devServerMiddleware_ = devServerMiddleware_1.createDevServerMiddleware({\n            port: metroConfig.server.port,\n            watchFolders: metroConfig.watchFolders,\n            logger: options.logger\n          }), middleware = _devServerMiddleware_.middleware, attachToServer = _devServerMiddleware_.attachToServer;\n          customEnhanceMiddleware = metroConfig.server.enhanceMiddleware;\n\n          metroConfig.server.enhanceMiddleware = function (metroMiddleware, server) {\n            if (customEnhanceMiddleware) {\n              metroMiddleware = customEnhanceMiddleware(metroMiddleware, server);\n            }\n\n            return middleware.use(metroMiddleware);\n          };\n\n          _context.next = 10;\n          return _regeneratorRuntime.awrap(createDevServerAsync_1.createDevServerAsync(projectRoot, {\n            config: metroConfig,\n            logger: options.logger\n          }));\n\n        case 10:\n          _await$createDevServe = _context.sent;\n          server = _await$createDevServe.server;\n          _attachToServer = attachToServer(server), messageSocket = _attachToServer.messageSocket, eventsSocket = _attachToServer.eventsSocket;\n          reporter.reportEvent = eventsSocket.reportEvent;\n          return _context.abrupt(\"return\", {\n            server: server,\n            middleware: middleware,\n            messageSocket: messageSocket\n          });\n\n        case 15:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexports.runMetroDevServerAsync = runMetroDevServerAsync;\nvar nextBuildID = 0;\n\nfunction bundleAsync(projectRoot, expoConfig, options, bundles) {\n  var metro, Server, reporter, ExpoMetroConfig, config, buildID, metroServer, buildAsync, maybeAddHermesBundleAsync, intermediateOutputs, bundleOutputs, i;\n  return _regeneratorRuntime.async(function bundleAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          metro = importMetroFromProject_1.importMetroFromProject(projectRoot);\n          Server = importMetroFromProject_1.importMetroServerFromProject(projectRoot);\n          reporter = new LogReporter_1.default(options.logger);\n          ExpoMetroConfig = getExpoMetroConfig(projectRoot, options);\n          _context4.next = 6;\n          return _regeneratorRuntime.awrap(ExpoMetroConfig.loadAsync(projectRoot, _objectSpread({\n            reporter: reporter\n          }, options)));\n\n        case 6:\n          config = _context4.sent;\n          buildID = \"bundle_\" + nextBuildID++;\n          _context4.next = 10;\n          return _regeneratorRuntime.awrap(metro.runMetro(config, {\n            watch: false\n          }));\n\n        case 10:\n          metroServer = _context4.sent;\n\n          buildAsync = function buildAsync(bundle) {\n            var _a, _b, _c, _d, bundleOptions, _await$metroServer$bu, code, map, assets;\n\n            return _regeneratorRuntime.async(function buildAsync$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    bundleOptions = _objectSpread(_objectSpread({}, Server.DEFAULT_BUNDLE_OPTIONS), {}, {\n                      bundleType: 'bundle',\n                      platform: bundle.platform,\n                      entryFile: bundle.entryPoint,\n                      dev: (_a = bundle.dev) !== null && _a !== void 0 ? _a : false,\n                      minify: (_b = bundle.minify) !== null && _b !== void 0 ? _b : !bundle.dev,\n                      inlineSourceMap: false,\n                      sourceMapUrl: bundle.sourceMapUrl,\n                      createModuleIdFactory: config.serializer.createModuleIdFactory,\n                      onProgress: function onProgress(transformedFileCount, totalFileCount) {\n                        if (!options.quiet) {\n                          reporter.update({\n                            buildID: buildID,\n                            type: 'bundle_transform_progressed',\n                            transformedFileCount: transformedFileCount,\n                            totalFileCount: totalFileCount\n                          });\n                        }\n                      }\n                    });\n                    reporter.update({\n                      buildID: buildID,\n                      type: 'bundle_build_started',\n                      bundleDetails: {\n                        bundleType: bundleOptions.bundleType,\n                        platform: bundle.platform,\n                        entryFile: bundle.entryPoint,\n                        dev: (_c = bundle.dev) !== null && _c !== void 0 ? _c : false,\n                        minify: (_d = bundle.minify) !== null && _d !== void 0 ? _d : false\n                      }\n                    });\n                    _context2.next = 4;\n                    return _regeneratorRuntime.awrap(metroServer.build(bundleOptions));\n\n                  case 4:\n                    _await$metroServer$bu = _context2.sent;\n                    code = _await$metroServer$bu.code;\n                    map = _await$metroServer$bu.map;\n                    _context2.next = 9;\n                    return _regeneratorRuntime.awrap(metroServer.getAssets(bundleOptions));\n\n                  case 9:\n                    assets = _context2.sent;\n                    reporter.update({\n                      buildID: buildID,\n                      type: 'bundle_build_done'\n                    });\n                    return _context2.abrupt(\"return\", {\n                      code: code,\n                      map: map,\n                      assets: assets\n                    });\n\n                  case 12:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          };\n\n          maybeAddHermesBundleAsync = function maybeAddHermesBundleAsync(bundle, bundleOutput) {\n            var _a, _b, platform, isHermesManaged, paths, configFilePath, platformTag, hermesBundleOutput;\n\n            return _regeneratorRuntime.async(function maybeAddHermesBundleAsync$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    platform = bundle.platform;\n                    isHermesManaged = HermesBundler_1.isEnableHermesManaged(expoConfig, platform);\n                    paths = config_1.getConfigFilePaths(projectRoot);\n                    configFilePath = (_b = (_a = paths.dynamicConfigPath) !== null && _a !== void 0 ? _a : paths.staticConfigPath) !== null && _b !== void 0 ? _b : 'app.json';\n                    _context3.next = 6;\n                    return _regeneratorRuntime.awrap(HermesBundler_1.maybeThrowFromInconsistentEngineAsync(projectRoot, configFilePath, platform, isHermesManaged));\n\n                  case 6:\n                    if (!isHermesManaged) {\n                      _context3.next = 14;\n                      break;\n                    }\n\n                    platformTag = chalk_1.default.bold({\n                      ios: 'iOS',\n                      android: 'Android',\n                      web: 'Web'\n                    }[platform] || platform);\n                    options.logger.info({\n                      tag: 'expo'\n                    }, \"\\uD83D\\uDCBF \" + platformTag + \" Building Hermes bytecode for the bundle\");\n                    _context3.next = 11;\n                    return _regeneratorRuntime.awrap(HermesBundler_1.buildHermesBundleAsync(projectRoot, bundleOutput.code, bundleOutput.map, bundle.minify));\n\n                  case 11:\n                    hermesBundleOutput = _context3.sent;\n                    bundleOutput.hermesBytecodeBundle = hermesBundleOutput.hbc;\n                    bundleOutput.hermesSourcemap = hermesBundleOutput.sourcemap;\n\n                  case 14:\n                    return _context3.abrupt(\"return\", bundleOutput);\n\n                  case 15:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, null, null, null, Promise);\n          };\n\n          _context4.prev = 13;\n          _context4.next = 16;\n          return _regeneratorRuntime.awrap(Promise.all(bundles.map(function (bundle) {\n            return buildAsync(bundle);\n          })));\n\n        case 16:\n          intermediateOutputs = _context4.sent;\n          bundleOutputs = [];\n          i = 0;\n\n        case 19:\n          if (!(i < bundles.length)) {\n            _context4.next = 28;\n            break;\n          }\n\n          _context4.t0 = bundleOutputs;\n          _context4.next = 23;\n          return _regeneratorRuntime.awrap(maybeAddHermesBundleAsync(bundles[i], intermediateOutputs[i]));\n\n        case 23:\n          _context4.t1 = _context4.sent;\n\n          _context4.t0.push.call(_context4.t0, _context4.t1);\n\n        case 25:\n          ++i;\n          _context4.next = 19;\n          break;\n\n        case 28:\n          return _context4.abrupt(\"return\", bundleOutputs);\n\n        case 29:\n          _context4.prev = 29;\n          metroServer.end();\n          return _context4.finish(29);\n\n        case 32:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[13,, 29, 32]], Promise);\n}\n\nexports.bundleAsync = bundleAsync;\n\nfunction attachInspectorProxy(projectRoot, _ref2) {\n  var server = _ref2.server,\n      middleware = _ref2.middleware;\n\n  var _importMetroFromProje = importMetroFromProject_1.importInspectorProxyServerFromProject(projectRoot),\n      InspectorProxy = _importMetroFromProje.InspectorProxy;\n\n  var inspectorProxy = new InspectorProxy(projectRoot);\n\n  if ('addWebSocketListener' in inspectorProxy) {\n    inspectorProxy.addWebSocketListener(server);\n  } else if ('createWebSocketListeners' in inspectorProxy) {\n    inspectorProxy.createWebSocketListeners(server);\n  }\n\n  middleware.use(inspectorProxy.processRequest.bind(inspectorProxy));\n  return {\n    inspectorProxy: inspectorProxy\n  };\n}\n\nexports.attachInspectorProxy = attachInspectorProxy;\n\n__exportStar(require(\"./middlwareMutations\"), exports);\n\n__exportStar(require(\"./JsInspector\"), exports);","map":{"version":3,"sources":["../src/MetroDevServer.ts"],"names":[],"mappings":"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","sourcesContent":["import type Log from '@expo/bunyan';\nimport { ExpoConfig, getConfigFilePaths } from '@expo/config';\nimport type { LoadOptions } from '@expo/metro-config';\nimport chalk from 'chalk';\nimport type { Server as ConnectServer } from 'connect';\nimport http from 'http';\nimport type Metro from 'metro';\n\nimport {\n  buildHermesBundleAsync,\n  isEnableHermesManaged,\n  maybeThrowFromInconsistentEngineAsync,\n} from './HermesBundler';\nimport LogReporter from './LogReporter';\nimport { createDevServerAsync } from './metro/createDevServerAsync';\nimport {\n  importExpoMetroConfigFromProject,\n  importInspectorProxyServerFromProject,\n  importMetroFromProject,\n  importMetroServerFromProject,\n} from './metro/importMetroFromProject';\nimport { createDevServerMiddleware } from './middleware/devServerMiddleware';\n\nexport type MetroDevServerOptions = LoadOptions & {\n  logger: Log;\n  quiet?: boolean;\n  unversioned?: boolean;\n};\nexport type BundleOptions = {\n  entryPoint: string;\n  platform: 'android' | 'ios' | 'web';\n  dev?: boolean;\n  minify?: boolean;\n  sourceMapUrl?: string;\n};\nexport type BundleAssetWithFileHashes = Metro.AssetData & {\n  fileHashes: string[]; // added by the hashAssets asset plugin\n};\nexport type BundleOutput = {\n  code: string;\n  map: string;\n  hermesBytecodeBundle?: Uint8Array;\n  hermesSourcemap?: string;\n  assets: readonly BundleAssetWithFileHashes[];\n};\nexport type MessageSocket = {\n  broadcast: (method: string, params?: Record<string, any> | undefined) => void;\n};\n\nfunction getExpoMetroConfig(\n  projectRoot: string,\n  { logger, unversioned }: Pick<MetroDevServerOptions, 'logger' | 'unversioned'>\n): typeof import('@expo/metro-config') {\n  if (!unversioned) {\n    try {\n      return importExpoMetroConfigFromProject(projectRoot);\n    } catch {\n      // If expo isn't installed, use the unversioned config and warn about installing expo.\n    }\n  }\n\n  const unversionedVersion = require('@expo/metro-config/package.json').version;\n  logger.info(\n    { tag: 'expo' },\n    chalk.gray(\n      `\\u203A Unversioned ${chalk.bold`@expo/metro-config@${unversionedVersion}`} is being used. Bundling apps may not work as expected, and is subject to breaking changes. Install ${chalk.bold`expo`} or set the app.json sdkVersion to use a stable version of @expo/metro-config.`\n    )\n  );\n\n  return require('@expo/metro-config');\n}\n\nexport async function runMetroDevServerAsync(\n  projectRoot: string,\n  options: MetroDevServerOptions\n): Promise<{\n  server: http.Server;\n  middleware: any;\n  messageSocket: MessageSocket;\n}> {\n  const reporter = new LogReporter(options.logger);\n\n  const ExpoMetroConfig = getExpoMetroConfig(projectRoot, options);\n\n  const metroConfig = await ExpoMetroConfig.loadAsync(projectRoot, { reporter, ...options });\n\n  const { middleware, attachToServer } = createDevServerMiddleware({\n    port: metroConfig.server.port,\n    watchFolders: metroConfig.watchFolders,\n    logger: options.logger,\n  });\n\n  const customEnhanceMiddleware = metroConfig.server.enhanceMiddleware;\n  // @ts-ignore can't mutate readonly config\n  metroConfig.server.enhanceMiddleware = (metroMiddleware: any, server: Metro.Server) => {\n    if (customEnhanceMiddleware) {\n      metroMiddleware = customEnhanceMiddleware(metroMiddleware, server);\n    }\n    return middleware.use(metroMiddleware);\n  };\n\n  const { server } = await createDevServerAsync(projectRoot, {\n    config: metroConfig,\n    logger: options.logger,\n  });\n\n  const { messageSocket, eventsSocket } = attachToServer(server);\n  reporter.reportEvent = eventsSocket.reportEvent;\n\n  return {\n    server,\n    middleware,\n    messageSocket,\n  };\n}\n\nlet nextBuildID = 0;\n\n// TODO: deprecate options.target\nexport async function bundleAsync(\n  projectRoot: string,\n  expoConfig: ExpoConfig,\n  options: MetroDevServerOptions,\n  bundles: BundleOptions[]\n): Promise<BundleOutput[]> {\n  const metro = importMetroFromProject(projectRoot);\n  const Server = importMetroServerFromProject(projectRoot);\n\n  const reporter = new LogReporter(options.logger);\n  const ExpoMetroConfig = getExpoMetroConfig(projectRoot, options);\n\n  const config = await ExpoMetroConfig.loadAsync(projectRoot, { reporter, ...options });\n  const buildID = `bundle_${nextBuildID++}`;\n\n  const metroServer = await metro.runMetro(config, {\n    watch: false,\n  });\n\n  const buildAsync = async (bundle: BundleOptions): Promise<BundleOutput> => {\n    const bundleOptions: Metro.BundleOptions = {\n      ...Server.DEFAULT_BUNDLE_OPTIONS,\n      bundleType: 'bundle',\n      platform: bundle.platform,\n      entryFile: bundle.entryPoint,\n      dev: bundle.dev ?? false,\n      minify: bundle.minify ?? !bundle.dev,\n      inlineSourceMap: false,\n      sourceMapUrl: bundle.sourceMapUrl,\n      createModuleIdFactory: config.serializer.createModuleIdFactory,\n      onProgress: (transformedFileCount: number, totalFileCount: number) => {\n        if (!options.quiet) {\n          reporter.update({\n            buildID,\n            type: 'bundle_transform_progressed',\n            transformedFileCount,\n            totalFileCount,\n          });\n        }\n      },\n    };\n    reporter.update({\n      buildID,\n      type: 'bundle_build_started',\n      bundleDetails: {\n        bundleType: bundleOptions.bundleType,\n        platform: bundle.platform,\n        entryFile: bundle.entryPoint,\n        dev: bundle.dev ?? false,\n        minify: bundle.minify ?? false,\n      },\n    });\n    const { code, map } = await metroServer.build(bundleOptions);\n    const assets = (await metroServer.getAssets(\n      bundleOptions\n    )) as readonly BundleAssetWithFileHashes[];\n    reporter.update({\n      buildID,\n      type: 'bundle_build_done',\n    });\n    return { code, map, assets };\n  };\n\n  const maybeAddHermesBundleAsync = async (\n    bundle: BundleOptions,\n    bundleOutput: BundleOutput\n  ): Promise<BundleOutput> => {\n    const { platform } = bundle;\n    const isHermesManaged = isEnableHermesManaged(expoConfig, platform);\n\n    const paths = getConfigFilePaths(projectRoot);\n    const configFilePath = paths.dynamicConfigPath ?? paths.staticConfigPath ?? 'app.json';\n    await maybeThrowFromInconsistentEngineAsync(\n      projectRoot,\n      configFilePath,\n      platform,\n      isHermesManaged\n    );\n\n    if (isHermesManaged) {\n      const platformTag = chalk.bold(\n        { ios: 'iOS', android: 'Android', web: 'Web' }[platform] || platform\n      );\n      options.logger.info(\n        { tag: 'expo' },\n        `ðŸ’¿ ${platformTag} Building Hermes bytecode for the bundle`\n      );\n      const hermesBundleOutput = await buildHermesBundleAsync(\n        projectRoot,\n        bundleOutput.code,\n        bundleOutput.map,\n        bundle.minify\n      );\n      bundleOutput.hermesBytecodeBundle = hermesBundleOutput.hbc;\n      bundleOutput.hermesSourcemap = hermesBundleOutput.sourcemap;\n    }\n    return bundleOutput;\n  };\n\n  try {\n    const intermediateOutputs = await Promise.all(bundles.map(bundle => buildAsync(bundle)));\n    const bundleOutputs: BundleOutput[] = [];\n    for (let i = 0; i < bundles.length; ++i) {\n      // hermesc does not support parallel building even we spawn processes.\n      // we should build them sequentially.\n      bundleOutputs.push(await maybeAddHermesBundleAsync(bundles[i], intermediateOutputs[i]));\n    }\n    return bundleOutputs;\n  } finally {\n    metroServer.end();\n  }\n}\n\n/**\n * Attach the inspector proxy to a development server.\n * Inspector proxy is used for viewing the JS context in a browser.\n * This must be attached after the server is listening.\n * Attaching consists of pushing custom middleware and appending WebSockets to the server.\n *\n *\n * @param projectRoot\n * @param props.server dev server to add WebSockets to\n * @param props.middleware dev server middleware to add extra middleware to\n */\nexport function attachInspectorProxy(\n  projectRoot: string,\n  { server, middleware }: { server: http.Server; middleware: ConnectServer }\n) {\n  const { InspectorProxy } = importInspectorProxyServerFromProject(projectRoot);\n  const inspectorProxy = new InspectorProxy(projectRoot);\n  if ('addWebSocketListener' in inspectorProxy) {\n    // metro@0.59.0\n    inspectorProxy.addWebSocketListener(server);\n  } else if ('createWebSocketListeners' in inspectorProxy) {\n    // metro@0.66.0\n    // TODO: This isn't properly support without a ws router.\n    inspectorProxy.createWebSocketListeners(server);\n  }\n  // TODO(hypuk): Refactor inspectorProxy.processRequest into separate request handlers\n  // so that we could provide routes (/json/list and /json/version) here.\n  // Currently this causes Metro to give warning about T31407894.\n  // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n  middleware.use(inspectorProxy.processRequest.bind(inspectorProxy));\n\n  return { inspectorProxy };\n}\n\nexport { LogReporter, createDevServerMiddleware };\nexport * from './middlwareMutations';\nexport * from './JsInspector';\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}