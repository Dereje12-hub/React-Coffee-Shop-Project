{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getWatchFolders = exports.resolveAllWorkspacePackageJsonPaths = exports.globAllPackageJsonPaths = void 0;\n\nvar json_file_1 = __importDefault(require(\"@expo/json-file\"));\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar find_yarn_workspace_root_1 = __importDefault(require(\"find-yarn-workspace-root\"));\n\nvar glob_1 = require(\"glob\");\n\nvar path_1 = __importDefault(require(\"path\"));\n\nfunction globAllPackageJsonPaths(workspaceProjectRoot, linkedPackages) {\n  return linkedPackages.map(function (glob) {\n    return glob_1.sync(path_1.default.join(glob, 'package.json').replace(/\\\\/g, '/'), {\n      cwd: workspaceProjectRoot,\n      absolute: true,\n      ignore: ['**/@(Carthage|Pods|node_modules)/**']\n    }).map(function (pkgPath) {\n      try {\n        json_file_1.default.read(pkgPath);\n        return pkgPath;\n      } catch (_unused) {}\n\n      return null;\n    });\n  }).flat().filter(Boolean).map(function (p) {\n    return path_1.default.join(p);\n  });\n}\n\nexports.globAllPackageJsonPaths = globAllPackageJsonPaths;\n\nfunction getWorkspacePackagesArray(_ref) {\n  var workspaces = _ref.workspaces;\n\n  if (Array.isArray(workspaces)) {\n    return workspaces;\n  }\n\n  assert_1.default(workspaces === null || workspaces === void 0 ? void 0 : workspaces.packages, 'Could not find a `workspaces` object in the root package.json');\n  return workspaces.packages;\n}\n\nfunction resolveAllWorkspacePackageJsonPaths(workspaceProjectRoot) {\n  try {\n    var rootPackageJsonFilePath = path_1.default.join(workspaceProjectRoot, 'package.json');\n    var rootPackageJson = json_file_1.default.read(rootPackageJsonFilePath);\n    var packages = getWorkspacePackagesArray(rootPackageJson);\n    return globAllPackageJsonPaths(workspaceProjectRoot, packages);\n  } catch (_unused2) {\n    return [];\n  }\n}\n\nexports.resolveAllWorkspacePackageJsonPaths = resolveAllWorkspacePackageJsonPaths;\n\nfunction getWatchFolders(projectRoot) {\n  var workspaceRoot = find_yarn_workspace_root_1.default(path_1.default.resolve(projectRoot));\n\n  if (!workspaceRoot) {\n    return [];\n  }\n\n  var packages = resolveAllWorkspacePackageJsonPaths(workspaceRoot);\n\n  if (!packages.length) {\n    return [];\n  }\n\n  return uniqueItems([path_1.default.join(workspaceRoot, 'node_modules')].concat(_toConsumableArray(packages.map(function (pkg) {\n    return path_1.default.dirname(pkg);\n  }))));\n}\n\nexports.getWatchFolders = getWatchFolders;\n\nfunction uniqueItems(items) {\n  return _toConsumableArray(new Set(items));\n}","map":{"version":3,"sources":["../src/getWatchFolders.ts"],"names":[],"mappings":"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","sourcesContent":["import JsonFile from '@expo/json-file';\nimport assert from 'assert';\nimport findWorkspaceRoot from 'find-yarn-workspace-root';\nimport { sync as globSync } from 'glob';\nimport path from 'path';\n\n/**\n * @param workspaceProjectRoot Root file path for the yarn workspace\n * @param linkedPackages List of folders that contain linked node modules, ex: `['packages/*', 'apps/*']`\n * @returns List of valid package.json file paths, ex: `['/Users/me/app/apps/my-app/package.json', '/Users/me/app/packages/my-package/package.json']`\n */\nexport function globAllPackageJsonPaths(\n  workspaceProjectRoot: string,\n  linkedPackages: string[]\n): string[] {\n  return linkedPackages\n    .map(glob => {\n      return globSync(path.join(glob, 'package.json').replace(/\\\\/g, '/'), {\n        cwd: workspaceProjectRoot,\n        absolute: true,\n        ignore: ['**/@(Carthage|Pods|node_modules)/**'],\n      }).map(pkgPath => {\n        try {\n          JsonFile.read(pkgPath);\n          return pkgPath;\n        } catch {\n          // Skip adding path if the package.json is invalid or cannot be read.\n        }\n        return null;\n      });\n    })\n    .flat()\n    .filter(Boolean)\n    .map(p => path.join(p as string));\n}\n\nfunction getWorkspacePackagesArray({ workspaces }: any): string[] {\n  if (Array.isArray(workspaces)) {\n    return workspaces;\n  }\n\n  assert(workspaces?.packages, 'Could not find a `workspaces` object in the root package.json');\n\n  return workspaces.packages;\n}\n\n/**\n * @param workspaceProjectRoot root file path for a yarn workspace.\n * @returns list of package.json file paths that are linked to the yarn workspace.\n */\nexport function resolveAllWorkspacePackageJsonPaths(workspaceProjectRoot: string) {\n  try {\n    const rootPackageJsonFilePath = path.join(workspaceProjectRoot, 'package.json');\n    // Could throw if package.json is invalid.\n    const rootPackageJson = JsonFile.read(rootPackageJsonFilePath);\n\n    // Extract the \"packages\" array or use \"workspaces\" as packages array (yarn workspaces spec).\n    const packages = getWorkspacePackagesArray(rootPackageJson);\n\n    // Glob all package.json files and return valid paths.\n    return globAllPackageJsonPaths(workspaceProjectRoot, packages);\n  } catch {\n    return [];\n  }\n}\n\n/**\n * @param projectRoot file path to app's project root\n * @returns list of node module paths to watch in Metro bundler, ex: `['/Users/me/app/node_modules/', '/Users/me/app/apps/my-app/', '/Users/me/app/packages/my-package/']`\n */\nexport function getWatchFolders(projectRoot: string): string[] {\n  const workspaceRoot = findWorkspaceRoot(path.resolve(projectRoot));\n  // Rely on default behavior in standard projects.\n  if (!workspaceRoot) {\n    return [];\n  }\n\n  const packages = resolveAllWorkspacePackageJsonPaths(workspaceRoot);\n  if (!packages.length) {\n    return [];\n  }\n\n  return uniqueItems([\n    path.join(workspaceRoot, 'node_modules'),\n    ...packages.map(pkg => path.dirname(pkg)),\n  ]);\n}\n\nfunction uniqueItems(items: string[]): string[] {\n  return [...new Set(items)];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}