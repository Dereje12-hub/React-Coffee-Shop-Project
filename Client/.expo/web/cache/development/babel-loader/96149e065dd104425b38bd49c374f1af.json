{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\n\nvar LinuxPlatform = _createClass(function LinuxPlatform() {\n  _classCallCheck(this, LinuxPlatform);\n});\n\nexport { LinuxPlatform as default };","map":{"version":3,"sources":["C:/Users/Dereje/node_modules/@expo/devcert/dist/platforms/linux.d.ts"],"names":["LinuxPlatform"],"mappings":";;;IAEqBA,a;;;;SAAAA,a","sourcesContent":["import { Options } from '../index';\nimport { Platform } from '.';\nexport default class LinuxPlatform implements Platform {\n    private FIREFOX_NSS_DIR;\n    private CHROME_NSS_DIR;\n    private FIREFOX_BIN_PATH;\n    private CHROME_BIN_PATH;\n    private HOST_FILE_PATH;\n    /**\n     * Linux is surprisingly difficult. There seems to be multiple system-wide\n     * repositories for certs, so we copy ours to each. However, Firefox does it's\n     * usual separate trust store. Plus Chrome relies on the NSS tooling (like\n     * Firefox), but uses the user's NSS database, unlike Firefox (which uses a\n     * separate Mozilla one). And since Chrome doesn't prompt the user with a GUI\n     * flow when opening certs, if we can't use certutil to install our certificate\n     * into the user's NSS database, we're out of luck.\n     */\n    addToTrustStores(certificatePath: string, options?: Options): Promise<void>;\n    removeFromTrustStores(certificatePath: string): void;\n    addDomainToHostFileIfMissing(domain: string): Promise<void>;\n    deleteProtectedFiles(filepath: string): void;\n    readProtectedFile(filepath: string): Promise<string>;\n    writeProtectedFile(filepath: string, contents: string): Promise<void>;\n    private isFirefoxInstalled;\n    private isChromeInstalled;\n}\n"]},"metadata":{},"sourceType":"module"}