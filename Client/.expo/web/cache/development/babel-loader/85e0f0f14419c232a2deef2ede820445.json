{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evalConfig = evalConfig;\nexports.resolveConfigExport = resolveConfigExport;\n\nfunction _fs() {\n  var data = require(\"fs\");\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _requireFromString() {\n  var data = _interopRequireDefault(require(\"require-from-string\"));\n\n  _requireFromString = function _requireFromString() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sucrase() {\n  var data = require(\"sucrase\");\n\n  _sucrase = function _sucrase() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _Errors() {\n  var data = require(\"./Errors\");\n\n  _Errors = function _Errors() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _Serialize() {\n  var data = require(\"./Serialize\");\n\n  _Serialize = function _Serialize() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction evalConfig(configFile, request) {\n  var contents = (0, _fs().readFileSync)(configFile, 'utf8');\n  var result;\n\n  try {\n    var _ref = (0, _sucrase().transform)(contents, {\n      filePath: configFile,\n      transforms: ['typescript', 'imports']\n    }),\n        code = _ref.code;\n\n    result = (0, _requireFromString().default)(code, configFile);\n  } catch (error) {\n    var location = extractLocationFromSyntaxError(error);\n\n    if (location) {\n      var _require = require('@babel/code-frame'),\n          codeFrameColumns = _require.codeFrameColumns;\n\n      var codeFrame = codeFrameColumns(contents, {\n        start: error.loc\n      }, {\n        highlightCode: true\n      });\n      error.codeFrame = codeFrame;\n      error.message += \"\\n\" + codeFrame;\n    } else {\n      var importantStack = extractImportantStackFromNodeError(error);\n\n      if (importantStack) {\n        error.message += \"\\n\" + importantStack;\n      }\n    }\n\n    throw error;\n  }\n\n  return resolveConfigExport(result, configFile, request);\n}\n\nfunction extractLocationFromSyntaxError(error) {\n  if (error.loc) {\n    return error.loc;\n  }\n\n  if ('lineNumber' in error && 'columnNumber' in error) {\n    return {\n      line: error.lineNumber,\n      column: error.columnNumber\n    };\n  }\n\n  return null;\n}\n\nfunction extractImportantStackFromNodeError(error) {\n  if (isSyntaxError(error)) {\n    var _error$stack;\n\n    var traces = (_error$stack = error.stack) === null || _error$stack === void 0 ? void 0 : _error$stack.split('\\n').filter(function (line) {\n      return !line.startsWith('    at ');\n    });\n    if (!traces) return null;\n\n    if (traces[traces.length - 1].startsWith('SyntaxError:')) {\n      traces.pop();\n    }\n\n    return traces.join('\\n');\n  }\n\n  return null;\n}\n\nfunction isSyntaxError(error) {\n  return error instanceof SyntaxError || error.constructor.name === 'SyntaxError';\n}\n\nfunction resolveConfigExport(result, configFile, request) {\n  var _result;\n\n  if (result.default != null) {\n    result = result.default;\n  }\n\n  var exportedObjectType = typeof result;\n\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n\n  if (result instanceof Promise) {\n    throw new (_Errors().ConfigError)(\"Config file \" + configFile + \" cannot return a Promise.\", 'INVALID_CONFIG');\n  }\n\n  if ((_result = result) !== null && _result !== void 0 && _result.expo) {\n    result = (0, _Serialize().serializeSkippingMods)(result.expo);\n  } else {\n    result = (0, _Serialize().serializeSkippingMods)(result);\n  }\n\n  return {\n    config: result,\n    exportedObjectType: exportedObjectType\n  };\n}","map":{"version":3,"sources":["../src/evalConfig.ts"],"names":["contents","code","filePath","transforms","result","location","extractLocationFromSyntaxError","codeFrameColumns","require","codeFrame","start","error","loc","highlightCode","importantStack","extractImportantStackFromNodeError","resolveConfigExport","line","column","columnNumber","isSyntaxError","traces","exportedObjectType","ConfigError","config"],"mappings":"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","sourcesContent":["import { readFileSync } from 'fs';\nimport requireString from 'require-from-string';\nimport { transform } from 'sucrase';\n\nimport { AppJSONConfig, ConfigContext, ExpoConfig } from './Config.types';\nimport { ConfigError } from './Errors';\nimport { serializeSkippingMods } from './Serialize';\n\ntype RawDynamicConfig = AppJSONConfig | Partial<ExpoConfig> | null;\n\nexport type DynamicConfigResults = { config: RawDynamicConfig; exportedObjectType: string };\n\n/**\n * Transpile and evaluate the dynamic config object.\n * This method is shared between the standard reading method in getConfig, and the headless script.\n *\n * @param options configFile path to the dynamic app.config.*, request to send to the dynamic config if it exports a function.\n * @returns the serialized and evaluated config along with the exported object type (object or function).\n */\nexport function evalConfig(\n  configFile: string,\n  request: ConfigContext | null\n): DynamicConfigResults {\n  const contents = readFileSync(configFile, 'utf8');\n  let result: any;\n  try {\n    const { code } = transform(contents, {\n      filePath: configFile,\n      transforms: ['typescript', 'imports'],\n    });\n\n    result = requireString(code, configFile);\n  } catch (error) {\n    const location = extractLocationFromSyntaxError(error);\n\n    // Apply a code frame preview to the error if possible, sucrase doesn't do this by default.\n    if (location) {\n      const { codeFrameColumns } = require('@babel/code-frame');\n      const codeFrame = codeFrameColumns(contents, { start: error.loc }, { highlightCode: true });\n      error.codeFrame = codeFrame;\n      error.message += `\\n${codeFrame}`;\n    } else {\n      const importantStack = extractImportantStackFromNodeError(error);\n\n      if (importantStack) {\n        error.message += `\\n${importantStack}`;\n      }\n    }\n    throw error;\n  }\n  return resolveConfigExport(result, configFile, request);\n}\n\nfunction extractLocationFromSyntaxError(\n  error: Error | any\n): { line: number; column?: number } | null {\n  // sucrase provides the `loc` object\n  if (error.loc) {\n    return error.loc;\n  }\n\n  // `SyntaxError`s provide the `lineNumber` and `columnNumber` properties\n  if ('lineNumber' in error && 'columnNumber' in error) {\n    return { line: error.lineNumber, column: error.columnNumber };\n  }\n\n  return null;\n}\n\n// These kinda errors often come from syntax errors in files that were imported by the main file.\n// An example is a module that includes an import statement.\nfunction extractImportantStackFromNodeError(error: any): string | null {\n  if (isSyntaxError(error)) {\n    const traces = error.stack?.split('\\n').filter(line => !line.startsWith('    at '));\n    if (!traces) return null;\n\n    // Remove redundant line\n    if (traces[traces.length - 1].startsWith('SyntaxError:')) {\n      traces.pop();\n    }\n    return traces.join('\\n');\n  }\n  return null;\n}\n\nfunction isSyntaxError(error: any): error is SyntaxError {\n  return error instanceof SyntaxError || error.constructor.name === 'SyntaxError';\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n * @param request\n */\nexport function resolveConfigExport(\n  result: any,\n  configFile: string,\n  request: ConfigContext | null\n) {\n  if (result.default != null) {\n    result = result.default;\n  }\n  const exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n\n  if (result instanceof Promise) {\n    throw new ConfigError(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');\n  }\n\n  // If the expo object exists, ignore all other values.\n  if (result?.expo) {\n    result = serializeSkippingMods(result.expo);\n  } else {\n    result = serializeSkippingMods(result);\n  }\n\n  return { config: result, exportedObjectType };\n}\n"]},"metadata":{},"sourceType":"script"}