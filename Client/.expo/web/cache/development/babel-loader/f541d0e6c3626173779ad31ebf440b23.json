{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createGetFileNameFromUrl = exports.getCompilerForPlatform = exports.getPlatformFromRequest = exports.getFileFromCompilerAsync = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar util_1 = require(\"webpack-dev-middleware/lib/util\");\n\nfunction getFileFromCompilerAsync(compiler, _ref) {\n  var fileName = _ref.fileName,\n      platform = _ref.platform;\n  var platformCompiler = getCompilerForPlatform(compiler, platform);\n  return new Promise(function (resolve, reject) {\n    return platformCompiler.outputFileSystem.readFile(fileName, function (error, content) {\n      if (error || !content) {\n        reject(error);\n      } else {\n        resolve(content.toString());\n      }\n    });\n  });\n}\n\nexports.getFileFromCompilerAsync = getFileFromCompilerAsync;\n\nfunction getPlatformFromRequest(request) {\n  var _a, _b, _c, _d, _e;\n\n  if (typeof request.headers['expo-platform'] === 'string') {\n    return (_a = request.headers['expo-platform']) !== null && _a !== void 0 ? _a : null;\n  }\n\n  return (_e = (_d = (_c = (_b = request === null || request === void 0 ? void 0 : request.url) === null || _b === void 0 ? void 0 : _b.match) === null || _c === void 0 ? void 0 : _c.call(_b, /[?|&]platform=(\\w+)[&|\\\\]/)) === null || _d === void 0 ? void 0 : _d[1]) !== null && _e !== void 0 ? _e : null;\n}\n\nexports.getPlatformFromRequest = getPlatformFromRequest;\n\nfunction getCompilerForPlatform(compiler, platform) {\n  if (!('compilers' in compiler)) {\n    return compiler;\n  }\n\n  assert_1.default(platform, 'platform must be provided for multi-compiler servers');\n  var platformCompiler = compiler.compilers.find(function (_ref2) {\n    var options = _ref2.options;\n    return options.name === platform;\n  });\n  assert_1.default(platformCompiler, \"Could not find Webpack compiler for platform: \" + platform);\n  return platformCompiler;\n}\n\nexports.getCompilerForPlatform = getCompilerForPlatform;\n\nfunction createGetFileNameFromUrl(compiler) {\n  var publicPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';\n  return function (_ref3) {\n    var url = _ref3.url,\n        platform = _ref3.platform;\n    var platformCompiler = getCompilerForPlatform(compiler, platform);\n    var filename = util_1.getFilenameFromUrl(publicPath, platformCompiler, url);\n\n    if (!filename) {\n      throw new Error(\"Cannot get Webpack file name from url: \" + url);\n    }\n\n    return filename;\n  };\n}\n\nexports.createGetFileNameFromUrl = createGetFileNameFromUrl;","map":{"version":3,"sources":["../../src/webpack/getFileAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from 'assert';\nimport type { IncomingMessage } from 'http';\nimport webpack from 'webpack';\n// @ts-ignore\nimport { getFilenameFromUrl } from 'webpack-dev-middleware/lib/util';\n\nexport type AnyCompiler = webpack.Compiler | webpack.MultiCompiler;\n\n/**\n * Read a file from the webpack \"compiler\".\n *\n * @param compiler webpack compiler\n * @param filename Like: `/Users/evanbacon/Documents/GitHub/lab/yolo47/web-build/index.bundle`\n * @returns\n */\nexport function getFileFromCompilerAsync(\n  compiler: AnyCompiler,\n  { fileName, platform }: { fileName: string; platform?: string }\n): Promise<string> {\n  const platformCompiler = getCompilerForPlatform(compiler, platform);\n  return new Promise<string>((resolve, reject) =>\n    (platformCompiler.outputFileSystem as any).readFile(\n      fileName,\n      (error: Error | undefined, content: string | Buffer) => {\n        if (error || !content) {\n          reject(error);\n        } else {\n          resolve(content.toString());\n        }\n      }\n    )\n  );\n}\n\nexport function getPlatformFromRequest(request: IncomingMessage): string | null {\n  // Use the expo updates spec to check the platform.\n  if (typeof request.headers['expo-platform'] === 'string') {\n    return request.headers['expo-platform'] ?? null;\n  }\n\n  // Get the platform from the query params cheaply.\n  return request?.url?.match?.(/[?|&]platform=(\\w+)[&|\\\\]/)?.[1] ?? null;\n}\n\n/**\n * Get the Webpack compiler for a given platform.\n * In Expo we distinguish platforms by using the `name` property of the Webpack config.\n *\n * When the platform is undefined, or the compiler cannot be identified, we assert.\n *\n * @param compiler\n * @param platform\n * @returns\n */\nexport function getCompilerForPlatform(compiler: AnyCompiler, platform?: string): webpack.Compiler {\n  if (!('compilers' in compiler)) {\n    return compiler;\n  }\n  assert(platform, 'platform must be provided for multi-compiler servers');\n  const platformCompiler = compiler.compilers.find(({ options }) => options.name === platform);\n  assert(platformCompiler, `Could not find Webpack compiler for platform: ${platform}`);\n  return platformCompiler;\n}\n\nexport function createGetFileNameFromUrl(compiler: AnyCompiler, publicPath: string = '/') {\n  return function ({ url, platform }: { url: string; platform?: string }): string {\n    const platformCompiler = getCompilerForPlatform(compiler, platform);\n\n    const filename = getFilenameFromUrl(\n      // public path\n      publicPath,\n      platformCompiler,\n      url\n    );\n    if (!filename) {\n      throw new Error(`Cannot get Webpack file name from url: ${url}`);\n    }\n    return filename;\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}