{"ast":null,"code":"'use strict';\n\nvar url = require('url');\n\nvar gitHosts = require(\"./git-host-info.js\");\n\nvar GitHost = module.exports = require(\"./git-host.js\");\n\nvar LRU = require('lru-cache');\n\nvar cache = new LRU({\n  max: 1000\n});\nvar protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n};\n\nfunction protocolToRepresentation(protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n};\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return;\n  var key = giturl + JSON.stringify(opts || {});\n\n  if (!cache.has(key)) {\n    cache.set(key, fromUrl(giturl, opts));\n  }\n\n  return cache.get(key);\n};\n\nfunction fromUrl(giturl, opts) {\n  if (giturl == null || giturl === '') return;\n  var url = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? 'github:' + giturl : giturl);\n  var parsed = parseGitUrl(url);\n  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\\/)?([^#]+)/);\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName];\n      var auth = null;\n\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = parsed.auth;\n      }\n\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;\n      var user = null;\n      var project = null;\n      var defaultRepresentation = null;\n\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);\n        project = decodeURIComponent(shortcutMatch[3].replace(/\\.git$/, ''));\n        defaultRepresentation = 'shortcut';\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return;\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return;\n        if (!parsed.path) return;\n        var pathmatch = gitHostInfo.pathmatch;\n        var matched = parsed.path.match(pathmatch);\n        if (!matched) return;\n\n        if (matched[1] !== null && matched[1] !== undefined) {\n          user = decodeURIComponent(matched[1].replace(/^:/, ''));\n        }\n\n        project = decodeURIComponent(matched[2]);\n        defaultRepresentation = protocolToRepresentation(parsed.protocol);\n      }\n\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);\n    } catch (ex) {\n      if (ex instanceof URIError) {} else throw ex;\n    }\n  }).filter(function (gitHostInfo) {\n    return gitHostInfo;\n  });\n  if (matches.length !== 1) return;\n  return matches[0];\n}\n\nfunction isGitHubShorthand(arg) {\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg);\n}\n\nfunction fixupUnqualifiedGist(giturl) {\n  var parsed = url.parse(giturl);\n\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host;\n  } else {\n    return giturl;\n  }\n}\n\nfunction parseGitUrl(giturl) {\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);\n\n  if (!matched) {\n    var legacy = url.parse(giturl);\n\n    if (legacy.auth) {\n      var authmatch = giturl.match(/[^@]+@[^:/]+/);\n\n      if (authmatch) {\n        var whatwg = new url.URL(authmatch[0]);\n        legacy.auth = whatwg.username || '';\n        if (whatwg.password) legacy.auth += ':' + whatwg.password;\n      }\n    }\n\n    return legacy;\n  }\n\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] + '/' + matched[3] + (matched[4] || '')\n  };\n}","map":{"version":3,"sources":["C:/Users/Dereje/node_modules/@expo/package-manager/node_modules/hosted-git-info/index.js"],"names":["url","require","gitHosts","GitHost","module","exports","LRU","cache","max","protocolToRepresentationMap","protocolToRepresentation","protocol","slice","authProtocols","fromUrl","giturl","opts","key","JSON","stringify","has","set","get","fixupUnqualifiedGist","isGitHubShorthand","parsed","parseGitUrl","shortcutMatch","match","matches","Object","keys","map","gitHostName","gitHostInfo","auth","committish","hash","decodeURIComponent","substr","user","project","defaultRepresentation","replace","host","domain","protocols_re","test","path","pathmatch","matched","undefined","ex","URIError","filter","length","arg","parse","legacy","authmatch","whatwg","URL","username","password","slashes","port","hostname","search","query","pathname","href"],"mappings":"AAAA;;AACA,IAAIA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAjB;;AACA,IAAIC,QAAQ,GAAGD,OAAO,sBAAtB;;AACA,IAAIE,OAAO,GAAGC,MAAM,CAACC,OAAP,GAAiBJ,OAAO,iBAAtC;;AACA,IAAIK,GAAG,GAAGL,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIM,KAAK,GAAG,IAAID,GAAJ,CAAQ;AAACE,EAAAA,GAAG,EAAE;AAAN,CAAR,CAAZ;AAEA,IAAIC,2BAA2B,GAAG;AAChC,cAAY,QADoB;AAEhC,gBAAc,OAFkB;AAGhC,UAAQ,QAHwB;AAIhC,UAAQ;AAJwB,CAAlC;;AAOA,SAASC,wBAAT,CAAmCC,QAAnC,EAA6C;AAC3C,SAAOF,2BAA2B,CAACE,QAAD,CAA3B,IAAyCA,QAAQ,CAACC,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CAAhD;AACD;;AAED,IAAIC,aAAa,GAAG;AAClB,UAAQ,IADU;AAElB,YAAU,IAFQ;AAGlB,gBAAc,IAHI;AAIlB,WAAS,IAJS;AAKlB,eAAa;AALK,CAApB;;AAQAT,MAAM,CAACC,OAAP,CAAeS,OAAf,GAAyB,UAAUC,MAAV,EAAkBC,IAAlB,EAAwB;AAC/C,MAAI,OAAOD,MAAP,KAAkB,QAAtB,EAAgC;AAChC,MAAIE,GAAG,GAAGF,MAAM,GAAGG,IAAI,CAACC,SAAL,CAAeH,IAAI,IAAI,EAAvB,CAAnB;;AAEA,MAAI,CAACT,KAAK,CAACa,GAAN,CAAUH,GAAV,CAAL,EAAqB;AACnBV,IAAAA,KAAK,CAACc,GAAN,CAAUJ,GAAV,EAAeH,OAAO,CAACC,MAAD,EAASC,IAAT,CAAtB;AACD;;AAED,SAAOT,KAAK,CAACe,GAAN,CAAUL,GAAV,CAAP;AACD,CATD;;AAWA,SAASH,OAAT,CAAkBC,MAAlB,EAA0BC,IAA1B,EAAgC;AAC9B,MAAID,MAAM,IAAI,IAAV,IAAkBA,MAAM,KAAK,EAAjC,EAAqC;AACrC,MAAIf,GAAG,GAAGuB,oBAAoB,CAC5BC,iBAAiB,CAACT,MAAD,CAAjB,GAA4B,YAAYA,MAAxC,GAAiDA,MADrB,CAA9B;AAGA,MAAIU,MAAM,GAAGC,WAAW,CAAC1B,GAAD,CAAxB;AACA,MAAI2B,aAAa,GAAG3B,GAAG,CAAC4B,KAAJ,CAAU,2CAAV,CAApB;AACA,MAAIC,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAY7B,QAAZ,EAAsB8B,GAAtB,CAA0B,UAAUC,WAAV,EAAuB;AAC7D,QAAI;AACF,UAAIC,WAAW,GAAGhC,QAAQ,CAAC+B,WAAD,CAA1B;AACA,UAAIE,IAAI,GAAG,IAAX;;AACA,UAAIV,MAAM,CAACU,IAAP,IAAetB,aAAa,CAACY,MAAM,CAACd,QAAR,CAAhC,EAAmD;AACjDwB,QAAAA,IAAI,GAAGV,MAAM,CAACU,IAAd;AACD;;AACD,UAAIC,UAAU,GAAGX,MAAM,CAACY,IAAP,GAAcC,kBAAkB,CAACb,MAAM,CAACY,IAAP,CAAYE,MAAZ,CAAmB,CAAnB,CAAD,CAAhC,GAA0D,IAA3E;AACA,UAAIC,IAAI,GAAG,IAAX;AACA,UAAIC,OAAO,GAAG,IAAd;AACA,UAAIC,qBAAqB,GAAG,IAA5B;;AACA,UAAIf,aAAa,IAAIA,aAAa,CAAC,CAAD,CAAb,KAAqBM,WAA1C,EAAuD;AACrDO,QAAAA,IAAI,GAAGb,aAAa,CAAC,CAAD,CAAb,IAAoBW,kBAAkB,CAACX,aAAa,CAAC,CAAD,CAAd,CAA7C;AACAc,QAAAA,OAAO,GAAGH,kBAAkB,CAACX,aAAa,CAAC,CAAD,CAAb,CAAiBgB,OAAjB,CAAyB,QAAzB,EAAmC,EAAnC,CAAD,CAA5B;AACAD,QAAAA,qBAAqB,GAAG,UAAxB;AACD,OAJD,MAIO;AACL,YAAIjB,MAAM,CAACmB,IAAP,IAAenB,MAAM,CAACmB,IAAP,KAAgBV,WAAW,CAACW,MAA3C,IAAqDpB,MAAM,CAACmB,IAAP,CAAYD,OAAZ,CAAoB,SAApB,EAA+B,EAA/B,MAAuCT,WAAW,CAACW,MAA5G,EAAoH;AACpH,YAAI,CAACX,WAAW,CAACY,YAAZ,CAAyBC,IAAzB,CAA8BtB,MAAM,CAACd,QAArC,CAAL,EAAqD;AACrD,YAAI,CAACc,MAAM,CAACuB,IAAZ,EAAkB;AAClB,YAAIC,SAAS,GAAGf,WAAW,CAACe,SAA5B;AACA,YAAIC,OAAO,GAAGzB,MAAM,CAACuB,IAAP,CAAYpB,KAAZ,CAAkBqB,SAAlB,CAAd;AACA,YAAI,CAACC,OAAL,EAAc;;AAEd,YAAIA,OAAO,CAAC,CAAD,CAAP,KAAe,IAAf,IAAuBA,OAAO,CAAC,CAAD,CAAP,KAAeC,SAA1C,EAAqD;AACnDX,UAAAA,IAAI,GAAGF,kBAAkB,CAACY,OAAO,CAAC,CAAD,CAAP,CAAWP,OAAX,CAAmB,IAAnB,EAAyB,EAAzB,CAAD,CAAzB;AACD;;AACDF,QAAAA,OAAO,GAAGH,kBAAkB,CAACY,OAAO,CAAC,CAAD,CAAR,CAA5B;AACAR,QAAAA,qBAAqB,GAAGhC,wBAAwB,CAACe,MAAM,CAACd,QAAR,CAAhD;AACD;;AACD,aAAO,IAAIR,OAAJ,CAAY8B,WAAZ,EAAyBO,IAAzB,EAA+BL,IAA/B,EAAqCM,OAArC,EAA8CL,UAA9C,EAA0DM,qBAA1D,EAAiF1B,IAAjF,CAAP;AACD,KA7BD,CA6BE,OAAOoC,EAAP,EAAW;AAEX,UAAIA,EAAE,YAAYC,QAAlB,EAA4B,CAC3B,CADD,MACO,MAAMD,EAAN;AACR;AACF,GAnCa,EAmCXE,MAnCW,CAmCJ,UAAUpB,WAAV,EAAuB;AAAE,WAAOA,WAAP;AAAoB,GAnCzC,CAAd;AAoCA,MAAIL,OAAO,CAAC0B,MAAR,KAAmB,CAAvB,EAA0B;AAC1B,SAAO1B,OAAO,CAAC,CAAD,CAAd;AACD;;AAED,SAASL,iBAAT,CAA4BgC,GAA5B,EAAiC;AAS/B,SAAO,+CAA+CT,IAA/C,CAAoDS,GAApD,CAAP;AACD;;AAED,SAASjC,oBAAT,CAA+BR,MAA/B,EAAuC;AAErC,MAAIU,MAAM,GAAGzB,GAAG,CAACyD,KAAJ,CAAU1C,MAAV,CAAb;;AACA,MAAIU,MAAM,CAACd,QAAP,KAAoB,OAApB,IAA+Bc,MAAM,CAACmB,IAAtC,IAA8C,CAACnB,MAAM,CAACuB,IAA1D,EAAgE;AAC9D,WAAOvB,MAAM,CAACd,QAAP,GAAkB,GAAlB,GAAwBc,MAAM,CAACmB,IAAtC;AACD,GAFD,MAEO;AACL,WAAO7B,MAAP;AACD;AACF;;AAED,SAASW,WAAT,CAAsBX,MAAtB,EAA8B;AAC5B,MAAImC,OAAO,GAAGnC,MAAM,CAACa,KAAP,CAAa,+DAAb,CAAd;;AACA,MAAI,CAACsB,OAAL,EAAc;AACZ,QAAIQ,MAAM,GAAG1D,GAAG,CAACyD,KAAJ,CAAU1C,MAAV,CAAb;;AACA,QAAI2C,MAAM,CAACvB,IAAX,EAAiB;AAUf,UAAMwB,SAAS,GAAG5C,MAAM,CAACa,KAAP,CAAa,cAAb,CAAlB;;AAEA,UAAI+B,SAAJ,EAAe;AACb,YAAIC,MAAM,GAAG,IAAI5D,GAAG,CAAC6D,GAAR,CAAYF,SAAS,CAAC,CAAD,CAArB,CAAb;AACAD,QAAAA,MAAM,CAACvB,IAAP,GAAcyB,MAAM,CAACE,QAAP,IAAmB,EAAjC;AACA,YAAIF,MAAM,CAACG,QAAX,EAAqBL,MAAM,CAACvB,IAAP,IAAe,MAAMyB,MAAM,CAACG,QAA5B;AACtB;AACF;;AACD,WAAOL,MAAP;AACD;;AACD,SAAO;AACL/C,IAAAA,QAAQ,EAAE,UADL;AAELqD,IAAAA,OAAO,EAAE,IAFJ;AAGL7B,IAAAA,IAAI,EAAEe,OAAO,CAAC,CAAD,CAHR;AAILN,IAAAA,IAAI,EAAEM,OAAO,CAAC,CAAD,CAJR;AAKLe,IAAAA,IAAI,EAAE,IALD;AAMLC,IAAAA,QAAQ,EAAEhB,OAAO,CAAC,CAAD,CANZ;AAOLb,IAAAA,IAAI,EAAEa,OAAO,CAAC,CAAD,CAPR;AAQLiB,IAAAA,MAAM,EAAE,IARH;AASLC,IAAAA,KAAK,EAAE,IATF;AAULC,IAAAA,QAAQ,EAAE,MAAMnB,OAAO,CAAC,CAAD,CAVlB;AAWLF,IAAAA,IAAI,EAAE,MAAME,OAAO,CAAC,CAAD,CAXd;AAYLoB,IAAAA,IAAI,EAAE,eAAepB,OAAO,CAAC,CAAD,CAAtB,GAA4B,GAA5B,GAAkCA,OAAO,CAAC,CAAD,CAAzC,GACA,GADA,GACMA,OAAO,CAAC,CAAD,CADb,IACoBA,OAAO,CAAC,CAAD,CAAP,IAAc,EADlC;AAZD,GAAP;AAeD","sourcesContent":["'use strict'\nvar url = require('url')\nvar gitHosts = require('./git-host-info.js')\nvar GitHost = module.exports = require('./git-host.js')\nvar LRU = require('lru-cache')\nvar cache = new LRU({max: 1000})\n\nvar protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1)\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return\n  var key = giturl + JSON.stringify(opts || {})\n\n  if (!cache.has(key)) {\n    cache.set(key, fromUrl(giturl, opts))\n  }\n\n  return cache.get(key)\n}\n\nfunction fromUrl (giturl, opts) {\n  if (giturl == null || giturl === '') return\n  var url = fixupUnqualifiedGist(\n    isGitHubShorthand(giturl) ? 'github:' + giturl : giturl\n  )\n  var parsed = parseGitUrl(url)\n  var shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\\/)?([^#]+)/)\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName]\n      var auth = null\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = parsed.auth\n      }\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null\n      var user = null\n      var project = null\n      var defaultRepresentation = null\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])\n        project = decodeURIComponent(shortcutMatch[3].replace(/\\.git$/, ''))\n        defaultRepresentation = 'shortcut'\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return\n        if (!parsed.path) return\n        var pathmatch = gitHostInfo.pathmatch\n        var matched = parsed.path.match(pathmatch)\n        if (!matched) return\n        /* istanbul ignore else */\n        if (matched[1] !== null && matched[1] !== undefined) {\n          user = decodeURIComponent(matched[1].replace(/^:/, ''))\n        }\n        project = decodeURIComponent(matched[2])\n        defaultRepresentation = protocolToRepresentation(parsed.protocol)\n      }\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n    } catch (ex) {\n      /* istanbul ignore else */\n      if (ex instanceof URIError) {\n      } else throw ex\n    }\n  }).filter(function (gitHostInfo) { return gitHostInfo })\n  if (matches.length !== 1) return\n  return matches[0]\n}\n\nfunction isGitHubShorthand (arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg)\n}\n\nfunction fixupUnqualifiedGist (giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl)\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host\n  } else {\n    return giturl\n  }\n}\n\nfunction parseGitUrl (giturl) {\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/)\n  if (!matched) {\n    var legacy = url.parse(giturl)\n    if (legacy.auth) {\n      // git urls can be in the form of scp-style/ssh-connect strings, like\n      // git+ssh://user@host.com:some/path, which the legacy url parser\n      // supports, but WhatWG url.URL class does not.  However, the legacy\n      // parser de-urlencodes the username and password, so something like\n      // https://user%3An%40me:p%40ss%3Aword@x.com/ becomes\n      // https://user:n@me:p@ss:word@x.com/ which is all kinds of wrong.\n      // Pull off just the auth and host, so we dont' get the confusing\n      // scp-style URL, then pass that to the WhatWG parser to get the\n      // auth properly escaped.\n      const authmatch = giturl.match(/[^@]+@[^:/]+/)\n      /* istanbul ignore else - this should be impossible */\n      if (authmatch) {\n        var whatwg = new url.URL(authmatch[0])\n        legacy.auth = whatwg.username || ''\n        if (whatwg.password) legacy.auth += ':' + whatwg.password\n      }\n    }\n    return legacy\n  }\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] +\n          '/' + matched[3] + (matched[4] || '')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}