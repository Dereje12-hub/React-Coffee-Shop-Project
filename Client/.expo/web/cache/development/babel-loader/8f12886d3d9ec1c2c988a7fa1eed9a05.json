{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar expo_pwa_1 = require(\"expo-pwa\");\n\nvar JsonWebpackPlugin_1 = __importDefault(require(\"./JsonWebpackPlugin\"));\n\nfunction maybeFetchPlugin(compiler, name) {\n  var _a, _b;\n\n  return (_b = (_a = compiler.options) === null || _a === void 0 ? void 0 : _a.plugins) === null || _b === void 0 ? void 0 : _b.map(function (_ref) {\n    var constructor = _ref.constructor;\n    return constructor;\n  }).find(function (constructor) {\n    return constructor && constructor.name === name;\n  });\n}\n\nvar PwaManifestWebpackPlugin = function (_JsonWebpackPlugin_1$) {\n  _inherits(PwaManifestWebpackPlugin, _JsonWebpackPlugin_1$);\n\n  var _super = _createSuper(PwaManifestWebpackPlugin);\n\n  function PwaManifestWebpackPlugin(pwaOptions, manifest) {\n    var _this;\n\n    _classCallCheck(this, PwaManifestWebpackPlugin);\n\n    _this = _super.call(this, {\n      path: pwaOptions.path,\n      json: manifest,\n      pretty: true\n    });\n    _this.pwaOptions = pwaOptions;\n    _this.rel = 'manifest';\n    return _this;\n  }\n\n  _createClass(PwaManifestWebpackPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(PwaManifestWebpackPlugin.prototype), \"apply\", this).call(this, compiler);\n\n      compiler.hooks.make.tapPromise(this.constructor.name, function _callee(compilation) {\n        var HtmlWebpackPlugin;\n        return _regeneratorRuntime.async(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                HtmlWebpackPlugin = maybeFetchPlugin(compiler, 'HtmlWebpackPlugin');\n\n                if (!HtmlWebpackPlugin) {\n                  _context.next = 6;\n                  break;\n                }\n\n                if (!(typeof HtmlWebpackPlugin.getHooks === 'undefined')) {\n                  _context.next = 5;\n                  break;\n                }\n\n                compilation.errors.push(new Error('PwaManifestWebpackPlugin - This PwaManifestWebpackPlugin version is not compatible with your current HtmlWebpackPlugin version.\\n'));\n                return _context.abrupt(\"return\");\n\n              case 5:\n                HtmlWebpackPlugin.getHooks(compilation).alterAssetTags.tapAsync(_this2.constructor.name, function (data, htmlCallback) {\n                  var isInjectionAllowed;\n\n                  if (typeof _this2.pwaOptions.inject === 'boolean') {\n                    isInjectionAllowed = _this2.pwaOptions.inject;\n                  } else if (typeof _this2.pwaOptions.inject === 'function') {\n                    isInjectionAllowed = _this2.pwaOptions.inject(data.plugin);\n                  } else {\n                    isInjectionAllowed = data.plugin.options.pwaManifest !== false;\n                  }\n\n                  if (isInjectionAllowed === false) {\n                    return htmlCallback(null, data);\n                  }\n\n                  data.assetTags.meta.push({\n                    tagName: 'link',\n                    voidTag: true,\n                    attributes: {\n                      rel: _this2.rel,\n                      href: expo_pwa_1.joinUrlPath(_this2.pwaOptions.publicPath, _this2.pwaOptions.path)\n                    }\n                  });\n                  htmlCallback(null, data);\n                });\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      });\n    }\n  }]);\n\n  return PwaManifestWebpackPlugin;\n}(JsonWebpackPlugin_1.default);\n\nexports.default = PwaManifestWebpackPlugin;","map":{"version":3,"sources":["../../src/plugins/PwaManifestWebpackPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { joinUrlPath } from 'expo-pwa';\nimport { compilation as compilationNS, Compiler, Plugin } from 'webpack';\n\nimport JsonWebpackPlugin from './JsonWebpackPlugin';\nimport { HTMLPluginData } from './ModifyHtmlWebpackPlugin';\n\nexport type Icon = {\n  src: string;\n  sizes: string;\n  type: 'image/png';\n};\n\nfunction maybeFetchPlugin(compiler: Compiler, name: string): Plugin | undefined {\n  return compiler.options?.plugins\n    ?.map(({ constructor }) => constructor)\n    .find(constructor => constructor && constructor.name === name);\n}\n\nexport type PwaManifestOptions = {\n  path: string;\n  inject?: boolean | Function;\n  publicPath: string;\n};\n\nexport default class PwaManifestWebpackPlugin extends JsonWebpackPlugin {\n  rel: string = 'manifest';\n\n  constructor(private pwaOptions: PwaManifestOptions, manifest: any) {\n    super({\n      path: pwaOptions.path,\n      json: manifest,\n      pretty: true,\n    });\n  }\n\n  apply(compiler: Compiler) {\n    super.apply(compiler);\n    compiler.hooks.make.tapPromise(\n      this.constructor.name,\n      async (compilation: compilationNS.Compilation) => {\n        // Hook into the html-webpack-plugin processing and add the html\n        const HtmlWebpackPlugin = maybeFetchPlugin(compiler, 'HtmlWebpackPlugin') as any;\n        if (HtmlWebpackPlugin) {\n          if (typeof HtmlWebpackPlugin.getHooks === 'undefined') {\n            compilation.errors.push(\n              new Error(\n                'PwaManifestWebpackPlugin - This PwaManifestWebpackPlugin version is not compatible with your current HtmlWebpackPlugin version.\\n'\n              )\n            );\n            return;\n          }\n\n          HtmlWebpackPlugin.getHooks(compilation).alterAssetTags.tapAsync(\n            this.constructor.name,\n            (\n              data: HTMLPluginData,\n              htmlCallback: (error: Error | null, data: HTMLPluginData) => void\n            ) => {\n              // Skip if a custom injectFunction returns false or if\n              // the htmlWebpackPlugin optuons includes a `favicons: false` flag\n              let isInjectionAllowed: boolean;\n              if (typeof this.pwaOptions.inject === 'boolean') {\n                isInjectionAllowed = this.pwaOptions.inject;\n              } else if (typeof this.pwaOptions.inject === 'function') {\n                isInjectionAllowed = this.pwaOptions.inject(data.plugin);\n              } else {\n                isInjectionAllowed = data.plugin.options.pwaManifest !== false;\n              }\n\n              if (isInjectionAllowed === false) {\n                return htmlCallback(null, data);\n              }\n\n              data.assetTags.meta.push({\n                tagName: 'link',\n                voidTag: true,\n                attributes: {\n                  rel: this.rel,\n                  href: joinUrlPath(this.pwaOptions.publicPath, this.pwaOptions.path),\n                },\n              });\n\n              htmlCallback(null, data);\n            }\n          );\n        }\n      }\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}