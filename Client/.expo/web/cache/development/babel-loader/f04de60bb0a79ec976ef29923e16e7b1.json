{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.escapeStringRegexp = void 0;\n\nfunction escapeStringRegexp(string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\n\nexports.escapeStringRegexp = escapeStringRegexp;","map":{"version":3,"sources":["../../src/utils/escapeStringRegexp.ts"],"names":[],"mappings":";;;;;;;AAAA,SAAgB,kBAAhB,CAAmC,MAAnC,EAAiD;AAC/C,MAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UAAM,IAAI,SAAJ,CAAc,mBAAd,CAAN;AACD;;AAID,SAAO,MAAM,CAAC,OAAP,CAAe,qBAAf,EAAsC,MAAtC,EAA8C,OAA9C,CAAsD,IAAtD,EAA4D,OAA5D,CAAP;AACD;;AARD,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourcesContent":["export function escapeStringRegexp(string: string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  // Escape characters with special meaning either inside or outside character sets.\n  // Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}