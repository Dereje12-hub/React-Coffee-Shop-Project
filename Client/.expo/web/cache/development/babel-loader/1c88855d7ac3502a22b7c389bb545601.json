{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar fs_1 = require(\"fs\");\n\nvar debug_1 = tslib_1.__importDefault(require(\"debug\"));\n\nvar command_exists_1 = require(\"command-exists\");\n\nvar rimraf_1 = tslib_1.__importDefault(require(\"rimraf\"));\n\nvar constants_1 = require(\"./constants\");\n\nvar platforms_1 = tslib_1.__importDefault(require(\"./platforms\"));\n\nvar certificate_authority_1 = tslib_1.__importStar(require(\"./certificate-authority\"));\n\nexports.uninstall = certificate_authority_1.uninstall;\n\nvar certificates_1 = tslib_1.__importDefault(require(\"./certificates\"));\n\nvar user_interface_1 = tslib_1.__importDefault(require(\"./user-interface\"));\n\nvar debug = debug_1.default('devcert');\n\nfunction certificateFor(domain) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return tslib_1.__awaiter(this, void 0, void 0, _regeneratorRuntime.mark(function _callee() {\n    var domainKeyPath, domainCertPath, ret;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!constants_1.VALID_IP.test(domain)) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new Error('IP addresses are not supported currently');\n\n          case 2:\n            if (constants_1.VALID_DOMAIN.test(domain)) {\n              _context.next = 4;\n              break;\n            }\n\n            throw new Error(\"\\\"\" + domain + \"\\\" is not a valid domain name.\");\n\n          case 4:\n            debug(\"Certificate requested for \" + domain + \". Skipping certutil install: \" + Boolean(options.skipCertutilInstall) + \". Skipping hosts file: \" + Boolean(options.skipHostsFile));\n\n            if (options.ui) {\n              _extends(user_interface_1.default, options.ui);\n            }\n\n            if (!(!constants_1.isMac && !constants_1.isLinux && !constants_1.isWindows)) {\n              _context.next = 8;\n              break;\n            }\n\n            throw new Error(\"Platform not supported: \\\"\" + process.platform + \"\\\"\");\n\n          case 8:\n            if (command_exists_1.sync('openssl')) {\n              _context.next = 10;\n              break;\n            }\n\n            throw new Error('OpenSSL not found: OpenSSL is required to generate SSL certificates - make sure it is installed and available in your PATH');\n\n          case 10:\n            domainKeyPath = constants_1.pathForDomain(domain, \"private-key.key\");\n            domainCertPath = constants_1.pathForDomain(domain, \"certificate.crt\");\n\n            if (fs_1.existsSync(constants_1.rootCAKeyPath)) {\n              _context.next = 18;\n              break;\n            }\n\n            debug('Root CA is not installed yet, so it must be our first run. Installing root CA ...');\n            _context.next = 16;\n            return certificate_authority_1.default(options);\n\n          case 16:\n            _context.next = 22;\n            break;\n\n          case 18:\n            if (!(options.getCaBuffer || options.getCaPath)) {\n              _context.next = 22;\n              break;\n            }\n\n            debug('Root CA is not readable, but it probably is because an earlier version of devcert locked it. Trying to fix...');\n            _context.next = 22;\n            return certificate_authority_1.ensureCACertReadable(options);\n\n          case 22:\n            if (fs_1.existsSync(constants_1.pathForDomain(domain, \"certificate.crt\"))) {\n              _context.next = 26;\n              break;\n            }\n\n            debug(\"Can't find certificate file for \" + domain + \", so it must be the first request for \" + domain + \". Generating and caching ...\");\n            _context.next = 26;\n            return certificates_1.default(domain);\n\n          case 26:\n            if (options.skipHostsFile) {\n              _context.next = 29;\n              break;\n            }\n\n            _context.next = 29;\n            return platforms_1.default.addDomainToHostFileIfMissing(domain);\n\n          case 29:\n            debug(\"Returning domain certificate\");\n            ret = {\n              key: fs_1.readFileSync(domainKeyPath),\n              cert: fs_1.readFileSync(domainCertPath)\n            };\n            if (options.getCaBuffer) ret.ca = fs_1.readFileSync(constants_1.rootCACertPath);\n            if (options.getCaPath) ret.caPath = constants_1.rootCACertPath;\n            return _context.abrupt(\"return\", ret);\n\n          case 34:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.certificateFor = certificateFor;\n\nfunction hasCertificateFor(domain) {\n  return fs_1.existsSync(constants_1.pathForDomain(domain, \"certificate.crt\"));\n}\n\nexports.hasCertificateFor = hasCertificateFor;\n\nfunction configuredDomains() {\n  return fs_1.readdirSync(constants_1.domainsDir);\n}\n\nexports.configuredDomains = configuredDomains;\n\nfunction removeDomain(domain) {\n  return rimraf_1.default.sync(constants_1.pathForDomain(domain));\n}\n\nexports.removeDomain = removeDomain;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import { readFileSync as readFile, readdirSync as readdir, existsSync as exists } from 'fs';\nimport createDebug from 'debug';\nimport { sync as commandExists } from 'command-exists';\nimport rimraf from 'rimraf';\nimport {\n  isMac,\n  isLinux,\n  isWindows,\n  pathForDomain,\n  domainsDir,\n  rootCAKeyPath,\n  rootCACertPath,\n  VALID_DOMAIN,\n  VALID_IP\n} from './constants';\nimport currentPlatform from './platforms';\nimport installCertificateAuthority, { ensureCACertReadable, uninstall } from './certificate-authority';\nimport generateDomainCertificate from './certificates';\nimport UI, { UserInterface } from './user-interface';\nexport { uninstall };\n\nconst debug = createDebug('devcert');\n\nexport interface Options /* extends Partial<ICaBufferOpts & ICaPathOpts>  */{\n  /** Return the CA certificate data? */\n  getCaBuffer?: boolean;\n  /** Return the path to the CA certificate? */\n  getCaPath?: boolean;\n  /** If `certutil` is not installed already (for updating nss databases; e.g. firefox), do not attempt to install it */\n  skipCertutilInstall?: boolean,\n  /** Do not update your systems host file with the domain name of the certificate */\n  skipHostsFile?: boolean,\n  /** User interface hooks */\n  ui?: UserInterface\n}\n\ninterface ICaBuffer {\n  ca: Buffer;\n}\ninterface ICaPath {\n  caPath: string;\n}\ninterface IDomainData {\n  key: Buffer;\n  cert: Buffer;\n}\ntype IReturnCa<O extends Options> = O['getCaBuffer'] extends true ? ICaBuffer : false;\ntype IReturnCaPath<O extends Options> = O['getCaPath'] extends true ? ICaPath : false;\ntype IReturnData<O extends Options = {}> = (IDomainData) & (IReturnCa<O>) & (IReturnCaPath<O>);\n\n/**\n * Request an SSL certificate for the given app name signed by the devcert root\n * certificate authority. If devcert has previously generated a certificate for\n * that app name on this machine, it will reuse that certificate.\n *\n * If this is the first time devcert is being run on this machine, it will\n * generate and attempt to install a root certificate authority.\n *\n * Returns a promise that resolves with { key, cert }, where `key` and `cert`\n * are Buffers with the contents of the certificate private key and certificate\n * file, respectively\n * \n * If `options.getCaBuffer` is true, return value will include the ca certificate data\n * as { ca: Buffer }\n * \n * If `options.getCaPath` is true, return value will include the ca certificate path\n * as { caPath: string }\n */\nexport async function certificateFor<O extends Options>(domain: string, options: O = {} as O): Promise<IReturnData<O>> {\n  if (VALID_IP.test(domain)) {\n    throw new Error('IP addresses are not supported currently');\n  }\n  if (!VALID_DOMAIN.test(domain)) {\n    throw new Error(`\"${domain}\" is not a valid domain name.`);\n  }\n  debug(`Certificate requested for ${ domain }. Skipping certutil install: ${ Boolean(options.skipCertutilInstall) }. Skipping hosts file: ${ Boolean(options.skipHostsFile) }`);\n\n  if (options.ui) {\n    Object.assign(UI, options.ui);\n  }\n\n  if (!isMac && !isLinux && !isWindows) {\n    throw new Error(`Platform not supported: \"${ process.platform }\"`);\n  }\n\n  if (!commandExists('openssl')) {\n    throw new Error('OpenSSL not found: OpenSSL is required to generate SSL certificates - make sure it is installed and available in your PATH');\n  }\n\n  let domainKeyPath = pathForDomain(domain, `private-key.key`);\n  let domainCertPath = pathForDomain(domain, `certificate.crt`);\n\n  if (!exists(rootCAKeyPath)) {\n    debug('Root CA is not installed yet, so it must be our first run. Installing root CA ...');\n    await installCertificateAuthority(options);\n  } else if (options.getCaBuffer || options.getCaPath) {\n    debug('Root CA is not readable, but it probably is because an earlier version of devcert locked it. Trying to fix...');\n    await ensureCACertReadable(options);\n  }\n\n  if (!exists(pathForDomain(domain, `certificate.crt`))) {\n    debug(`Can't find certificate file for ${ domain }, so it must be the first request for ${ domain }. Generating and caching ...`);\n    await generateDomainCertificate(domain);\n  }\n\n  if (!options.skipHostsFile) {\n    await currentPlatform.addDomainToHostFileIfMissing(domain);\n  }\n\n  debug(`Returning domain certificate`);\n\n  const ret = {\n    key: readFile(domainKeyPath),\n    cert: readFile(domainCertPath)\n  } as IReturnData<O>;\n  if (options.getCaBuffer) (ret as ICaBuffer).ca = readFile(rootCACertPath);\n  if (options.getCaPath) (ret as ICaPath).caPath = rootCACertPath;\n\n  return ret;\n}\n\nexport function hasCertificateFor(domain: string) {\n  return exists(pathForDomain(domain, `certificate.crt`));\n}\n\nexport function configuredDomains() {\n  return readdir(domainsDir);\n}\n\nexport function removeDomain(domain: string) {\n  return rimraf.sync(pathForDomain(domain));\n}\n"],"sourceRoot":"/Users/evanbacon/Documents/GitHub/devcert/"},"metadata":{},"sourceType":"script"}