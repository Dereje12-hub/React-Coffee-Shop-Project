{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _excluded = [\"experimentalImportSupport\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBabelConfig = void 0;\n\nvar fs_1 = __importDefault(require(\"fs\"));\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar resolve_from_1 = __importDefault(require(\"resolve-from\"));\n\nvar getBabelRC = function () {\n  var babelRC = null;\n  return function _getBabelRC(projectRoot, options) {\n    var _a, _b;\n\n    if (babelRC != null) {\n      return babelRC;\n    }\n\n    babelRC = {\n      plugins: []\n    };\n    var projectBabelRCPath;\n\n    if (projectRoot) {\n      projectBabelRCPath = path_1.default.resolve(projectRoot, '.babelrc');\n    }\n\n    if (projectBabelRCPath) {\n      if (!fs_1.default.existsSync(projectBabelRCPath)) {\n        projectBabelRCPath = path_1.default.resolve(projectRoot, '.babelrc.js');\n      }\n\n      if (!fs_1.default.existsSync(projectBabelRCPath)) {\n        projectBabelRCPath = path_1.default.resolve(projectRoot, 'babel.config.js');\n      }\n\n      if (fs_1.default.existsSync(projectBabelRCPath)) {\n        babelRC.extends = projectBabelRCPath;\n      }\n    }\n\n    if (!babelRC.extends) {\n      var experimentalImportSupport = options.experimentalImportSupport,\n          presetOptions = _objectWithoutProperties(options, _excluded);\n\n      var presetPath = (_b = (_a = resolve_from_1.default.silent(projectRoot, 'babel-preset-expo')) !== null && _a !== void 0 ? _a : resolve_from_1.default.silent(projectRoot, 'metro-react-native-babel-preset')) !== null && _b !== void 0 ? _b : require.resolve('babel-preset-expo');\n      babelRC.presets = [[require(presetPath), _objectSpread(_objectSpread({\n        jsxRuntime: 'automatic'\n      }, presetOptions), {}, {\n        disableImportExportTransform: experimentalImportSupport,\n        enableBabelRuntime: options.enableBabelRuntime\n      })]];\n    }\n\n    return babelRC;\n  };\n}();\n\nfunction getBabelConfig(filename, options) {\n  var plugins = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var babelRC = getBabelRC(options.projectRoot, options);\n  var extraConfig = {\n    babelrc: typeof options.enableBabelRCLookup === 'boolean' ? options.enableBabelRCLookup : true,\n    code: false,\n    filename: filename,\n    highlightCode: true\n  };\n\n  var config = _objectSpread(_objectSpread({}, babelRC), extraConfig);\n\n  var extraPlugins = [];\n\n  if (options.inlineRequires) {\n    var inlineRequiresPlugin = resolve_from_1.default(options.projectRoot, 'babel-preset-fbjs/plugins/inline-requires');\n    extraPlugins.push(inlineRequiresPlugin);\n  }\n\n  config.plugins = extraPlugins.concat(config.plugins, plugins);\n\n  if (options.dev && options.hot) {\n    var mayContainEditableReactComponents = filename.indexOf('node_modules') === -1;\n\n    if (mayContainEditableReactComponents) {\n      if (!config.plugins) {\n        config.plugins = [];\n      }\n\n      config.plugins.push(resolve_from_1.default.silent(options.projectRoot, 'react-refresh/babel'));\n    }\n  }\n\n  return _objectSpread(_objectSpread({}, babelRC), config);\n}\n\nexports.getBabelConfig = getBabelConfig;","map":{"version":3,"sources":["../../src/transformer/getBabelConfig.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Expo.\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Forks the default metro-react-native-babel-transformer and adds support for known transforms.\n */\n\nimport type { PluginItem as BabelPlugins, PluginItem } from '@babel/core';\nimport fs from 'fs';\nimport type { BabelTransformerOptions } from 'metro-babel-transformer';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\n\n/**\n * Return a memoized function that checks for the existence of a\n * project level .babelrc file, and if it doesn't exist, reads the\n * default RN babelrc file and uses that.\n */\nconst getBabelRC = (function () {\n  let babelRC: {\n    // `any` to avoid flow type mismatch with Babel 7's internal type of\n    // `Array<string>` even though it correctly accepts the usage below.\n    presets?: any;\n    extends?: string;\n    plugins: BabelPlugins;\n  } | null = null;\n\n  return function _getBabelRC(projectRoot: string, options: BabelTransformerOptions) {\n    if (babelRC != null) {\n      return babelRC;\n    }\n\n    babelRC = { plugins: [] };\n\n    // Let's look for a babel config file in the project root.\n    // TODO look into adding a command line option to specify this location\n    let projectBabelRCPath;\n\n    // .babelrc\n    if (projectRoot) {\n      projectBabelRCPath = path.resolve(projectRoot, '.babelrc');\n    }\n\n    if (projectBabelRCPath) {\n      // .babelrc.js\n      if (!fs.existsSync(projectBabelRCPath)) {\n        projectBabelRCPath = path.resolve(projectRoot, '.babelrc.js');\n      }\n\n      // babel.config.js\n      if (!fs.existsSync(projectBabelRCPath)) {\n        projectBabelRCPath = path.resolve(projectRoot, 'babel.config.js');\n      }\n\n      // If we found a babel config file, extend our config off of it\n      // otherwise the default config will be used\n      if (fs.existsSync(projectBabelRCPath)) {\n        babelRC.extends = projectBabelRCPath;\n      }\n    }\n\n    // If a babel config file doesn't exist in the project then\n    // the default preset for react-native will be used instead.\n    if (!babelRC.extends) {\n      const { experimentalImportSupport, ...presetOptions } = options;\n\n      // Use `babel-preset-expo` instead of `metro-react-native-babel-preset`.\n      const presetPath =\n        resolveFrom.silent(projectRoot, 'babel-preset-expo') ??\n        resolveFrom.silent(projectRoot, 'metro-react-native-babel-preset') ??\n        require.resolve('babel-preset-expo');\n\n      babelRC.presets = [\n        [\n          require(presetPath),\n          {\n            // Default to React 17 automatic JSX transform.\n            jsxRuntime: 'automatic',\n            ...presetOptions,\n            disableImportExportTransform: experimentalImportSupport,\n            enableBabelRuntime: options.enableBabelRuntime,\n          },\n        ],\n      ];\n    }\n\n    return babelRC;\n  };\n})();\n\n/**\n * Given a filename and options, build a Babel\n * config object with the appropriate plugins.\n */\nexport function getBabelConfig(\n  filename: string,\n  options: BabelTransformerOptions,\n  plugins: BabelPlugins = []\n) {\n  const babelRC = getBabelRC(options.projectRoot, options);\n\n  const extraConfig = {\n    babelrc: typeof options.enableBabelRCLookup === 'boolean' ? options.enableBabelRCLookup : true,\n    code: false,\n    filename,\n    highlightCode: true,\n  };\n\n  const config: any = { ...babelRC, ...extraConfig };\n\n  // Add extra plugins\n  const extraPlugins: (string | PluginItem)[] = [];\n\n  // TODO: This probably can be removed\n  if (options.inlineRequires) {\n    const inlineRequiresPlugin = resolveFrom(\n      options.projectRoot,\n      'babel-preset-fbjs/plugins/inline-requires'\n    );\n    extraPlugins.push(inlineRequiresPlugin);\n  }\n\n  config.plugins = extraPlugins.concat(config.plugins, plugins);\n\n  if (options.dev && options.hot) {\n    // Note: this intentionally doesn't include the path separator because\n    // I'm not sure which one it should use on Windows, and false positives\n    // are unlikely anyway. If you later decide to include the separator,\n    // don't forget that the string usually *starts* with \"node_modules\" so\n    // the first one often won't be there.\n    // TODO: Support monorepos\n    const mayContainEditableReactComponents = filename.indexOf('node_modules') === -1;\n\n    if (mayContainEditableReactComponents) {\n      if (!config.plugins) {\n        config.plugins = [];\n      }\n      // Add react refresh runtime.\n      // NOTICE: keep in sync with 'metro-react-native-babel-preset/src/configs/hmr'.\n      config.plugins.push(resolveFrom.silent(options.projectRoot, 'react-refresh/babel'));\n    }\n  }\n\n  return { ...babelRC, ...config };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}