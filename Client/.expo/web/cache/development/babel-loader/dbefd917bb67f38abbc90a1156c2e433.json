{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _url() {\n  var data = _interopRequireDefault(require(\"url\"));\n\n  _url = function _url() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _ws() {\n  var data = require(\"ws\");\n\n  _ws = function _ws() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cliTools() {\n  var data = require(\"@react-native-community/cli-tools\");\n\n  _cliTools = function _cliTools() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar PROTOCOL_VERSION = 2;\n\nfunction parseMessage(data, binary) {\n  if (binary) {\n    _cliTools().logger.error('Expected text message, got binary!');\n\n    return undefined;\n  }\n\n  try {\n    var message = JSON.parse(data);\n\n    if (message.version === PROTOCOL_VERSION) {\n      return message;\n    }\n\n    _cliTools().logger.error(\"Received message had wrong protocol version: \" + message.version);\n  } catch (e) {\n    _cliTools().logger.error(\"Failed to parse the message as JSON:\\n\" + data);\n  }\n\n  return undefined;\n}\n\nfunction isBroadcast(message) {\n  return typeof message.method === 'string' && message.id === undefined && message.target === undefined;\n}\n\nfunction isRequest(message) {\n  return typeof message.method === 'string' && typeof message.target === 'string';\n}\n\nfunction isResponse(message) {\n  return typeof message.id === 'object' && typeof message.id.requestId !== 'undefined' && typeof message.id.clientId === 'string' && (message.result !== undefined || message.error !== undefined);\n}\n\nfunction attachToServer(server, path) {\n  var wss = new (_ws().Server)({\n    server: server,\n    path: path\n  });\n  var clients = new Map();\n  var nextClientId = 0;\n\n  function getClientWs(clientId) {\n    var clientWs = clients.get(clientId);\n\n    if (clientWs === undefined) {\n      throw new Error(\"could not find id \\\"\" + clientId + \"\\\" while forwarding request\");\n    }\n\n    return clientWs;\n  }\n\n  function handleSendBroadcast(broadcasterId, message) {\n    var forwarded = {\n      version: PROTOCOL_VERSION,\n      method: message.method,\n      params: message.params\n    };\n\n    if (clients.size === 0) {\n      _cliTools().logger.warn(\"No apps connected. Sending \\\"\" + message.method + \"\\\" to all React Native apps failed. Make sure your app is running in the simulator or on a phone connected via USB.\");\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(clients), _step; !(_step = _iterator()).done;) {\n      var _ref = _step.value;\n\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      var otherId = _ref2[0];\n      var otherWs = _ref2[1];\n\n      if (otherId !== broadcasterId) {\n        try {\n          otherWs.send(JSON.stringify(forwarded));\n        } catch (e) {\n          _cliTools().logger.error(\"Failed to send broadcast to client: '\" + otherId + \"' \" + (\"due to:\\n \" + e.toString()));\n        }\n      }\n    }\n  }\n\n  wss.on('connection', function (clientWs) {\n    var clientId = \"client#\" + nextClientId++;\n\n    function handleCaughtError(message, error) {\n      var errorMessage = {\n        id: message.id,\n        method: message.method,\n        target: message.target,\n        error: message.error === undefined ? 'undefined' : 'defined',\n        params: message.params === undefined ? 'undefined' : 'defined',\n        result: message.result === undefined ? 'undefined' : 'defined'\n      };\n\n      if (message.id === undefined) {\n        _cliTools().logger.error(\"Handling message from \" + clientId + \" failed with:\\n\" + error + \"\\n\" + (\"message:\\n\" + JSON.stringify(errorMessage)));\n      } else {\n        try {\n          clientWs.send(JSON.stringify({\n            version: PROTOCOL_VERSION,\n            error: error,\n            id: message.id\n          }));\n        } catch (e) {\n          _cliTools().logger.error(\"Failed to reply to \" + clientId + \" with error:\\n\" + error + (\"\\nmessage:\\n\" + JSON.stringify(errorMessage)) + (\"\\ndue to error: \" + e.toString()));\n        }\n      }\n    }\n\n    function handleServerRequest(message) {\n      var result = null;\n\n      switch (message.method) {\n        case 'getid':\n          result = clientId;\n          break;\n\n        case 'getpeers':\n          result = {};\n          clients.forEach(function (otherWs, otherId) {\n            if (clientId !== otherId) {\n              result[otherId] = _url().default.parse(otherWs.upgradeReq.url, true).query;\n            }\n          });\n          break;\n\n        default:\n          throw new Error(\"unknown method: \" + message.method);\n      }\n\n      clientWs.send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        result: result,\n        id: message.id\n      }));\n    }\n\n    function forwardRequest(message) {\n      getClientWs(message.target).send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        method: message.method,\n        params: message.params,\n        id: message.id === undefined ? undefined : {\n          requestId: message.id,\n          clientId: clientId\n        }\n      }));\n    }\n\n    function forwardResponse(message) {\n      if (!message.id) {\n        return;\n      }\n\n      getClientWs(message.id.clientId).send(JSON.stringify({\n        version: PROTOCOL_VERSION,\n        result: message.result,\n        error: message.error,\n        id: message.id.requestId\n      }));\n    }\n\n    clients.set(clientId, clientWs);\n\n    var onCloseHandler = function onCloseHandler() {\n      clientWs.onmessage = null;\n      clients.delete(clientId);\n    };\n\n    clientWs.onclose = onCloseHandler;\n    clientWs.onerror = onCloseHandler;\n\n    clientWs.onmessage = function (event) {\n      var message = parseMessage(event.data, event.binary);\n\n      if (message === undefined) {\n        _cliTools().logger.error('Received message not matching protocol');\n\n        return;\n      }\n\n      try {\n        if (isBroadcast(message)) {\n          handleSendBroadcast(clientId, message);\n        } else if (isRequest(message)) {\n          if (message.target === 'server') {\n            handleServerRequest(message);\n          } else {\n            forwardRequest(message);\n          }\n        } else if (isResponse(message)) {\n          forwardResponse(message);\n        } else {\n          throw new Error('Invalid message, did not match the protocol');\n        }\n      } catch (e) {\n        handleCaughtError(message, e.toString());\n      }\n    };\n  });\n  return {\n    broadcast: function broadcast(method, params) {\n      handleSendBroadcast(null, {\n        method: method,\n        params: params\n      });\n    }\n  };\n}\n\nvar _default = {\n  attachToServer: attachToServer,\n  parseMessage: parseMessage\n};\nexports.default = _default;","map":{"version":3,"sources":["../../src/websocket/messageSocketServer.ts"],"names":["PROTOCOL_VERSION","logger","message","JSON","wss","WebSocketServer","server","path","clients","nextClientId","clientWs","forwarded","version","method","params","otherId","otherWs","e","clientId","errorMessage","id","target","error","result","url","getClientWs","requestId","onCloseHandler","event","parseMessage","isBroadcast","handleSendBroadcast","isRequest","handleServerRequest","forwardRequest","isResponse","forwardResponse","handleCaughtError","broadcast","attachToServer"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport url from 'url';\nimport {Server as WebSocketServer} from 'ws';\nimport {logger} from '@react-native-community/cli-tools';\nimport {Server as HttpServer} from 'http';\nimport {Server as HttpsServer} from 'https';\n\nconst PROTOCOL_VERSION = 2;\n\ntype IdObject = {\n  requestId: string;\n  clientId: string;\n};\n\ntype Message = {\n  version?: string;\n  id?: IdObject;\n  method?: string;\n  target: string;\n  result?: any;\n  error?: Error;\n  params?: Record<string, any>;\n};\n\nfunction parseMessage(data: string, binary: any) {\n  if (binary) {\n    logger.error('Expected text message, got binary!');\n    return undefined;\n  }\n  try {\n    const message = JSON.parse(data);\n    if (message.version === PROTOCOL_VERSION) {\n      return message;\n    }\n    logger.error(\n      `Received message had wrong protocol version: ${message.version}`,\n    );\n  } catch (e) {\n    logger.error(`Failed to parse the message as JSON:\\n${data}`);\n  }\n  return undefined;\n}\n\nfunction isBroadcast(message: Message) {\n  return (\n    typeof message.method === 'string' &&\n    message.id === undefined &&\n    message.target === undefined\n  );\n}\n\nfunction isRequest(message: Message) {\n  return (\n    typeof message.method === 'string' && typeof message.target === 'string'\n  );\n}\n\nfunction isResponse(message: Message) {\n  return (\n    typeof message.id === 'object' &&\n    typeof message.id.requestId !== 'undefined' &&\n    typeof message.id.clientId === 'string' &&\n    (message.result !== undefined || message.error !== undefined)\n  );\n}\n\ntype Server = HttpServer | HttpsServer;\nfunction attachToServer(server: Server, path: string) {\n  const wss = new WebSocketServer({\n    server,\n    path,\n  });\n  const clients = new Map();\n  let nextClientId = 0;\n\n  function getClientWs(clientId: string) {\n    const clientWs = clients.get(clientId);\n    if (clientWs === undefined) {\n      throw new Error(\n        `could not find id \"${clientId}\" while forwarding request`,\n      );\n    }\n    return clientWs;\n  }\n\n  function handleSendBroadcast(\n    broadcasterId: string | null,\n    message: Partial<Message>,\n  ) {\n    const forwarded = {\n      version: PROTOCOL_VERSION,\n      method: message.method,\n      params: message.params,\n    };\n    if (clients.size === 0) {\n      logger.warn(\n        `No apps connected. Sending \"${message.method}\" to all React Native apps failed. Make sure your app is running in the simulator or on a phone connected via USB.`,\n      );\n    }\n    for (const [otherId, otherWs] of clients) {\n      if (otherId !== broadcasterId) {\n        try {\n          otherWs.send(JSON.stringify(forwarded));\n        } catch (e) {\n          logger.error(\n            `Failed to send broadcast to client: '${otherId}' ` +\n              `due to:\\n ${e.toString()}`,\n          );\n        }\n      }\n    }\n  }\n\n  wss.on('connection', (clientWs) => {\n    const clientId = `client#${nextClientId++}`;\n\n    function handleCaughtError(message: Message, error: Error) {\n      const errorMessage = {\n        id: message.id,\n        method: message.method,\n        target: message.target,\n        error: message.error === undefined ? 'undefined' : 'defined',\n        params: message.params === undefined ? 'undefined' : 'defined',\n        result: message.result === undefined ? 'undefined' : 'defined',\n      };\n\n      if (message.id === undefined) {\n        logger.error(\n          `Handling message from ${clientId} failed with:\\n${error}\\n` +\n            `message:\\n${JSON.stringify(errorMessage)}`,\n        );\n      } else {\n        try {\n          clientWs.send(\n            JSON.stringify({\n              version: PROTOCOL_VERSION,\n              error,\n              id: message.id,\n            }),\n          );\n        } catch (e) {\n          logger.error(\n            `Failed to reply to ${clientId} with error:\\n${error}` +\n              `\\nmessage:\\n${JSON.stringify(errorMessage)}` +\n              `\\ndue to error: ${e.toString()}`,\n          );\n        }\n      }\n    }\n\n    function handleServerRequest(message: Message) {\n      let result = null;\n      switch (message.method) {\n        case 'getid':\n          result = clientId;\n          break;\n        case 'getpeers':\n          result = {};\n          clients.forEach((otherWs, otherId) => {\n            if (clientId !== otherId) {\n              result[otherId] = url.parse(otherWs.upgradeReq.url, true).query;\n            }\n          });\n          break;\n        default:\n          throw new Error(`unknown method: ${message.method}`);\n      }\n\n      clientWs.send(\n        JSON.stringify({\n          version: PROTOCOL_VERSION,\n          result,\n          id: message.id,\n        }),\n      );\n    }\n\n    function forwardRequest(message: Message) {\n      getClientWs(message.target).send(\n        JSON.stringify({\n          version: PROTOCOL_VERSION,\n          method: message.method,\n          params: message.params,\n          id:\n            message.id === undefined\n              ? undefined\n              : {requestId: message.id, clientId},\n        }),\n      );\n    }\n\n    function forwardResponse(message: Message) {\n      if (!message.id) {\n        return;\n      }\n      getClientWs(message.id.clientId).send(\n        JSON.stringify({\n          version: PROTOCOL_VERSION,\n          result: message.result,\n          error: message.error,\n          id: message.id.requestId,\n        }),\n      );\n    }\n\n    clients.set(clientId, clientWs);\n    const onCloseHandler = () => {\n      // @ts-ignore\n      clientWs.onmessage = null;\n      clients.delete(clientId);\n    };\n    clientWs.onclose = onCloseHandler;\n    clientWs.onerror = onCloseHandler;\n    clientWs.onmessage = (event: any) => {\n      const message = parseMessage(event.data, event.binary);\n      if (message === undefined) {\n        logger.error('Received message not matching protocol');\n        return;\n      }\n\n      try {\n        if (isBroadcast(message)) {\n          handleSendBroadcast(clientId, message);\n        } else if (isRequest(message)) {\n          if (message.target === 'server') {\n            handleServerRequest(message);\n          } else {\n            forwardRequest(message);\n          }\n        } else if (isResponse(message)) {\n          forwardResponse(message);\n        } else {\n          throw new Error('Invalid message, did not match the protocol');\n        }\n      } catch (e) {\n        handleCaughtError(message, e.toString());\n      }\n    };\n  });\n\n  return {\n    broadcast: (method: string, params?: Record<string, any>) => {\n      handleSendBroadcast(null, {method, params});\n    },\n  };\n}\n\nexport default {attachToServer, parseMessage};\n"]},"metadata":{},"sourceType":"script"}