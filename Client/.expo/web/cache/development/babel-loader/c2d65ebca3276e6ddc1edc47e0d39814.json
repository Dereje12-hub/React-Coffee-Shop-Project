{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar debug_1 = tslib_1.__importDefault(require(\"debug\"));\n\nvar mkdirp_1 = require(\"mkdirp\");\n\nvar fs_1 = require(\"fs\");\n\nvar constants_1 = require(\"./constants\");\n\nvar utils_1 = require(\"./utils\");\n\nvar certificate_authority_1 = require(\"./certificate-authority\");\n\nvar debug = debug_1.default('devcert:certificates');\n\nfunction generateDomainCertificate(domain) {\n  return tslib_1.__awaiter(this, void 0, void 0, _regeneratorRuntime.mark(function _callee() {\n    var domainKeyPath, csrFile, domainCertPath;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            mkdirp_1.sync(constants_1.pathForDomain(domain));\n            debug(\"Generating private key for \" + domain);\n            domainKeyPath = constants_1.pathForDomain(domain, 'private-key.key');\n            generateKey(domainKeyPath);\n            debug(\"Generating certificate signing request for \" + domain);\n            csrFile = constants_1.pathForDomain(domain, \"certificate-signing-request.csr\");\n            constants_1.withDomainSigningRequestConfig(domain, function (configpath) {\n              utils_1.openssl(['req', '-new', '-config', configpath, '-key', domainKeyPath, '-out', csrFile]);\n            });\n            debug(\"Generating certificate for \" + domain + \" from signing request and signing with root CA\");\n            domainCertPath = constants_1.pathForDomain(domain, \"certificate.crt\");\n            _context.next = 11;\n            return certificate_authority_1.withCertificateAuthorityCredentials(function (_ref) {\n              var caKeyPath = _ref.caKeyPath,\n                  caCertPath = _ref.caCertPath;\n              constants_1.withDomainCertificateConfig(domain, function (domainCertConfigPath) {\n                utils_1.openssl(['ca', '-config', domainCertConfigPath, '-in', csrFile, '-out', domainCertPath, '-keyfile', caKeyPath, '-cert', caCertPath, '-days', '825', '-batch']);\n              });\n            });\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.default = generateDomainCertificate;\n\nfunction generateKey(filename) {\n  debug(\"generateKey: \" + filename);\n  utils_1.openssl(['genrsa', '-out', filename, '2048']);\n  fs_1.chmodSync(filename, 400);\n}\n\nexports.generateKey = generateKey;","map":{"version":3,"sources":["certificates.ts"],"names":[],"mappings":";;;;;;;;;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,IAAA,GAAA,OAAA,CAAA,IAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,eAAA;;AACA,IAAA,OAAA,GAAA,OAAA,WAAA;;AACA,IAAA,uBAAA,GAAA,OAAA,2BAAA;;AAEA,IAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,sBAAZ,CAAd;;AASA,SAAA,yBAAA,CAAwD,MAAxD,EAAsE;;;;;;;AACpE,YAAA,QAAA,CAAA,IAAA,CAAO,WAAA,CAAA,aAAA,CAAc,MAAd,CAAP;AAEA,YAAA,KAAK,iCAAgC,MAAhC,CAAL;AACI,YAAA,a,GAAgB,WAAA,CAAA,aAAA,CAAc,MAAd,EAAsB,iBAAtB,C;AACpB,YAAA,WAAW,CAAC,aAAD,CAAX;AAEA,YAAA,KAAK,iDAAgD,MAAhD,CAAL;AACI,YAAA,O,GAAU,WAAA,CAAA,aAAA,CAAc,MAAd,oC;AACd,YAAA,WAAA,CAAA,8BAAA,CAA+B,MAA/B,EAAuC,UAAC,UAAD,EAAe;AACpD,cAAA,OAAA,CAAA,OAAA,CAAQ,CAAC,KAAD,EAAQ,MAAR,EAAgB,SAAhB,EAA2B,UAA3B,EAAuC,MAAvC,EAA+C,aAA/C,EAA8D,MAA9D,EAAsE,OAAtE,CAAR;AACD,aAFD;AAIA,YAAA,KAAK,iCAAgC,MAAhC,oDAAL;AACI,YAAA,c,GAAiB,WAAA,CAAA,aAAA,CAAc,MAAd,oB;;AAErB,mBAAM,uBAAA,CAAA,mCAAA,CAAoC,gBAA8B;AAAA,kBAA3B,SAA2B,QAA3B,SAA2B;AAAA,kBAAhB,UAAgB,QAAhB,UAAgB;AACtE,cAAA,WAAA,CAAA,2BAAA,CAA4B,MAA5B,EAAoC,UAAC,oBAAD,EAAyB;AAC3D,gBAAA,OAAA,CAAA,OAAA,CAAQ,CAAC,IAAD,EAAO,SAAP,EAAkB,oBAAlB,EAAwC,KAAxC,EAA+C,OAA/C,EAAwD,MAAxD,EAAgE,cAAhE,EAAgF,UAAhF,EAA4F,SAA5F,EAAuG,OAAvG,EAAgH,UAAhH,EAA4H,OAA5H,EAAqI,KAArI,EAA4I,QAA5I,CAAR;AACD,eAFD;AAGD,aAJK,CAAN;;;;;;;;;AAKD;;AArBD,OAAA,CAAA,OAAA,GAAA,yBAAA;;AAwBA,SAAA,WAAA,CAA4B,QAA5B,EAA4C;AAC1C,EAAA,KAAK,mBAAkB,QAAlB,CAAL;AACA,EAAA,OAAA,CAAA,OAAA,CAAQ,CAAC,QAAD,EAAW,MAAX,EAAmB,QAAnB,EAA6B,MAA7B,CAAR;AACA,EAAA,IAAA,CAAA,SAAA,CAAM,QAAN,EAAgB,GAAhB;AACD;;AAJD,OAAA,CAAA,WAAA,GAAA,WAAA","sourcesContent":["// import path from 'path';\nimport createDebug from 'debug';\nimport { sync as mkdirp } from 'mkdirp';\nimport { chmodSync as chmod } from 'fs';\nimport { pathForDomain, withDomainSigningRequestConfig, withDomainCertificateConfig } from './constants';\nimport { openssl } from './utils';\nimport { withCertificateAuthorityCredentials } from './certificate-authority';\n\nconst debug = createDebug('devcert:certificates');\n\n/**\n * Generate a domain certificate signed by the devcert root CA. Domain\n * certificates are cached in their own directories under\n * CONFIG_ROOT/domains/<domain>, and reused on subsequent requests. Because the\n * individual domain certificates are signed by the devcert root CA (which was\n * added to the OS/browser trust stores), they are trusted.\n */\nexport default async function generateDomainCertificate(domain: string): Promise<void> {\n  mkdirp(pathForDomain(domain));\n\n  debug(`Generating private key for ${ domain }`);\n  let domainKeyPath = pathForDomain(domain, 'private-key.key');\n  generateKey(domainKeyPath);\n\n  debug(`Generating certificate signing request for ${ domain }`);\n  let csrFile = pathForDomain(domain, `certificate-signing-request.csr`);\n  withDomainSigningRequestConfig(domain, (configpath) => {\n    openssl(['req', '-new', '-config', configpath, '-key', domainKeyPath, '-out', csrFile]);\n  });\n\n  debug(`Generating certificate for ${ domain } from signing request and signing with root CA`);\n  let domainCertPath = pathForDomain(domain, `certificate.crt`);\n\n  await withCertificateAuthorityCredentials(({ caKeyPath, caCertPath }) => {\n    withDomainCertificateConfig(domain, (domainCertConfigPath) => {\n      openssl(['ca', '-config', domainCertConfigPath, '-in', csrFile, '-out', domainCertPath, '-keyfile', caKeyPath, '-cert', caCertPath, '-days', '825', '-batch'])\n    });\n  });\n}\n\n// Generate a cryptographic key, used to sign certificates or certificate signing requests.\nexport function generateKey(filename: string): void {\n  debug(`generateKey: ${ filename }`);\n  openssl(['genrsa', '-out', filename, '2048']);\n  chmod(filename, 400);\n}"],"sourceRoot":"/Users/evanbacon/Documents/GitHub/devcert/"},"metadata":{},"sourceType":"script"}